# 浏览器

**主要功能**: 将用户选择的web资源呈现出来，需要通过请求服务器资源，并将其显示在浏览器窗口中，资源的格式通常为HTML、PDF和image

**浏览器组成结构**

- 用户界面：地址栏、后退/前进按钮、书签目录等【显示访问页面窗口以外的部分】
- 浏览器内核：由渲染引擎和JS引擎组成
  - 渲染引擎：用来显示请求内容，负责解析和渲染页面
  - JS引擎：用来解析执行JS代码
- 网络：用来完成网络调用，如http请求
- UI后端：用来绘制类似组合选择框及对话选择框等基本组件，具有通用接口，底层使用操作系统的用户接口
- 数据储存：属于持久层，负责在硬盘中保存类似cookie的各种数据

***主流渲染引擎**：

| 内核    | 浏览器                                 | JS引擎                   |
| ------- | -------------------------------------- | ------------------------ |
| Trident | IE 4-11                                | JScript，9+chakra        |
| Gecko   | Firefox                                | SpiderMonkey             |
| WebKit  | Safari,Chromium,Chrome，Android 浏览器 | WebCore + JavascriptCore |
| Blink   | Chrome, Opera， Edge                   | V8                       |

**浏览器渲染机制**
*GUI渲染

1. 解析html建立dom树
2. 解析css构建render树（将css代码解析成cssom【树形的数据结构】，然后结合dom合并成render树）
3. 布局render树（Layout/reflow）,负责各元素尺寸，位置的计算
4. 绘制render树（painting），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite）,显示在屏幕上
【GUI引擎和JS引擎互斥，两者必须一个完全处理完毕，另一个才能开始处理】

***渲染卡顿**：页面渲染时间过长，导致卡顿现象
***渲染卡顿优化方式**：优化JS执行效率、降低样式的复杂程度、避免大规模复杂的布局、优先使用渲染层合并属性 控制层数量、JS代码置于页面底部减少渲染影响

# HTML5

*H5的优势在于跨平台，并非是语言跨平台，而是主流浏览器基本实现跨平台，同时可以实现快速迭代、成本较低

**HTML5新特性：**

1. 语义化
2. 存储机制【WebStorage和本地数据库】 
3. 设备兼容性【提供数据与应用接入开放接口，如重力感应、地理定位、摄像头】
4. 连接特性【服务器推送技术，如Websockets】
5. 网页多媒体特性【支持网页端多媒体，如Audio、Video】
6. 三维、图形及特效特性【基于SVG、Canvas、WebGL和CSS3的3D功能】
7. 性能与集成特性【XMLHttpRequest Level2】
8. CSS3特性

## DOCTYPE

*DOCTYPE即Document Type Declaration(文档类型声明，缩写为DTD)，在H5中不需要输入，已经被浏览器提前预设

## 语义化标签(一组新的片段类元素)

*H5出来之前，一般使用div来表示页面头部，章节，页脚等，这些div没有实际意义，所以H5引入了语义化标签来取代命名div的方式

```html
<hgroup></hgroup>//一个网页中可以设置多个<h1>标签
<header></header>//表示网页或section的页眉
<nav></nav>
<section></section>//文档中的节或者段
<article></article>//文章专用标签
<aside></aside>//article元素中的附属信息
<footer></footer>
```

*语义化的优点：

1. HTML5可以让更多更语义化结构化的代码标签代替大量无意义的div标签
2. 这种语义化的特性提高了网页代码的质量和可读性
3. 对搜索引擎更加友好

## attr(属性)&prop(性质)

- attr是从页面搜索(HTML)获取元素值，页面必须明确定义元素才能获取值
- prop是从属性对象(JS对象)中取值，对象有多少属性就能取得多少值

*如何选择：

对于HTML元素本身就带有的固有属性，在处理时，使用prop方法更快速，准确

对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法

例如： 

```js
<input id="chke1" type="checkbox" />记住密码
<input id="chke2" type="checkbox" checked="checked" />记住密码

//不同返回值
$("#chke1").prop("checked");// false
$("#chke2").prop("checked");// true
   
$("#chke1").attr("checked"); //undefined
$("#chke2").attr("checked"); //"checked"
```

*本质上attr也是一种特殊prop，不过它存放的是标签的自定义和预定义属性

```js
var a=document.querySlelctor('input[type=checkbox]');
a.setAttribute('checked','checked1'); //attr
a.checked=true; //prop
//checked是一个布尔值属性,a是非布尔值属性
```

*布尔值属性：prop是布尔值类型 / 非布尔值属性：prop是非布尔值属性

*在非布尔值属性的情况下无论如何prop和attr值始终实时同步

*布尔值属性下改变prop值时不会同步attr / 在没有动过prop时，改变attr会同步prop但是prop一旦改变，attr同步即失效，attr将不在变动=

*用户操作的是prop，浏览器也只认prop

## dataset

*HTML5提供了dataset API，可以更方便的 设定 / 获取 元素所有的自定义属性

```vue
//一般情况自定义属性只能通过setAttribute/getAttribute方法修改
<div class="div1" xx="xxx"></div>
<script>  
     let div=document.querySelector('.div1');
     div.setAttribute('xx','xxxx');
</script>

//新增了一种dataset方法,自定义元素命名需要加入data-
<div class="div1" data-xx="xxx"></div>
<script>  
     let div=document.querySelector('.div1');
     div.dataset.xx='xxxx';
</script>
```

## classList

*H5新增的api，原生JS可以通过它判断或者获取dom节点，通过class属性

1. length:获取元素名的个数

   ```js
   var len=document.body.classList.length
   ```

2. item(number):获取元素类名，接受一个参数--即可以数字索引

   ```js
   //超出index范围即返回null
   var cls=document.body.classList.item(index);
   ```

3. add(String):可以给元素增加类名，类似jQuery中的addClass()

   ```js
   document.body.classList.add('myclass');
   //遗憾的是，它一次性只能增加一个类名
   ```

4. remove:可以删除元素类名，类似jQuery中的removeClass()

   ```js
   document.body.classList.remove('myclass');
   ```

5. toggle:包含add和remove的方法

   ```js
   document.body.classList.toggle('myclass');
   //当只有一个参数时：切换 class value，即如果类存在，则删除它并返回false，如果不存在，则添加它并返回true
   //当存在第二个参数时：如果第二个参数的计算结果为true，则添加指定的类值，如果计算结果为false，则删除它
   ```

6. contains:检测元素是否包含这个类名，返回true或者false

   ```js
   document.body.classList.contains('myclass'); 
   //返回true或者false
   ```

## Cookie&WebStorage

**Cookie&session**

*用来跟踪浏览器用户身份的会话方式，可以保存相应的会话信息

|          | Cookie                                                       | session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 保存状态 | 保存在浏览器端                                               | 保存在服务器端                                               |
| 机制     | 在后端未设置过期时间【maxAge】的情况下，被保存在内存，随浏览器关闭结束；设置了过期时间则保存在硬盘中，直到过期时间才消失；它以文本的方式保存在客户端，每次请求都带上 | 服务器受到请求需要创建seesion时，会先检查客户端请求中是否包含sessionID，有就返回session没有就返回session+sessionID；sessionID以cookie方式储存 |
| 存储内容 | 字符串类型，以文本方式                                       | 任何类型                                                     |
| 大小     | 不超过4kb                                                    | 没有限制                                                     |
| 安全性   | 低                                                           | 高                                                           |
| 应用场景 | 判断用户是否登录过，实现自动登录或记住密码功能；保存上次登录的时间等信息；保存上次查看页面；浏览计数 | 保存用户专用的信息，变量值保存在服务器端，通过sessionID区分用户；不同页面的共用用户信息；购物车 |

**localStorage&sessionStorage**

*同属于H5的webStorage，用来改善cookie的存储机制【cookie跟随http head发送，浪费带宽】，提供存储大量可以跨会话存在的数据的功能

|          | localStorage               | sesssionStorage            |
| -------- | -------------------------- | -------------------------- |
| 生命周期 | 永久                       | 页面存在时有效             |
| 大小     | 5mb                        | 5mb                        |
| 存储位置 | 客户端，不与服务器交互通信 | 客户端，不与服务器交互通信 |
| 存储类型 | 字符串类型                 | 字符串类型                 |
| 应用场景 | 保持长期登录状态           | 敏感账号一次性登录状态     |

| localStorage/sessionStorage API规则 | 用法                   |
| ----------------------------------- | ---------------------- |
| localStorage.getItem("key")         | 读取key中的数据        |
| localStorage.setItem("key","value") | 将value数据存储到key中 |
| localStorage.removeItem("key")      | 删除key信息            |
| localStorage.clear()                | 清空所有信息           |

**WebStorage对比Cookie**

- 存储空间更大
- 节省流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像Cookie一样每次请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量
- 速度极快：获取本地数据比获取服务端数据快很多
- 安全性：WebStorage不随请求头到服务器端，安全性高
- 操作简单：提供了便捷的API

## IndexedDB

**IndexedDB是什么：**浏览器提供的本地数据库，可以被网页脚本创建和操作，它允许储存大量数据，提供查找接口，还可以建立索引。它不属于关系型数据库，本质上接近NoSQL数据库

*本地数据库解决问题：浏览器功能的增强，数据量越来越大，大部分网站考虑将数据储存再客户端以此减轻服务器处理请求的压力

Cookie不适合储存大量数据，LocalStorage储存的数据不提供搜索功能，不能建立自定义索引，由此诞生了IndexedDB

### IndexedDB特性：

1. 键值对储存： IndexedDB 内部采用对象仓库（object store）存放数据，所有类型的数据都可以直接存入，对象仓库中，数据以"键值对"的形式保存
2. 异步：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的，所以不会影响网页渲染
3. 支持事务：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况
4. 同源限制：每一个数据库对应创建它的域名，不可以跨域访问数据库
5. 储存空间大：不少于250MB，没有上限
6. 支持二进制储存：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）

### IndexedDB API
1.打开数据库
```js
var request = window.indexedDB.open(databaseName,version)
//返回一个IDBRequset对象，对象通过error、success和upgradeneeded处理打开数据库的结果

//-----error事件------
request.onerror = function(event){
	console.log('数据库打开错误')
}

//-----success事件------
var db
request.onsuccess = function(event){
	db = requset.result
	console.log('数据库打开成功')
}

//-----upgradeneeded事件------
var db
request.onupgradeneeded = function(event){
	db = event.target.result
}
```

2.新建数据库
*新建数据库和打开数据库是同一个操作，如果指定的数据库不存在则会新建一个数据库，不同之处在于后续的操作主要在upgradeneeded事件的监听函数中完成
```js
request.onupgradeneeded = function(event) {
  db = event.target.result;
  //新建数据库的第一个步骤就是新建对象仓库，可以先判断仓库是否存在
  var objectStore
  if (!db.objectStoreNames.contains('person')) {
    objectStore = db.createObjectStore('person', { keyPath: 'id' });
    //------新建索引------
    objectStore.createIndex('name', 'name', { unique: false });
  	objectStore.createIndex('email', 'email', { unique: true });
  	//IDBOject.createIndex三个参数对应索引名称，索引对应的属性，配置对象是否包含重复值
  }
}

```
3. 新增数据
*通过事务实现向对象仓库写入数据
```js
function add() {
//新建一个事务，必须指定名称和操作模式【只读/读写】
  var request = db.transaction(['person'], 'readwrite')
  	//通过objectStore拿到IDBObjectStore对象
    .objectStore('person')
    //通过表格对象的add()方法，向表格写入
    .add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });
//写入操作时异步操作，通过监听连接对象的success事件和error事件判断写入成功
  request.onsuccess = function (event) {
    console.log('数据写入成功');
  };
  request.onerror = function (event) {
    console.log('数据写入失败');
  }
}

add();
```
4. 读取数据
*通过事务读取数据
```js
function read() {
   var transaction = db.transaction(['person']);
   var objectStore = transaction.objectStore('person');
   var request = objectStore.get(1);

   request.onerror = function(event) {
     console.log('事务失败');
   };

   request.onsuccess = function( event) {
      if (request.result) {
        console.log('Name: ' + request.result.name);
        console.log('Age: ' + request.result.age);
        console.log('Email: ' + request.result.email);
      } else {
        console.log('未获得数据记录');
      }
   };
}

read();
```
5. 遍历数据
*使用指针对象IDBCursor遍历数据表格所有记录
```js
function readAll() {
  var objectStore = db.transaction('person').objectStore('person');
	//openCursor()方法是一个异步操作，所以需要监听success事件
   objectStore.openCursor().onsuccess = function (event) {
     var cursor = event.target.result;
     if (cursor) {
       console.log('Id: ' + cursor.key);
       console.log('Name: ' + cursor.value.name);
       console.log('Age: ' + cursor.value.age);
       console.log('Email: ' + cursor.value.email);
       cursor.continue();
    } else {
      console.log('没有更多数据了！');
    }
  };
}

readAll();
```
6. 更新数据
```js
function update() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    //使用put()方法更新数据
    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });

  request.onsuccess = function (event) {
    console.log('数据更新成功');
  };

  request.onerror = function (event) {
    console.log('数据更新失败');
  }
}

update();
```
7. 删除数据
```js
function remove() {
  var request = db.transaction(['person'], 'readwrite')
    .objectStore('person')
    //delete()删除数据
    .delete(1);

  request.onsuccess = function (event) {
    console.log('数据删除成功');
  };
}

remove();
```
8. 索引数据
*索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）
```js
//建立表格时，添加了name字段的索引
objectStore.createIndex('name', 'name', { unique: false });

var transaction = db.transaction(['person'], 'readonly');
var store = transaction.objectStore('person');
var index = store.index('name');
var request = index.get('李四');

request.onsuccess = function (e) {
  var result = e.target.result;
  if (result) {
    // ...
  } else {
    // ...
  }
}
```

# CSS&CSS3

## CSS尺寸

| 单位 | 用途                                                         |
| ---- | ------------------------------------------------------------ |
| px   | 1px等于1个物理像素点                                         |
| em   | em是相对于父元素的font-size而计算的。如果当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体(16px)尺寸【谷歌浏览器强制最小字体为12】 |
| rem  | rem是相对于根元素html的参考值的em                            |
| %    | 相对于父元素的百分比尺寸                                     |
| vw   | 视窗宽度，1vw等于视窗宽度的1%【在出现竖向滚动条的时候vw=%+滚动条的宽度】 |
| vh   | 视窗高度，1vh = 浏览器高度的1%                               |
| vm   | vmin&vmax，1vmax=浏览器宽度/100px&1vmin=浏览器高度/100px     |



## CSS选择器

基本选择器：

- 标签选择器：针对一类标签
- ID选择器：针对某一个特定的标签使用
- 类选择器：针对你想要的所有标签使用
- 通用选择器（通配符*）：针对所有的标签都适用（不建议使用）

选择器权重比：行内样式---1000  ID---100  属性/类/伪类---10  通用---1

高级选择器：

- 后代选择器：用空格隔开
- 交集选择器：用`.`隔开
- 并集选择器（分组选择器）：用逗号隔开
- 伪类选择器
- 序选择器：first-child / last-child
- 兄弟选择器：+ (选择下一个兄弟)

## CSS3选择器

| 选择器                                                       | 例子                  | 例子描述                                                     | CSS  |
| :----------------------------------------------------------- | :-------------------- | :----------------------------------------------------------- | :--- |
| [.*class*](https://www.w3school.com.cn/cssref/selector_class.asp) | .intro                | 选择 class="intro" 的所有元素                                | 1    |
| [#*id*](https://www.w3school.com.cn/cssref/selector_id.asp)  | #firstname            | 选择 id="firstname" 的所有元素                               | 1    |
| [*](https://www.w3school.com.cn/cssref/selector_all.asp)     | *                     | 选择所有元素                                                 | 2    |
| [*element*](https://www.w3school.com.cn/cssref/selector_element.asp) | p                     | 选择所有 <p> 元素                                            | 1    |
| [*element*,*element*](https://www.w3school.com.cn/cssref/selector_element_comma.asp) | div,p                 | 选择所有 <div> 元素和所有 <p> 元素                           | 1    |
| [*element* *element*](https://www.w3school.com.cn/cssref/selector_element_element.asp) | div p                 | 选择 <div> 元素内部的所有 <p> 元素                           | 1    |
| [*element*>*element*](https://www.w3school.com.cn/cssref/selector_element_gt.asp) | div>p                 | 选择父元素为 <div> 元素的所有 <p> 元素                       | 2    |
| [*element*+*element*](https://www.w3school.com.cn/cssref/selector_element_plus.asp) | div+p                 | 选择紧接在 <div> 元素之后的所有 <p> 元素                     | 2    |
| [[*attribute*\]](https://www.w3school.com.cn/cssref/selector_attribute.asp) | [target]              | 选择带有 target 属性所有元素                                 | 2    |
| [[*attribute*=*value*\]](https://www.w3school.com.cn/cssref/selector_attribute_value.asp) | [target=_blank]       | 选择 target="_blank" 的所有元素                              | 2    |
| [[*attribute*~=*value*\]](https://www.w3school.com.cn/cssref/selector_attribute_value_contain.asp) | [title~=flower]       | 选择 title 属性包含单词 "flower" 的所有元素                  | 2    |
| [[*attribute*\|=*value*\]](https://www.w3school.com.cn/cssref/selector_attribute_value_start.asp) | [lang\|=en]           | 选择 lang 属性值以 "en" 开头的所有元素                       | 2    |
| [:link](https://www.w3school.com.cn/cssref/selector_link.asp) | a:link                | 选择所有未被访问的链接                                       | 1    |
| [:visited](https://www.w3school.com.cn/cssref/selector_visited.asp) | a:visited             | 选择所有已被访问的链接                                       | 1    |
| [:active](https://www.w3school.com.cn/cssref/selector_active.asp) | a:active              | 选择活动链接                                                 | 1    |
| [:hover](https://www.w3school.com.cn/cssref/selector_hover.asp) | a:hover               | 选择鼠标指针位于其上的链接                                   | 1    |
| [:focus](https://www.w3school.com.cn/cssref/selector_focus.asp) | input:focus           | 选择获得焦点的 input 元素                                    | 2    |
| [:first-letter](https://www.w3school.com.cn/cssref/selector_first-letter.asp) | p:first-letter        | 选择每个 <p> 元素的首字母                                    | 1    |
| [:first-line](https://www.w3school.com.cn/cssref/selector_first-line.asp) | p:first-line          | 选择每个 <p> 元素的首行                                      | 1    |
| [:first-child](https://www.w3school.com.cn/cssref/selector_first-child.asp) | p:first-child         | 选择属于父元素的第一个子元素的每个 <p> 元素                  | 2    |
| [:before](https://www.w3school.com.cn/cssref/selector_before.asp) | p:before              | 在每个 <p> 元素的内容之前插入内容【before里必须加上 content:' '；才能正常显示 】 | 2    |
| [:after](https://www.w3school.com.cn/cssref/selector_after.asp) | p:after               | 在每个 <p> 元素的内容之后插入内容【after里必须加上 content:' '；才能正常显示 】 | 2    |
| [:lang(*language*)](https://www.w3school.com.cn/cssref/selector_lang.asp) | p:lang(it)            | 选择带有以 "it" 开头的 lang 属性值的每个 <p> 元素            | 2    |
| [*element1*~*element2*](https://www.w3school.com.cn/cssref/selector_gen_sibling.asp) | p~ul                  | 选择前面有 <p> 元素的每个 <ul> 元素                          | 3    |
| [[*attribute*^=*value*\]](https://www.w3school.com.cn/cssref/selector_attr_begin.asp) | a[src^="https"]       | 选择其 src 属性值以 "https" 开头的每个 <a> 元素              | 3    |
| [[*attribute*$=*value*\]](https://www.w3school.com.cn/cssref/selector_attr_end.asp) | a[src$=".pdf"]        | 选择其 src 属性以 ".pdf" 结尾的所有 <a> 元素                 | 3    |
| [[*attribute**=*value*\]](https://www.w3school.com.cn/cssref/selector_attr_contain.asp) | a[src*="abc"]         | 选择其 src 属性中包含 "abc" 子串的每个 <a> 元素              | 3    |
| [:first-of-type](https://www.w3school.com.cn/cssref/selector_first-of-type.asp) | p:first-of-type       | 选择属于其父元素的首个 <p> 元素的每个 <p> 元素               | 3    |
| [:last-of-type](https://www.w3school.com.cn/cssref/selector_last-of-type.asp) | p:last-of-type        | 选择属于其父元素的最后 <p> 元素的每个 <p> 元素               | 3    |
| [:only-of-type](https://www.w3school.com.cn/cssref/selector_only-of-type.asp) | p:only-of-type        | 选择属于其父元素唯一的 <p> 元素的每个 <p> 元素               | 3    |
| [:only-child](https://www.w3school.com.cn/cssref/selector_only-child.asp) | p:only-child          | 选择属于其父元素的唯一子元素的每个 <p> 元素                  | 3    |
| [:nth-child(*n*)](https://www.w3school.com.cn/cssref/selector_nth-child.asp) | p:nth-child(2)        | 选择属于其父元素的第二个子元素的每个 <p> 元素 【(odd)或(even)表示选择奇数个和偶数个子元素】 | 3    |
| [:nth-last-child(*n*)](https://www.w3school.com.cn/cssref/selector_nth-last-child.asp) | p:nth-last-child(2)   | 同上，从最后一个子元素开始计数                               | 3    |
| [:nth-of-type(*n*)](https://www.w3school.com.cn/cssref/selector_nth-of-type.asp) | p:nth-of-type(2)      | 选择属于其父元素第二个 <p> 元素的每个 <p> 元素               | 3    |
| [:nth-last-of-type(*n*)](https://www.w3school.com.cn/cssref/selector_nth-last-of-type.asp) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数                           | 3    |
| [:last-child](https://www.w3school.com.cn/cssref/selector_last-child.asp) | p:last-child          | 选择属于其父元素最后一个子元素每个 <p> 元素                  | 3    |
| [:root](https://www.w3school.com.cn/cssref/selector_root.asp) | :root                 | 选择文档的根元素                                             | 3    |
| [:empty](https://www.w3school.com.cn/cssref/selector_empty.asp) | p:empty               | 选择没有子元素的每个 <p> 元素（包括文本节点）                | 3    |
| [:target](https://www.w3school.com.cn/cssref/selector_target.asp) | #news:target          | 选择当前活动的 #news 元素                                    | 3    |
| [:enabled](https://www.w3school.com.cn/cssref/selector_enabled.asp) | input:enabled         | 选择每个启用的 <input> 元素                                  | 3    |
| [:disabled](https://www.w3school.com.cn/cssref/selector_disabled.asp) | input:disabled        | 选择每个禁用的 <input> 元素                                  | 3    |
| [:checked](https://www.w3school.com.cn/cssref/selector_checked.asp) | input:checked         | 选择每个被选中的 <input> 元素                                | 3    |
| [:not(*selector*)](https://www.w3school.com.cn/cssref/selector_not.asp) | :not(p)               | 选择非 <p> 元素的每个元素                                    | 3    |
| [::selection](https://www.w3school.com.cn/cssref/selector_selection.asp) | ::selection           | 选择被用户选取的元素部分                                     | 3    |

## CSS变量

*自定义属性（有时候也被称作CSS变量或者级联变量）是由CSS作者定义，它包含的值可以在整个文档中重复使用

**声明和使用：**

```css
//声明一个变量
element{
    --main-bg-color:#fff;
}
//使用这个变量
element{
    background-color: var(--main-bg-color);
}
```

*将重复使用的CSS值语义化，方便其他地方使用

```css
//css变量一般在:root组件中声明
:root{
    --color: #fff;
    --background-color: #333;
}
```





## CSS3颜色定义HSLA

css3新增HSLA(H,S,L,A)颜色设置方法 的参数说明：
H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360
S：Saturation(饱和度)。取值为：0.0% - 100.0%
L：Lightness(亮度)。取值为：0.0% - 100.0%
A：Alpha透明度。取值0~1之间。
注：此色彩模式与HSL相同，只是在HSL模式上新增了Alpha透明度 ，SL不要省略%符号

## CSS3盒子模型

- content-box ==> width和height只包括内容宽高，不包括边框和内外边距
- border-box ==> width和height包括内容宽高和内边距及边框的宽高，但是不包括外边距

用法：box-sizing : border-box

```css
  ul{
    overflow: hidden;
    width: 400px;
    height: 400px;
    background-color: #fff;
    margin: 100px auto;
  }
  li{
    float:left;
    width: 25%;
  // content-box情况下，宽度设置为25%，在有4个li的情况下应该是正好可以撑满ul一整行
  // 但是因为content-box不包括内外边距，所以最后一个li会换行
    height: 100px;
    border: 10px solid #9a8;
  // 这里将默认的content-box设置为border-box
  // 就可以解决换行问题，因为border-box设置包括内边距
    box-sizing: border-box;
  }
```

## @media多媒体查询

语法：@mediatype and | not | only (media feature) { css-code; }

*尺寸判断举例：

```css
页面宽度等于960px尺寸
@media screen and (max-device-width:960px){
    body{background:red;}
}
页面宽度大于960px
@media screen and (min-width:960px){ 
    body{background:orange;}
}
页面宽度大于960px小于1200px
@media screen and (min-width:960px) and (max-width:1200px){
    body{background:yellow;}
}
```

**@media所有参数：**
|值	|描述|
|------|-------|
|aspect-ratio	|定义输出设备中的页面可见区域宽度与高度的比率|
|color	|定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0|
|color-index	|定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0|
|device-aspect-ratio	|定义输出设备的屏幕可见宽度与高度的比率|
|device-height	|定义输出设备的屏幕可见高度|
|device-width	|定义输出设备的屏幕可见宽度|
|grid	|用来查询输出设备是否使用栅格或点阵|
|height	|定义输出设备中的页面可见区域高度|
|max-aspect-ratio	|定义输出设备的屏幕可见宽度与高度的最大比率|
|max-color	|定义输出设备每一组彩色原件的最大个数|
|max-color-index	|定义在输出设备的彩色查询表中的最大条目数|
|max-device-aspect-ratio	|定义输出设备的屏幕可见宽度与高度的最大比率|
|max-device-height	|定义输出设备的屏幕可见的最大高度|
|max-device-width	|定义输出设备的屏幕最大可见宽度|
|max-height	|定义输出设备中的页面最大可见区域高度|
|max-monochrome	|定义在一个单色框架缓冲区中每像素包含的最大单色原件个数|
|max-resolution	|定义设备的最大分辨率|
|max-width	|定义输出设备中的页面最大可见区域宽度|
|min-aspect-ratio	|定义输出设备中的页面可见区域宽度与高度的最小比率|
|min-color	|定义输出设备每一组彩色原件的最小个数|
|min-color-index	|定义在输出设备的彩色查询表中的最小条目数|
|min-device-aspect-ratio	|定义输出设备的屏幕可见宽度与高度的最小比率|
|min-device-width	|定义输出设备的屏幕最小可见宽度|
|min-device-height	|定义输出设备的屏幕的最小可见高度|
|min-height	|定义输出设备中的页面最小可见区域高度|
|min-monochrome	|定义在一个单色框架缓冲区中每像素包含的最小单色原件个数|
|min-resolution	|定义设备的最小分辨率|
|min-width	|定义输出设备中的页面最小可见区域宽度|
|monochrome	|定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0|
|orientation	|定义输出设备中的页面可见区域高度是否大于或等于宽度|
|resolution	|定义设备的分辨率【如：96dpi, 300dpi, 118dpcm】|
|scan	|定义电视类设备的扫描工序|
|width	|定义输出设备中的页面可见区域宽度|

具体使用方法：
```css
(max-width:599px) 
(min-width:600px) 
(orientation:portrait) 竖屏
(orientation:landscape)        横屏css
(-webkit-min-device-pixel-ratio: 2) 像素比
```
**媒体类型：**

| 类型   | 说明                               |
| ------ | ---------------------------------- |
| all    | 所有媒体                           |
| print  | 用于打印机和打印预览               |
| screen | 用于电脑屏幕，平板电脑，智能手机等 |
| speech | 应用于屏幕阅读器等发声设备         |

**关键字：**

| 关键字 | 说明                   |
| ------ | ---------------------- |
| and    | 包括某种制定的媒体类型 |
| not    | 排除某种制定的媒体类型 |
| only   | 限定某种特定的媒体类型 |

具体使用方法：

```css
@media only screen and (max-width: 500px) {
    .gridmenu {
        width:100%;
    }

    .gridmain {
        width:100%;
    }

    .gridright {
        width:100%;
    }
}
```




## animation

animation是一个简写属性，用于设置六个动画属性，需要配合@keyframe使用

语法：animation: name duration timing-function delay iteration-count direction;

| 值                                                           | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| *[animation-name](https://www.w3school.com.cn/cssref/pr_animation-name.asp)* | 规定需要绑定到选择器的 keyframe 名称。。                     |
| *[animation-duration](https://www.w3school.com.cn/cssref/pr_animation-duration.asp)* | 规定完成动画所花费的时间，以秒或毫秒计。                     |
| *[animation-timing-function](https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp)* | 规定动画的速度曲线。                                         |
| *[animation-delay](https://www.w3school.com.cn/cssref/pr_animation-delay.asp)* | 规定在动画开始之前的延迟。                                   |
| *[animation-iteration-count](https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp)* | 规定动画应该播放的次数。                                     |
| *[animation-direction](https://www.w3school.com.cn/cssref/pr_animation-direction.asp)* | 规定是否应该轮流反向播放动画。【normal默认播放一次，alternate动画轮流反向播放】 |

**@keyframes**

通过@keyframes规则，创建动画【原理是将一套CSS样式逐渐转化为另一套CSS样式】

以百分比来规定改变发生的事件，或者通过关键词"from"和"to"，等价于0%和100%

0%是动画开始，100%动画结束

语法：@keyframes animationname {keyframes-selector {css-styles;}}

| 值                   | 描述                                                         |
| :------------------- | :----------------------------------------------------------- |
| *animationname*      | 必需。定义动画的名称。                                       |
| *keyframes-selector* | 必需。动画时长的百分比。合法的值：0-100%from（与 0% 相同）to（与 100% 相同） |
| *css-styles*         | 必需。一个或多个合法的 CSS 样式属性。                        |

## background

### background-clip

根据盒模型区域裁剪背景图片

语法：background-clip: border-box|padding-box|content-box;

| 值          | 描述                   |
| :---------- | :--------------------- |
| border-box  | 背景被裁剪到边框盒。   |
| padding-box | 背景被裁剪到内边距框。 |
| content-box | 背景被裁剪到内容框。   |

### background-origin

设置背景图片的左上角起始定位

语法：background-origin: padding-box|border-box|content-box;

注意：当使用background-attachment：fixed【固定背景图位置】后，该属性失效

| 值          | 描述                           |
| :---------- | :----------------------------- |
| padding-box | 背景图像在内边距框以内定位显示 |
| border-box  | 背景图像在盒边框以内定位显示   |
| content-box | 背景图像在盒内容以内定位显示   |

### background-position

 设置背景图片初始位置，主要用来给精灵图定位

```css
//几种设置方式
最常用的是:background-position: Xpx Ypx;定位
/* Keyword values */
background-position: top;
background-position: bottom;
background-position: left;
background-position: right;
background-position: center;

/* <percentage> values */
background-position: 25% 75%;

/* <length> values */
background-position: 0 0;
background-position: 1cm 2cm;
background-position: 10ch 8em;

/* Multiple images */
background-position: 0 0, center;

/* Edge offsets values */
background-position: bottom 10px right 20px;
background-position: right 3em bottom 10px;
background-position: bottom 10px right;
background-position: top right 10px;

/* Global values */
background-position: inherit;
background-position: initial;
background-position: unset;
```

### background-size

设置背景图片的填充样式【建立在no-repeat基础上】

语法：background-size: length|percentage|cover|contain

background-size: 50% 50% 宽高 //100px 100px 宽高

| 值           | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *length*     | 设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"。 |
| *percentage* | 以父元素的百分比来设置背景图像的宽度和高度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 "auto"。 |
| cover        | 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 |
| contain      | 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 |

## box-shadow

```css
box-shadow: a b c d #color
a:offset-x  b:offset-y  c:blur-size  d:spread-size 
//外部阴影
<div  style="box-shadow:-10px 0px 10px red,   /*左边阴影*/              
                    0px -10px 10px #000,  /*上边阴影*/               
                   10px 0px 10px green,  /*右边阴影*/  
                    0px 10px 10px blue;" /*下边阴影*/ > 
</div>
//阴影分成两个部分 无渐变的阴影和有渐变的阴影
//最后一个参数决定的是 渐变到无效果 阴影的的长度
//内部阴影
<div  style="box-shadow:-10px 0px 10px red inset /*左内阴影*/
```

## border-radius

css3矩形圆角设置

写法：border-radius 1px 2px 3px 4px;

从左上到左下的顺时针顺序设置矩形的四个角的圆角弧度半径大小

border-(top/bottom)-(left/right)-radius: 1px  /  1px 2px

单独设置一个角的圆角度，一个参数就是设置圆角半径 / 两个参数是设置椭圆

## border-image

| 值                    | 描述                                                         |
| :-------------------- | :----------------------------------------------------------- |
| *border-image-source* | 用在边框的图片的路径。                                       |
| *border-image-slice*  | 图片边框向内偏移。                                           |
| *border-image-width*  | 图片边框的宽度                                               |
| *border-image-outset* | 边框图像区域超出边框的量。                                   |
| *border-image-repeat* | 图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。 |

## cursor

定义了达到特定元素区域时光标的样式

| 值        | 描述                                                         |
| :-------- | :----------------------------------------------------------- |
| *url*     | 需使用的自定义光标的 URL。注释：请在此列表的末端始终定义一种普通的光标，以防没有由 URL 定义的可用光标 |
| default   | 默认光标（通常是一个箭头）                                   |
| auto      | 默认  浏览器设置的光标                                       |
| crosshair | 光标呈现为十字线                                             |
| pointer   | 光标呈现为指示链接的指针（一只手）                           |
| move      | 此光标指示某对象可被移动                                     |
| e-resize  | 此光标指示矩形框的边缘可被向右（东）移动                     |
| ne-resize | 此光标指示矩形框的边缘可被向上及向右移动（北/东）            |
| nw-resize | 此光标指示矩形框的边缘可被向上及向左移动（北/西）            |
| n-resize  | 此光标指示矩形框的边缘可被向上（北）移动                     |
| se-resize | 此光标指示矩形框的边缘可被向下及向右移动（南/东）            |
| sw-resize | 此光标指示矩形框的边缘可被向下及向左移动（南/西）            |
| s-resize  | 此光标指示矩形框的边缘可被向下移动（南）                     |
| w-resize  | 此光标指示矩形框的边缘可被向左移动（西）                     |
| text      | 此光标指示文本                                               |
| wait      | 此光标指示程序正忙（通常是一只表或沙漏）                     |
| help      | 此光标指示可用的帮助（通常是一个问号或一个气球）             |

## filter
CSS3定义的一种滤镜特效函数【高斯模糊】

语法：filter:blur(多少px)

| Filter                                             | 描述                                                         |
| :------------------------------------------------- | :----------------------------------------------------------- |
| none                                               | 默认值，没有效果。                                           |
| blur(*px*)                                         | 给图像设置高斯模糊。"radius"一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；  如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。 |
| brightness(*%*)                                    | 给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。 |
| contrast(*%*)                                      | 调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。 |
| drop-shadow(*h-shadow v-shadow blur spread color*) | 给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受<shadow>(在CSS3背景中定义)类型的值，除了"inset"关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。`参数如下：``**** **** (必须)这是设置阴影偏移量的两个 值. **** 设定水平方向距离. 负值会使阴影出现在元素左边. ****设定垂直距离.负值会使阴影出现在元素上方。查看****可能的单位.**如果两个值都是0**, 则阴影出现在元素正后面 (如果设置了 and/or ，会有模糊效果).**** (可选)这是第三个code>值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利).**** (可选)这是第四个 值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小). 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 **** (可选)查看 该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用color**color**属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。` |
| grayscale(*%*)                                     | 将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； |
| hue-rotate(*deg*)                                  | 给图像应用色相旋转。"angle"一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。 |
| invert(*%*)                                        | 反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。 |
| opacity(*%*)                                       | 转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。 |
| saturate(*%*)                                      | 转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。 |
| sepia(*%*)                                         | 将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； |
| url()                                              | URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。例如：`filter: url(svg-url#element-id)` |
| initial                                            | 设置属性为默认值                                             |
| inherit                                            | 从父元素继承该属性                                           |


## flex

CSS3新增的一种弹性布局方式

### align-items

align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式

语法：align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;

| 值         | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| stretch    | 默认值。元素被拉伸以适应容器。如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制。 |
| center     | 元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 |
| flex-start | 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 |
| flex-end   | 元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 |
| baseline   | 元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与'flex-start'等效。其它情况下，该值将参与基线对齐。 |
| initial    | 设置该属性为它的默认值。                                     |
| inherit    | 从父元素继承该属性。                                         |

### flex-shrink

指定flex元素的收缩规则，flex元素仅在默认宽度之和大于容器的时候才会发生收缩，收缩大小根据flex-shrink的值来定

注意：flex-shrink只能用在弹性盒子对象的元素身上

```css
flex-shrink: number|initial|inherit;
number自定义收缩大小
initial为默认值
inherit则是继承父元素属性
```
### flex-wrap
让弹性盒子元素在必要的时候拆分成多行，而不是只在一行中显示
语法：flex-wrap: nowrap|wrap|wrap-reverse|initial|inherit;

| 值           | 描述                                                   |
| :----------- | :----------------------------------------------------- |
| nowrap       | 默认值。规定灵活的项目不拆行或不拆列                   |
| wrap         | 规定灵活的项目在必要的时候拆行或拆列                   |
| wrap-reverse | 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序 |
| initial      | 设置该属性为它的默认值                                 |
| inherit      | 从父元素继承该属性                                     |


###  justify-content

用于设置或检索一个或多个弹性盒子元素在主轴(横轴)方向上的对齐方式【在父元素中】

语法： justify-content: flex-start|flex-end|center|space-between|space-around|initial|inherit; 

| 值            | 描述                                             |
| :------------ | :----------------------------------------------- |
| flex-start    | 默认值。项目位于容器的开头。                     |
| flex-end      | 项目位于容器的结尾。                             |
| center        | 项目位于容器的中心。                             |
| space-between | 项目位于各行之间留有空白的容器内。               |
| space-around  | 项目位于各行之前、之间、之后都留有空白的容器内。 |
| initial       | 设置该属性为它的默认值。                         |
| inherit       | 从父元素继承该属性。                             |

### order

order 属性 设置或检索弹性盒模型对象的子元素从左到右的排序【0在最左边，依次往后排】

语法：order：0；

| 值       | 描述                           |
| :------- | :----------------------------- |
| *number* | 默认值是 0，规定灵活项目的顺序 |
| initial  | 设置该属性为它的默认值         |
| inherit  | 从父元素继承该属性             |

## font

字体效果

| 值                    | 描述                               |
| --------------------- | ---------------------------------- |
| font-style            | 设置字体风格                       |
| font-variant          | 以小型大写字体或者正常字体显示文本 |
| font-weight           | 设置字体粗细                       |
| font-size/line-height | 设置字体尺寸/文本高度              |
| font-family           | 设置字体系列                       |

## Gradients

CSS3渐变效果，常用于background

### linear-gradient

创建一个背景色线性渐变的图案

语法：background-image: linear-gradient(direction, color-stop1, color-stop2, ...);

| 值                          | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| *direction*                 | 用角度值指定渐变的方向（或角度）【例如to right、90deg(0-360)】 |
| color-stop1, color-stop2,.. | 用于指定渐变的颜色【例如red、rgba()】                        |

### radial-gradient

径向渐变的图案

语法：radial-gradient(shape size at position, start-color, ..., last-color)

| 值                             | 描述                                                         |
| :----------------------------- | :----------------------------------------------------------- |
| *shape*                        | 确定圆的类型:ellipse (默认): 指定椭圆形的径向渐变。circle ：指定圆形的径向渐变 |
| *size*                         | 定义渐变的大小，可能值：farthest-corner (默认) : 指定径向渐变的半径长度为从圆心到离圆心最远的角closest-side ：指定径向渐变的半径长度为从圆心到离圆心最近的边closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心最近的角farthest-side ：指定径向渐变的半径长度为从圆心到离圆心最远的边 |
| *position*                     | 定义渐变的位置。可能值：**center**（默认）：设置中间为径向渐变圆心的纵坐标值。**top**：设置顶部为径向渐变圆心的纵坐标值。**bottom**：设置底部为径向渐变圆心的纵坐标值。 |
| *start-color, ..., last-color* | 用于指定渐变的起止颜色。                                     |

### repeating

重复渐变

语法：repeating-linear-gradient  /  repeating-radial-gradient

## Gird

CSS的网格布局，相比于flex等其他一维布局方案，Grid是一个二维布局方案

语法：display：gird / inline-grid  指定一个容器采用网格布局【此时容器内部子元素的float、display：inline-block/table-cell、vertical-align和column都会失效】

*容器定义网格布局后，需要通过特殊CSS语法划分容器的行和列

- grid-template-columns：定义每一列列宽
- gird-template-rows：定义每一行行高

```html
<!--在一个容器里指定一个三行三列的网格布局-->
<body>
    <div class="container"></div>
</body>
<style>
    .container{
        display:grid;
        grid-template-columns:100px 100px 100px;
        grid-template-rows:100px 100px 100px;
        //----使用repeat()设置相同重复的属性，比如----
        grid-template-rows:repeat(3,100px或者3,33.3%) //repeat接受两个参数，一个重复次数一个重复的值
    }
</style>
```

**fr关键字：**网格布局提供了一种 fr (fraction) 单位来表示网格之间的比例关系，是相对单位

```css
.container {
  display: grid;
  grid-template-columns: 1fr 2fr; //表示网格第二列是第一列的两倍宽
}
//注意：fr单位可以和其他单位混用，比如grid-template-columns:100px(绝对宽度) 1fr 2fr(相对宽度)
```

*设置网格间距的语法

- grid-row-gap：行间距
- grid-column-gap：列间距
- grid-gap：行列间距合并写法，接受两个参数，一个行一个列

## outline

outline （轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，一般按钮默认有outline样式

语法：outline:color style width;

| 值              | 描述       |
| --------------- | ---------- |
| outline-color   | 边框颜色   |
| *outline-style* | 边框的样式 |
| *outline-width* | 边框的宽度 |

**outline-style：**

| 值     | 描述                                                |
| :----- | :-------------------------------------------------- |
| none   | 默认。定义无轮廓。                                  |
| dotted | 定义点状的轮廓。                                    |
| dashed | 定义虚线轮廓。                                      |
| solid  | 定义实线轮廓。                                      |
| double | 定义双线轮廓。双线的宽度等同于 outline-width 的值。 |
| groove | 定义 3D 凹槽轮廓。此效果取决于 outline-color 值。   |
| ridge  | 定义 3D 凸槽轮廓。此效果取决于 outline-color 值。   |
| inset  | 定义 3D 凹边轮廓。此效果取决于 outline-color 值。   |
| outset | 定义 3D 凸边轮廓。此效果取决于 outline-color 值。   |

**outline-width:**

| 值       | 描述                   |
| :------- | :--------------------- |
| thin     | 规定细轮廓。           |
| medium   | 默认。规定中等的轮廓。 |
| thick    | 规定粗的轮廓。         |
| *length* | 允许规定轮廓粗细的值。 |

## transition

过渡是CSS3中的效果，可以实现元素不同状态的平滑过渡(补间动画)，经常用来制作动画效果

语法：transition: property duration timing-function delay;【默认all 0 ease 0】

| 值                                                           | 描述                                |
| :----------------------------------------------------------- | :---------------------------------- |
| [transition-property](https://www.w3school.com.cn/cssref/pr_transition-property.asp) | 规定设置过渡效果的 CSS 属性的名称。 |
| [transition-duration](https://www.w3school.com.cn/cssref/pr_transition-duration.asp) | 规定完成过渡效果需要多少秒或毫秒。  |
| [transition-timing-function](https://www.w3school.com.cn/cssref/pr_transition-timing-function.asp) | 规定动画速度效果的速度曲线。        |
| [transition-delay](https://www.w3school.com.cn/cssref/pr_transition-delay.asp) | 定义过渡效果何时开始。              |

## transform

 transform 属性向元素应用 2D 或 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜

| 值                                                           | 描述                                  |
| ------------------------------------------------------------ | ------------------------------------- |
| none                                                         | 定义不进行转换                        |
| matrix(n,n,n,n,n,n)                                          | 定义2D转换，使用六个值的矩阵          |
| matrix3d(*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*) | 定义 3D 转换，使用 16 个值的 4x4 矩阵 |
| translate(*x*,*y*)                                           | 定义 2D 转换                          |
| translate3d(*x*,*y*,*z*)                                     | 定义 3D 转换                          |
| translateX(*x*)                                              | 定义转换，只是用 X 轴的值             |
| translateY(*y*)                                              | 定义转换，只是用 Y 轴的值             |
| translateZ(*z*)                                              | 定义 3D 转换，只是用 Z 轴的值         |
| scale(*x*,*y*)                                               | 定义 2D 缩放转换                      |
| scale3d(*x*,*y*,*z*)                                         | 定义 3D 缩放转换                      |
| scaleX(*x*)                                                  | 通过设置 X 轴的值来定义缩放转换       |
| scaleY(*y*)                                                  | 通过设置 Y 轴的值来定义缩放转换       |
| scaleZ(*z*)                                                  | 通过设置 Z 轴的值来定义 3D 缩放转换   |
| rotate(*angle*)                                              | 定义 2D 旋转，在参数中规定角度        |
| rotate3d(*x*,*y*,*z*,*angle*)                                | 定义 3D 旋转                          |
| rotateX(*angle*)                                             | 定义沿着 X 轴的 3D 旋转               |
| rotateY(*angle*)                                             | 定义沿着 Y 轴的 3D 旋转               |
| rotateZ(*angle*)                                             | 定义沿着 Z 轴的 3D 旋转               |
| skew(*x-angle*,*y-angle*)                                    | 定义沿着 X 和 Y 轴的 2D 倾斜转换      |
| skewX(*angle*)                                               | 定义沿着 X 轴的 2D 倾斜转换           |
| skewY(*angle*)                                               | 定义沿着 Y 轴的 2D 倾斜转换           |
| perspective(*n*)                                             | 为 3D 转换元素定义透视视图            |

## text

### text-overflow
规定当文本大小溢出包含元素大小时，处理方式
语法：text-overflow: clip|ellipsis|string;

| 值       | 描述                                 |
| :------- | :----------------------------------- |
| clip     | 修剪文本                           |
| ellipsis | 显示省略符号来代表被修剪的文本    |
| *string* | 使用给定的字符串来代表被修剪的文本 |


### text-shadow
设置对象中文本的文字阴影和模糊效果

语法：text-shadow  1px 2px 3px #color

1px是对象阴影的水平偏移值

2px是对象阴影的垂直偏移值

3px是对象阴影的模糊值  不可以为负值

color是对象的阴影颜色

## vertical-align

*设置元素的垂直对齐方式

| 属性             | 用法                                                   |
| ---------------- | ------------------------------------------------------ |
| baseline【默认】 | 元素放置在父元素的基线上                               |
| sub              | 垂直对齐文本的下标                                     |
| super            | 垂直对齐文本的上标                                     |
| top              | 把元素的顶端与行中最高元素的顶端对齐                   |
| text-top         | 把元素的顶端与父元素字体的顶端对齐                     |
| middle           | 把此元素放置在父元素的中部 (可以去除图片默认3px下边距) |
| bottom           | 把元素的顶端与行中最低的元素的顶端对齐                 |
| text-bottom      | 把元素的底端与父元素字体的底端对齐                     |

注：vertical-align:text-bottom + margin-bottom用来解决input框与文本框垂直对齐的问题

## white-space

设置如何处理元素内的空白区域【常用于子元素在父元素中的布局方式】

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| normal   | 默认。空白会被浏览器忽略。                                   |
| pre      | 空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。    |
| nowrap   | 文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。 |
| pre-wrap | 保留空白符序列，但是正常地进行换行。                         |
| pre-line | 合并空白符序列，但是保留换行符。                             |
| inherit  | 规定应该从父元素继承 white-space 属性的值。                  |

## 绘制三角形(border)

```css
div {
    width: 50px;
    height: 50px;
    border: 40px solid;
    border-color: orange blue red green;
}
```

*元素的border是由四个三角形组合而成

![img](https://upload-images.jianshu.io/upload_images/9397803-9dc8deee9d6c1922.png?imageMogr2/auto-orient/strip|imageView2/2/w/262/format/webp)



*当元素尺寸设置为0时

```css
div {
    width: 0;
    height: 0;
    border: 40px solid;
    border-color: orange blue red green;
}
```

![img](https://upload-images.jianshu.io/upload_images/9397803-d69e514577bcca5e.png?imageMogr2/auto-orient/strip|imageView2/2/w/160/format/webp)

*所以将其他的border边设置为透明色即可得到三角形

```css
div {
    width: 0;
    height: 0;
    border: 40px solid;
    border-color: transparent transparent transparent
        red;
}
```

![img](https://upload-images.jianshu.io/upload_images/9397803-f1cfc55454bb35ad.png?imageMogr2/auto-orient/strip|imageView2/2/w/260/format/webp)

不过，被“隐藏”的上border仍然占据着空间，要想使得绘制出的三角形尺寸最小化，还需要将上border的宽度设置为0（其它情况同理）

```css
div {
    width: 0;
    height: 0;
    border-width: 0 40px 40px;
    border-style: solid;
    border-color: transparent transparent transparent red;
}
```

## 脱离文档流

*文档流：将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流

*脱离文档流：元素脱离文档流之后，将不再在文档流中占据空间，而是处于浮动状态（可以理解为漂浮在文档流的上方）。脱离文档流的元素的定位基于正常的文档流，当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间

*脱离文档流的三种方法：

1. float：float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围
2. position:absolute：absolute称为绝对定位，其实应该称为相对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）
3. position:fixed：完全脱离文档流，相对于浏览器窗口进行定位（相对于浏览器窗口就是相对于html）

## 清除浮动

使用浮动属性时，当子元素设置了float属性，且父元素的高度和宽度没有进行设置，而是由子元素撑起来的，这种情况会导致父元素高度塌陷为0

1. 给父元素设置合适的高度
2. 给元素的伪元素after添加clear:both属性

```css
.clean-fix::after{
    clear:both;
    content:'';
    display: block;
    width: 0;
    height: 0;
    visibility: hidden;
}
```

3. 父级div定义overflow:hidden

 为什么加入overflow:hidden即可清除浮动呢？那是因为overflow:hidden属性相当于是让父级紧贴内容，这样即可紧贴其对象内内容（包括使用float的div盒子），从而实现了清除浮动 

## BFC

BFC指块级格式化上下文，box是CSS布局的对象和基本单位，一个页面是由若干个Box组成的，BFC就是一个独立的渲染区域，区域里只有block-level box参与，它定义了内部的box如何布局【不会影响区域外部和内部box的子元素的布局】

**触发BFC的情况：**

1. 设置了float且属性不为none
2. position的属性为absolute或fixed
3. display属性为inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
4. overflow属性不为visible，为 auto、scroll、hidden

**注意：**display:table也可以生成BFC的原因在于Table会默认生成一个匿名的table-cell，是这个匿名的table-cell生成了BFC

**BFC中元素的特性：**

1. 子元素会从区域顶端开始一个接一个排列
2. 盒子的垂直方向距离由margin决定，属于同一个BFC的盒子的margin会重叠
3. 在BFC中，每一个盒子的左边缘会触碰到父容器的左边缘内部，也就是说在没有margin和padding时，父border的内边和子border的外边重叠
4. BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘
5. 如果父盒子没有设置高度，但是子盒子中有浮动元素，那么在计算BFC的高度时，浮动子元素也参与计算

**BFC主要用途**

- 清除元素内部浮动：比如给父元素添加overflow:hidden清除子元素浮动带来的父元素高度坍塌问题
- 解决外边距合并问题：同属一个BFC区域中的两个盒子元素，给一个盒子元素设置浮动后会和另一个盒子元素重叠，此时给第二个盒子也定义一个新BFC区域，就可以避免这种问题

## CSS预处理器

### less

*less时一门CSS预处理语言，它拓展了CSS语言，增加了变量、Mixin、函数等特性，使CSS更易维护和拓展

*less可以运行在Node或服务器端

#### less注释

//  注释不会被编译到CSS文件中

/**/  注释会被编译到CSS文件中，保留下来用户可以看到

#### less中的变量

*使用@来声明一个变量----@color：pink;

变量的用法：

1. 作为普通属性值来使用：例如@color
2. 作为选择器和属性名：@{selector的值}的形式
3. 作为URL：@{url}
4. 变量的延迟加载

less中的嵌套规则

1. 基本嵌套规则

2. &用法

   ```css
   .xxx{
       &:hover
   }
   ==>.xxx:hover //自动编译成符合格式的CSS
   ```

#### less的混合(Mixin)

1. 普通混合：

   ```css
   //通过类似函数的方式创立公共属性，通过传参的方式修改每个元素具体样式
   .common(@a,@b,@c){
   	width:@a;
   	height:@b;
   	background:@c;	
   }
   .xxx{
   	.common(实参);
   }
   ```

2. xxx

3. xxxx

#### less文件转译css

在cmd中less文件目录下运行lessc  xx.less  xx.css命令将目标less文件转义输出成标准css文件

### Sass

*sass基于Ruby语言开发，所以 windows环境 安装sass之前需要安装Ruby

1. 变量声明

   通过 $＋变量名  的方式，申请变量

```css
$highlight-color:#f90
//使用方法
nav{
	color:$highlight-color;
	//中划线改成下划线也行，sass没有严格要求
}
```

2. 嵌套引入

*sass允许@import命令写在css规则内

```
//定义一个_blue-theme.scss局部文件
aside{
	background:blue;
	color:white;
}
//导入到css规则中
.blue-theme{@import "blue-theme"}
//就可以自动导入这个局部文件的样式
```

### stylus(不常用)

## Scoped CSS

**特性：**

- 私有作用域：当<style>标签有scoped属性时，它的CSS只作用于当前组件中的元素，它通过使用PostCSS来实现给当前组件的class添加唯一字符串

- 深度选择器：如果希望一个选择器中的样式可以作用的更深(影响子组件)，则需要使用>>>或者/deep/

  ```css
  <!--常规情况-->
  <styles scoped>
     .a >>> .b{/* ... */}
  </style>
  <!--sass和less的使用方式-->
  <styles lang='scss' scoped>
     /deep/.a{/* ... */}
  </style>
  ```

  

## PostCSS

postcss 一种对css编译的工具，类似babel对js的处理

*常见功能：

- 使用下一代css语法
- 自动补全浏览器前缀
- 自动把px代为转换成rem
- css 代码压缩
- 和less/sass结合使用

安装：npm install postcss-loader –save-dev

*webpack loader配置：

```json
//-------webpack.config.js-------
rules:[
    {
        test: /\.css$/,
        use: ['style-loader', 'postcss-loader'],
    },
    {
        test:/\.css$/,
        exclude:/node_modules/,
        use:[
             {
                loader:'postcss-loader'
             }
        ]
    }
]
```

*主要插件(通过npm安装)：

- Autoprefixer   内核前缀自动补全
- postcss-cssnext    自动将新版本的css语法转化为通用老版本
- postcss-pxtorem   将px转化为rem

*导出插件：

```js
//-----创建postcss.config.js文件------
module.exports = {
  plugins: [
    require('autoprefixer'),
    require('postcss-nested')
  ]
}
```



# BOM

各个浏览器厂商根据DOM在各自浏览器上的实现

主要处理浏览器的窗口和框架，JavaScript是通过访问BOM对象来访问、控制、修改浏览器，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM（Document Object Model）模型的根节点。可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。 

# DOM

W3C制定的文档对象模型，是HTML和XML的应用程序接口(API)，DOM中包含window对象，window的属性包含 document、location、navigator、screen、history、frames Document根节点包含子节点：forms、location、anchors、images、links 

从window.document已然可以看出，DOM的最根本的对象是BOM的window对象的子对象。

区别：DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口。

## 节点

*节点包含三个属性：nodeName/nodeType/nodeValue

## nodeType

数值对应节点类型：

| 编号 | 节点类型              | 描述                                               | 子节点                                                       |
| ---- | --------------------- | -------------------------------------------------- | :----------------------------------------------------------- |
| 1    | Element               | 代表元素                                           | Element, Text, Comment, ProcessingInstruction, CDATASection, EntityReference |
| 2    | Attr                  | 代表属性                                           | Text, EntityReference                                        |
| 3    | Text                  | 代表元素或属性中的文本内容                         | None                                                         |
| 4    | CDATASection          | 代表文档中的 CDATA 部分（不会由解析器解析的文本）  | None                                                         |
| 5    | EntityReference       | 代表实体引用                                       | Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference |
| 6    | Entity                | 代表实体                                           | Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference |
| 7    | ProcessingInstruction | 代表处理指令                                       | None                                                         |
| 8    | Comment               | 代表注释                                           | None                                                         |
| 9    | Document              | 代表整个文档（DOM 树的根节点）                     | Element, ProcessingInstruction, Comment, DocumentType        |
| 10   | DocumentType          | 向为文档定义的实体提供接口                         | None                                                         |
| 11   | DocumentFragment      | 代表轻量级的 Document 对象，能够容纳文档的某个部分 | Element, ProcessingInstruction, Comment, Text, CDATASection, EntityReference |
| 12   | Notation              | 代表 DTD 中声明的符号                              | None                                                         |

## classList

classList 属性返回元素的类名，该属性用于在元素中添加，移除及切换 CSS 类

语法：element.classList.方法

| 方法                          | 描述                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| add(*class1, class2, ...*)    | 在元素中添加一个或多个类名。  如果指定的类名已存在，则不会添加 |
| contains(*class*)             | 返回布尔值，判断指定的类名是否存在。可能值：true - 元素包已经包含了该类名false - 元素中不存在该类名 |
| item(*index*)                 | 返回元素中索引值对应的类名。索引值从 0 开始。  如果索引值在区间范围外则返回 *null* |
| remove(*class1, class2, ...*) | 移除元素中一个或多个类名。  **注意：** 移除不存在的类名，不会报错。 |
| toggle(*class,* true\|false)  | 在元素中切换类名。  第一个参数为要在元素中移除的类名，并返回 false。 如果该类名不存在则会在元素中添加类名，并返回 true。  第二个是可选参数，是个布尔值用于设置元素是否强制添加或移除类，不管该类名是否存在。例如：  移除一个 class: *element*.classList.toggle("classToRemove", false); 添加一个 class: *element*.classList.toggle("classToAdd", true);  **注意：** Internet Explorer 或 Opera 12 及其更早版本不支持第二个参数。 |

## Element对象

| 属性 / 方法                                                  | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [element.accessKey](https://www.w3school.com.cn/jsref/prop_html_accesskey.asp) | 设置或返回元素的快捷键。                                     |
| (document.body.)element.appendChild()                        | 向元素添加新的子节点，作为最后一个子节点。                   |
| [element.attributes](https://www.w3school.com.cn/jsref/prop_node_attributes.asp) | 返回元素属性的 NamedNodeMap。                                |
| [element.childNodes](https://www.w3school.com.cn/jsref/prop_node_childnodes.asp) | 返回元素子节点的 NodeList。                                  |
| [element.className](https://www.w3school.com.cn/jsref/prop_html_classname.asp) | 设置或返回元素的 class 属性。                                |
| element.clientHeight                                         | 返回元素的可见高度。                                         |
| element.clientWidth                                          | 返回元素的可见宽度。                                         |
| [element.cloneNode()](https://www.w3school.com.cn/jsref/met_node_clonenode.asp) | 克隆元素。                                                   |
| [element.compareDocumentPosition()](https://www.w3school.com.cn/jsref/met_node_comparedocumentposition.asp) | 比较两个元素的文档位置。                                     |
| [element.contentEditable](https://www.w3school.com.cn/jsref/prop_html_contenteditable.asp) | 设置或返回元素的文本方向。                                   |
| [element.dir](https://www.w3school.com.cn/jsref/prop_html_dir.asp) | 设置或返回元素的内容是否可编辑。                             |
| [element.firstChild](https://www.w3school.com.cn/jsref/prop_node_firstchild.asp) | 返回元素的首个子。                                           |
| [element.getAttribute()](https://www.w3school.com.cn/jsref/met_element_getattribute.asp) | 返回元素节点的指定属性值。                                   |
| [element.getAttributeNode()](https://www.w3school.com.cn/jsref/met_element_getattributenode.asp) | 返回指定的属性节点。                                         |
| [element.getElementsByTagName()](https://www.w3school.com.cn/jsref/met_element_getelementsbytagname.asp) | 返回拥有指定标签名的所有子元素的集合。                       |
| element.getFeature()                                         | 返回实现了指定特性的 API 的某个对象。                        |
| element.getUserData()                                        | 返回关联元素上键的对象。                                     |
| [element.hasAttribute()](https://www.w3school.com.cn/jsref/met_element_hasattribute.asp) | 如果元素拥有指定属性，则返回true，否则返回 false。           |
| [element.hasAttributes()](https://www.w3school.com.cn/jsref/met_node_hasattributes.asp) | 如果元素拥有属性，则返回 true，否则返回 false。              |
| [element.hasChildNodes()](https://www.w3school.com.cn/jsref/met_node_haschildnodes.asp) | 如果元素拥有子节点，则返回 true，否则 false。                |
| [element.id](https://www.w3school.com.cn/jsref/prop_html_id.asp) | 设置或返回元素的 id。                                        |
| [element.innerHTML](https://www.w3school.com.cn/jsref/prop_html_innerhtml.asp) | 设置或返回元素的内容。                                       |
| [element.insertBefore()](https://www.w3school.com.cn/jsref/met_node_insertbefore.asp) | 在指定的已有的子节点之前插入新节点。                         |
| [element.isContentEditable](https://www.w3school.com.cn/jsref/prop_html_iscontenteditable.asp) | 设置或返回元素的内容。                                       |
| [element.isDefaultNamespace()](https://www.w3school.com.cn/jsref/met_node_isdefaultnamespace.asp) | 如果指定的 namespaceURI 是默认的，则返回 true，否则返回 false。 |
| [element.isEqualNode()](https://www.w3school.com.cn/jsref/met_node_isequalnode.asp) | 检查两个元素是否相等。                                       |
| [element.isSameNode()](https://www.w3school.com.cn/jsref/met_node_issamenode.asp) | 检查两个元素是否是相同的节点。                               |
| [element.isSupported()](https://www.w3school.com.cn/jsref/met_node_issupported.asp) | 如果元素支持指定特性，则返回 true。                          |
| [element.lang](https://www.w3school.com.cn/jsref/prop_html_lang.asp) | 设置或返回元素的语言代码。                                   |
| [element.lastChild](https://www.w3school.com.cn/jsref/prop_node_lastchild.asp) | 返回元素的最后一个子元素。                                   |
| [element.namespaceURI](https://www.w3school.com.cn/jsref/prop_node_namespaceuri.asp) | 返回元素的 namespace URI。                                   |
| [element.nextSibling](https://www.w3school.com.cn/jsref/prop_node_nextsibling.asp) | 返回位于相同节点树层级的下一个节点。                         |
| [element.nodeName](https://www.w3school.com.cn/jsref/prop_node_nodename.asp) | 返回元素的名称。                                             |
| [element.nodeType](https://www.w3school.com.cn/jsref/prop_node_nodetype.asp) | 返回元素的节点类型。                                         |
| [element.nodeValue](https://www.w3school.com.cn/jsref/prop_node_nodevalue.asp) | 设置或返回元素值。                                           |
| [element.normalize()](https://www.w3school.com.cn/jsref/met_node_normalize.asp) | 合并元素中相邻的文本节点，并移除空的文本节点。               |
| element.offsetHeight                                         | 返回元素的高度。                                             |
| element.offsetWidth                                          | 返回元素的宽度。                                             |
| element.offsetLeft                                           | 返回元素的水平偏移位置。                                     |
| element.offsetParent                                         | 返回元素的偏移容器。                                         |
| element.offsetTop                                            | 返回元素的垂直偏移位置。                                     |
| [element.ownerDocument](https://www.w3school.com.cn/jsref/prop_node_ownerdocument.asp) | 返回元素的根元素（文档对象）。                               |
| [element.parentNode](https://www.w3school.com.cn/jsref/prop_node_parentnode.asp) | 返回元素的父节点。                                           |
| [element.previousSibling](https://www.w3school.com.cn/jsref/prop_node_previoussibling.asp) | 返回位于相同节点树层级的前一个元素。                         |
| [element.removeAttribute()](https://www.w3school.com.cn/jsref/met_element_removeattribute.asp) | 从元素中移除指定属性。                                       |
| [element.removeAttributeNode()](https://www.w3school.com.cn/jsref/met_element_removeattributenode.asp) | 移除指定的属性节点，并返回被移除的节点。                     |
| [element.removeChild()](https://www.w3school.com.cn/jsref/met_node_removechild.asp) | 从元素中移除子节点。                                         |
| [element.replaceChild()](https://www.w3school.com.cn/jsref/met_node_replacechild.asp) | 替换元素中的子节点。                                         |
| element.scrollHeight                                         | 返回元素的整体高度。                                         |
| element.scrollLeft                                           | 返回元素左边缘与视图之间的距离。                             |
| element.scrollTop                                            | 返回元素上边缘与视图之间的距离。                             |
| element.scrollWidth                                          | 返回元素的整体宽度。                                         |
| [element.setAttribute()](https://www.w3school.com.cn/jsref/met_element_setattribute.asp) | 把指定属性设置或更改为指定值。                               |
| [element.setAttributeNode()](https://www.w3school.com.cn/jsref/met_element_setattributenode.asp) | 设置或更改指定属性节点。                                     |
| element.setIdAttribute()                                     |                                                              |
| element.setIdAttributeNode()                                 |                                                              |
| element.setUserData()                                        | 把对象关联到元素上的键。                                     |
| element.style                                                | 设置或返回元素的 style 属性。                                |
| [element.tabIndex](https://www.w3school.com.cn/jsref/prop_html_tabindex.asp) | 设置或返回元素的 tab 键控制次序。                            |
| [element.tagName](https://www.w3school.com.cn/jsref/prop_element_tagname.asp) | 返回元素的标签名。                                           |
| [element.textContent](https://www.w3school.com.cn/jsref/prop_node_textcontent.asp) | 设置或返回节点及其后代的文本内容。                           |
| [element.title](https://www.w3school.com.cn/jsref/prop_html_title.asp) | 设置或返回元素的 title 属性。                                |
| element.toString()                                           | 把元素转换为字符串。                                         |
| [nodelist.item()](https://www.w3school.com.cn/jsref/met_nodelist_item.asp) | 返回 NodeList 中位于指定下标的节点。                         |
| [nodelist.length](https://www.w3school.com.cn/jsref/prop_nodelist_length.asp) | 返回 NodeList 中的节点数。                                   |

## Event对象

Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。

事件通常与函数结合使用，函数不会在事件发生前被执行！

### addEventListener()
用于给指定元素添加事件句柄

语法： *element*.addEventListener(*event*, *function*, *useCapture*) 

| 参数         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| *event*      | 必须。字符串，指定事件名。  **注意:** 不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。 |
| *function*   | 必须。指定要事件触发时执行的函数。  当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， "click" 事件属于 MouseEvent(鼠标事件) 对象。 |
| *useCapture* | 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。  可能值:true - 事件句柄在捕获阶段执行false- false- 默认。事件句柄在冒泡阶段执行 |

注意：addEventListener和on的区别

addEventListener可以给同一个元素绑定多次，事件之间互不影响，**on事件会被后面的on的事件覆盖**
addEventListener不被IE9以下兼容，兼容性劣于on

#### preventDefault()
用于取消或阻止事件的默认动作【比如表单提交】
语法：event.preventDefault( )
注：如果Event对象的cancelable属性为false，则event无默认动作，此方法无效

示例：

```js
document.querySelector("#id-checkbox").addEventListener("click", function(event) {
         document.getElementById("output-box").innerHTML += "Sorry! <code>preventDefault()</code> won't let you check this!<br>";
         event.preventDefault();
}, false);
```

#### stopPropagation()
终止事件的传播过程【阻止事件冒泡的父元素】
语法：event.stopPropagation( )


# Canvas
canvas是H5新增的一个标签，作为画布使用，画笔则是由js来编写

```html
<canvas width="600" height="400"></canvas> 
	<!-- 1.定义画布大小，最好使用行内样式,在css中定义大小会缩放画布内容 -->
    <!-- 2.准备绘制工具 -->
    <!-- 3.利用工具绘图 -->
    <script>
    	//1.获取dom元素
        let myCanvas=document.querySelector('canvas');
        //2.获取上下文  或者说 获取绘制工具箱
        let ctx = myCanvas.getContext('2d');
        //3.绘制一条直线
        //移动画笔
        ctx.moveTo(100,100);
        //4.绘制直线(轨迹/路径，此时还无法看见)
        ctx.lineTo(200,100);
        //5.描边
        ctx.stroke();
    </script>
```

**Canvas绘制矩形的三种方式**

```js
//绘制一个填充矩形(默认填充黑色)
fillRect(x,y,width,height)
//绘制一个矩形边框
strokeRect(x,y,width,height)
//清除出一个指定矩形区域，使该区域完全透明
clearRect(x,y,width,height)
```

**Canvas添加颜色**

```js
fillStyle：设置图形填充颜色
strokeStyle：设置图形轮廓颜色
```

## Canvas工具

```javascript
1.描边样式
ctx.strokeStyle 
2.线宽
ctx.lineWidth
3.开启新路径---独立每个绘画，每个绘画之间样式设置不会相互覆盖
ctx.beginPath(); 
//但是每开启一个新样式都得重新描一次边
4.填充图形
ctx.fill();
5.自动路径闭合，防止设置线宽以后路径闭合出现缺角的问题
ctx.closePath();
6.设置线末端类型(默认butt/round/square)--相当于戴帽子，会在原长度基础上增长
ctx.lineCap
7.设置相交线的拐点(默认miter/round/bevel)--设置一个点，此时线条会以它为拐点弯曲，还可以用来设置矩形圆角
ctx.lineJoin
8.设置虚线
ctx.setLineDash([a,b]) ==>a是实线长度,b是虚线空出的长度 
9.获取虚线宽度集合
ctx.getLineDash()
10.设置虚线偏移量(正左右负)
ctx.lineDashOffset
11.定点绘制矩形
ctx.fillRect(x,y,width,height) 四个参数绘制矩形
12.绘制圆类形状需要通过fill()来绘制路径
ctx.arc(x,y,r,sAngle,eAngle,弧度) 五个参数一个不能少
弧度一般设置为  具体度数*Math.PI/180
```

**标准绘画过程**

```js
ctx.save();
//在这里导入绘画样式及颜色
ctx.beginPath();
//在这里绘画具体内容
ctx.restore();
```

*指定样式时考虑save和restore

*save():保存当前的绘图状态 / restore():恢复之前保存的绘图状态

*save是从上往下保存，restore是从下往上恢复

```vue
<body>
<!--创建一个边长为200的正方形画布-->
<canvas id="mc" width="200" height="200" style="border:1px solid black"></canvas>

<script type="text/javascript">
    var canvas = document.getElementById('mc'); //获取Canvas元素对应的DOM对象
    var ctx = canvas.getContext('2d');//获取Canvas上的绘图的CanvasRenderingContext2D对象
    ctx.lineWidth=3; //设置笔触线条的宽度
    ctx.translate(100,100); //将原点左边设置到画布的中间
    ctx.save(); //保存当前画布的状态，该状态包含了lineWidth=3,translate(100,100),然后其他那些属性为默认值.
    ctx.strokeStyle='red'; //设置线条颜色为红色
    //坐标系统旋转90°
    ctx.rotate(Math.PI/2);  
    //画第一条直线
    ctx.beginPath();
    ctx.moveTo(-100,0);
    ctx.lineTo(100,0);
    ctx.closePath();
    ctx.stroke();
    //恢复之前保存的绘图状态
    ctx.restore(); 
    //再画第二条直线
    ctx.beginPath();
    ctx.moveTo(-100,0);
    ctx.lineTo(100,0);
    ctx.closePath();
    ctx.stroke();
</script>
</body>
```

## 非零环绕规则(填充)

![img](https://upload-images.jianshu.io/upload_images/665439-7eb425b2345fe3f9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp)

*判断目标区域是否被填充只需要从目标区域画一条线到整个图形外面，同时给定目标区域一个初始值为0(**轨迹值**)，当与顺时针线条相交时就+1，与逆时针线条相交时就-1，最终值非零就填充该目标区域，为零则不填充该区域

**绘制黑渐变线条**

```js
let myCanvas=document.querySelector('canvas');
        let ctx=myCanvas.getContext('2d');

        ctx.lineWidth=30;
        for(var i=0;i<255;i++){
            ctx.beginPath();
            // 每画一个颜色都不一样，所以必须开启新路径来显示，不然最后都变成rgb(255,255,255)
            ctx.moveTo(100+i-1,100);
            ctx.lineTo(100+i,100);
            ctx.strokeStyle='rgb('+i+','+i+','+i+')';
            ctx.stroke();
        }
```

*绘制渐变矩形需要用渐变方案：

```js
let linearGradient=ctx.createLinearGradient(x1,y1,x2,y2);
//两个点确定渐变的长度和方向
linearGradient.addColorStop(0,"pink"); //起始颜色，0是0%的的意思
linearGradient.addColorStop(1,"blue"); //结束颜色，1是100%的意思
//canvas采用的是百分比分段的方式
ctx.fillStyle="linearGradient" //style采用渐变方案
```

**绘制圆弧**

```js
let myCanvas=document.querySelector('canvas');
        let ctx=myCanvas.getContext('2d');
        // 圆心坐标x,y 半径r 确定起始绘制的位置和结束绘制的位置
        //这可以确定弧的长度和位置,以及绘制的方向direction
        //中心位置一个半径150px的圆弧右下角
        var w=ctx.canvas.width;
        var h=ctx.canvas.height;
        ctx.arc(w/2,h/2,150,0,Math.PI/2);
	//第一二个参数是确定圆心位置，第三个是半径，第四第五是确定圆弧的起始和结束
    //Math.PI指的是Π=3.14的意思也就表示这个圆弧是0-Π/2
        ctx.stroke();
```

*绘制扇形

```js
  var w=ctx.canvas.width;
  var h=ctx.canvas.height;
  ctx.moveTo(w/2,h/2)
  //设置闭合点
  ctx.arc(w/2,h/2,150,0,Math.PI/2);
  ctx.closePath();
  //闭合路径
  ctx.stroke();
```

## **绘制图片**

**加载图片到内存**

```js
var img=document.createElement('img');
img.src='目标图片';
//或者创建对象
var image=new Image();
image.onload=function(){};
image.src='';
//但是图片没有加载完成时无法使用该图片，所以使用onload方法,要在src之前
```

**绘制图片的三种方式**

1. drawImage三个参数

   ```js
     var image=new Image();
           image.onload=function(){
               // 第一个参数是图片，第2，3是画布上绘制的起点x,y
               ctx.drawImage(Image,100,100);
           }
           image.src="xxx.jpg"
   ```

2. drawImage五个参数

   ```js
   ctx.drawImage(Image,100,100,100,100);
   //4，5表示缩放图片的大小
   ```

3. drawImage九个参数

   ```js
   ctx.drawImage(Image,100,100,100,100,100,100,100,100);
   //1,2表示图片上定位坐标x,y   3,4在图片上截取多大区域
   //5,6画布上绘制的起点     7,8 缩放图片大小
   ```

**利用精灵图图片达到帧动画的效果**

```js
let myCanvas=document.querySelector('canvas');
let ctx=myCanvas.getContext('2d');

let img=new Image();
	img.onload=function(){
            // 动态获取当前图片尺寸
            let imgWidth=img.width;
            let imgHeight=img.height;
            // 计算出每一个人物的尺寸
            let personWidth=imgWidth/4;
            // 位截取图片
            // 帧动画 在固定的时间间隔更换显示图片
            let index=0;
            // 根据index切换图片,设置定时器 
            setInterval(function(){
                index++;
                if(index==3){
                    index=0;
                }
                //做一个循环
                ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height)
                // 由于每一帧都会保留，所以有重影，需要删除一次画布
               ctx.drawImage(img,index*personWidth,0,personWidth,imgHeight,0,0,personWidth,imgHeight)
            },300)
        }
        img.src='./1.jpg';
```

*canvas动画离不开setInterval定时器

# SVG

***可缩放矢量图形**（**Scalable Vector Graphics，SVG**），是一种用于描述基于二维的矢量图形的，基于XML的标记语言。SVG可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将这两种方式结合起来创建图形。一个简单的SVG文档由<svg>根元素和基本的形状元素构成，SVG支持渐变、旋转、滤镜效果、JavaScript接口等等功能，但是所有这些额外的语言特性，都需要在一个定义好的图形区域内实现

**SVG绘制流程：**

```html
<svg version="1.1"
     baseProfile="full"
     width="300" height="200"
     xmlns="http://www.w3.org/2000/svg">

  <rect width="100%" height="100%" fill="red" />
  <circle cx="150" cy="100" r="80" fill="green" />
  <text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG</text>

</svg>
```

1. 从<svg>根元素开始：
   - 应舍弃来自 (X)HTML的doctype声明，因为基于SVG的DTD验证导致的问题比它能解决的问题更多。
   - SVG 2之前，version属性和baseProfile属性用来供其他类型的验证识别SVG的版本。SVG 2不推荐使用version和baseProfile这两个属性。
   - 作为XML的一种方言，SVG必须正确的绑定命名空间 （在xmlns属性中绑定）。
2. 绘制一个完全覆盖图像区域的矩形 <rect/>，把背景颜色设为红色。
3. 一个半径80px的绿色圆圈<circle/>绘制在红色矩形的正中央 （向右偏移150px，向下偏移100px）。
4. 绘制文字“SVG”。文字被填充为白色， 通过设置居中的锚点把文字定位到期望的位置：在这种情况下，中心点应该对应于绿色圆圈的中点。还可以精细调整字体大小和垂直位置，确保最后的样式是美观的

**SVG预定义形状及参数：**

- 矩形 <rect>

 ```html
  <rect x="20" y="20" rx="20" ry="20" width="250"
    height="100" style="fill:red;stroke:black;
    stroke-width:5;opacity:0.5"/>
    x定义矩形左侧到浏览器左侧的距离，单位px
    y定义矩形顶端到浏览器顶端的距离，单位px
    rx、ry可使矩形产生圆角
    width 和 height 可定义矩形的高度和宽度
    fill定义矩形的填充颜色
    stroke定义矩形边框的颜色
    stroke-width定义矩形边框的宽度
    opacity定义整个元素的透明值
 ```

- 圆形 <circle>

 ```html
 <circle cx="100" cy="50" r="40" stroke="black"
    stroke-width="2" fill="red"/>
    cx、cy定义圆点的xy坐标，默认值0，0
    r定义圆的半径
 ```

- 椭圆 <ellipse>

 ```html
 <ellipse cx="300" cy="150" rx="200" ry="80"
    style="fill:rgb(200,100,50);
    stroke:rgb(0,0,100);stroke-width:2"/>
    cx、cy定义圆点xy坐标
    rx定义水平半径
    ry定义垂直半径
 ```

- 线 <line>

 ```html
 <line x1="0" y1="0" x2="300" y2="300"
    style="stroke:rgb(99,99,99);stroke-width:2"/>
    x1在x轴定义线条的开始
    y1在y轴定义线条的开始
    x2在x轴定义线条的结束
    y2在y轴定义线条的结束
 ```

- 折线 <polyline>

 ```html
 <polyline points="0,0 0,20 20,20 20,40 40,40 40,60"
    style="fill:white;stroke:red;stroke-width:2"/>
 ```

- 多边形 <polygon>
*该标签用来创建含有不少于三个边的图形
 ```html
 <polygon points="220,100 300,210 170,250"
    style="fill:#cccccc;
    stroke:#000000;stroke-width:1"/>
    points定义多边形每个角的xy坐标
 ```

- 路径 <path>

 ```html
 <path d="M250 150 L150 350 L350 350 Z" />
 上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径
 path所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位
    M = moveto
    L = lineto
    H = horizontal lineto
    V = vertical lineto
    C = curveto
    S = smooth curveto
    Q = quadratic Belzier curve
    T = smooth quadratic Belzier curveto
    A = elliptical Arc
    Z = closepath
 ```

# 移动端

*适配各种不同的屏幕，成本较低，但是流畅度对比app低

## 适配问题(屏幕尺寸不同)
**布局方式：**

- 静态布局：页面元素设置固定的宽高，单位为px，缩小窗口会出现滚动条，针对不同分辨率的手机设置不同的样式文件
- 自适应布局：创建多个静态布局，每个静态布局对应一个屏幕分辨率范围，使用到@media媒体查询
- 流式布局：元素的宽度用%高度用px，元素宽高按屏幕分辨率调整，布局不发生变化，屏幕尺寸跨度过大会导致页面显示异常
- 响应式布局：采用自适应布局 + 流式布局 ，将屏幕分辨率划分为几个范围，每个范围对应一个流式布局
- 弹性布局：包裹文字的各元素的尺寸采用em/rem做单位【rem是相对于html元素font-size大小而定的单位，em是相对于其父元素】页面的主要划分区域的尺寸仍使用百分数或px做单位

## viewport(视觉窗口)

*是移动端特有的虚拟区域 , viewport 翻译为中文可以叫做"视区"。

**viewport参数**

1. width：可以设置宽度   (width=device-width 当前设备的宽度)
2. height：可以设置高度
3. initial-scale：可以设置默认缩放比例(默认initial-scale=1)
4. user-scalable：可以设置是否允许用户自行缩放（no/yes）
5. maximum/minimum-scale：可以设置最大最小缩放比例  `maximum-scale/minimum-scale`

```html
<!--常用viewport设置-->
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">   
```

*在设置允许用户缩放后可以设置最大最小缩放比例

**适配方案要求**

1. 不出现横向滚动条----网页内容的宽度和浏览器保持一致
2. 缩放比例为1----默认显示缩放比例和PC端保持一致
3. 不允许用户自行缩放网页

## 具体适配方案

| 方案                     | 原理                                                         | 优势                                 | 缺点                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| 百分比方案               | 使用%定义宽度，px固定高度                                    | 简单、没有兼容问题                   | 屏幕横向尺寸过大会导致画面拉伸变形 / 布局复杂                |
| rem方案                  | 相对长度单位，获取文档根元素和设备dpr以后设置rem             | 兼容性好，自适应效果佳               | 需要引入JS脚本，rem参数出现小数会出现渲染问题【浏览器只按整数渲染】 |
| vh/vw方案                | 将viewport宽高100等分对应1vw和1vh                            | 逻辑简单，根据视口百分比定义元素宽度 | 存在兼容性问题，安卓4.4以下不支持                            |
| rem+vw/vh方案            | 结合方案，根据rem换算vw/vh的值                               | 解决了vw兼容性问题                   |                                                              |
| 基于媒体查询的响应式设计 | 通过媒体查询，给不同分辨率设备编写不同布局【流式布局+弹性布局】 | 在不同设备上呈现合理布局             | 匹配功能复杂                                                 |



# JavaScript

## 内存堆栈

- 栈：存放变量名和变量  **基本数据类型**  的值：Number、Boolean、String、Undefined、Null
- 堆：存放 变量的值 为  **对象**  的值，【此时栈的变量的值为一个**内存地址**，堆中对象值 与 栈内存地址相关联】

## 变量提升

```js
a = 2;
var a;
console.log(a);  //2
----------------------------
console.log(a);
var a = 2; //undifined
------------------------------
//函数优先级高于变量声明
foo();	//foo
function foo() {
    console.log('foo');
}
var foo = 2; 
-----------------------------
//最后的函数覆盖前面的函数
foo(); //2
function foo() {
    console.log('1');
}
function foo() {
    console.log('2');
}
```
总结：
1. js会将变量的声明提升到js顶部执行，因此对于 var a = 2; 其实上js会将其分为 var a; 和 a = 2; 两部分，并且将var a这一步提升到顶部执行。
2. 变量提升的本质其实是由于js引擎在编译的时候，就将所有的变量声明了，因此在执行的时候，所有的变量都已经完成声明。
3. 当有多个同名变量声明的时候，函数声明会覆盖其他的声明。如果有多个函数声明，则是由最后的一个函数声明覆盖之前所有的声明。

注意：匿名函数，ES6中let、const可以避免变量提升的问题

## 变量冻结

用于锁定对象中的变量声明，外部无法修改，保证代码的稳定性

语法：Object.freeze(变量名) 

## ==/===

1. ===  等同号，当等号两边为相同类型时，直接比较两边的值，相同返回true，不同则返回false
2. ==    等值号，无论等号两边类型是否相同，都自动转化为相同，再比较值，返回true&false【NaN == NaN】返回false，NaN和自身也不相等

## 作用域及作用域链

在Js中，作用域分为**全局作用域**和**函数作用域**

- 全局作用域在任何地方都可以访问，window对象的内置属性都拥有全局作用域
- 函数作用域在特定函数内部才能访问

**作用域链**

一般情况下，变量取值  到  创建变量的函数作用域  中取值

但是如果在当前作用域中没有查到值，就会向上级作用域去查【变量提升】，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链

### 闭包

函数与对其状态即**词法环境**（**lexical environment**）的引用共同构成**闭包**（**closure**）【**这个环境包含了这个闭包创建时所能访问的所有局部变量**】，闭包可以让你从内部函数访问外部函数作用域，闭包中的变量始终保存在内存中，不会自动销毁

```js
function makeFunc() {
    var name = "Mozilla";
    function displayName() {  //displayName就是一个闭包函数，它可以访问makeFunc中的name变量
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc(); 
myFunc(); //alert(Mozilla)    
------------------------------
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12
```

注：Java支持方法声明私有化，即它们只能被同一个类中的其它方法所调用。但是Js中没有这种原生支持，所以使用闭包模拟私有方法【私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分】

**闭包三个注意点**

- 引用变量的值改变
```js
function outer() {
      var result = [];
      for (var i = 0; i<10; i++){
        result[i] = function () {
            console.info(i)  // 10，10，10，10
        }
     }
     return result
}
--------------------------------------------------
// 通过再定义一个子作用域的方式
function outer() {
      var result = [];
      for (var i = 0; i<10; i++){
        result[i] = function (num) {
             return function() {
                   console.info(num);    // 此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number都不一样
             }
        }(i)
     }
     return result
}
```
- this指向
```js
var object = {
     name: "object",
     getName: function() {
        return function() {
             console.info(this.name)
        }
    }
}
object.getName()()    // underfined
// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向window
```
- 内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收
```js
function  showId() {
    var el = document.getElementById("app")
    el.onclick = function(){
      alert(el.id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
    }
}

// 改成下面
function  showId() {
    var el = document.getElementById("app")
    var id  = el.id
    el.onclick = function(){
      alert(id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
    }
    el = null    // 主动释放el
}
```

## 定时器

**setTimeout和setInterval**

*基础语法：setTimeout/setInterval(function(){},1000)

- setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式【只执行一次】
- setInterval()方法可按照指定的周期来调用函数或者计算表达式【多次执行，只到clearInterval( )被调用或者窗口被关闭】

**setTimeout可以设置循环函数做到和setInterval同样的效果**

```js
var showTimes=setInterval("showTime()", 5000);
function showTime()
{
    var today = new Date();
    alert("The time is: " + today.toString());
}

//-------------------
var showTimes=null;
showTime();
function showTime()
{
    var today = new Date();
    alert("The time is: " + today.toString());
    showTimes=setTimeout("showTime()", 5000);
}
```



##隐式参数

浏览器在调用函数时,会传递两个隐式参数

- 函数的上下文对象this
- 封装实参的对象arguments

### arguments对象
arguments对象是一个包含 函数内参数 的 类数组
```js
function fun(){
  console.log(arguments);
}
fun('tom',[1,2,3],{name:'Janny'});
```
===>返回

```js
Arguments(3)["tom",Array(3),{...},callee:f,Symbol(Symbol.iterator):f]
	0:"tom"
	1:(3)[1,2,3]
	2:{name:"Janny"}
	callee:f fun()
	length:3
	Symbol(Symbol.iterator):f value()
	__proto__:Object
```
注：Arguments包含函数实参，callee属性，length和Symbol迭代器
callee属性就是Arguments的指向函数
length就是函数的实参个数


### this指向

**核心概念**： **哪个对象调用函数，函数里面的this指向哪个对象** 

**1.普通函数调用**

这个情况没特殊意外，就是指向全局对象window

```js
let username='cn'
function fn(){
    alert(this.username);//undefined
}
fn();
```

可能大家会困惑，为什么不是输出cn，但是因为声明的方式是let，不会是window对象
如果输出正常，要这样写

```js
var username='cn'
function fn(){
    alert(this.username);//cn
}
fu();
//---------------
window.username='cn'
function fn(){
    alert(this.username);//cn
}
fn();
//可以理解为
//window.fn();
```

**2.对象函数调用** 

哪个函数调用，this指向哪里 

```js
window.b=2222
let obj={
    a:111,
    fn:function(){
        alert(this.a);//111
        alert(this.b);//undefined
    }
}
obj.fn();
```

 很明显，第一次就是输出`obj.a`，就是111。而第二次，`obj`没有`b`这个属性，所以输出undefined，因为`this`指向`obj`。 

 但是下面这个情况得注意 

```js
let obj1={
    a:222
};
let obj2={
    a:111,
    fn:function(){
        alert(this.a);
    }
}
obj1.fn=obj2.fn;
obj1.fn();//222
```

 这个相信也不难理解，虽然`obj1.fn`是从`obj2.fn`赋值而来，但是调用函数的是`obj1`，所以`this`指向`obj1`。 

**3.构造函数调用**

```js
let TestClass=function(){
    this.name='111';
}
let subClass=new TestClass();
subClass.name='cn';
console.log(subClass.name);//cn
let subClass1=new TestClass();
console.log(subClass1.name)//111
```

*特殊情况：在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象

 **4.apply和call调用** 

 apply和call简单来说就是会改变传入函数的this 

```js
let obj1={
    a:222
};
let obj2={
    a:111,
    fn:function(){
        alert(this.a);
    }
}
obj2.fn.call(obj1); //222
```

`call` 和 `apply` 两个主要用途就是

1.改变 `this` 的指向（把 `this` 从 `obj2` 指向到 `obj1` ）

2.方法借用（ `obj1` 没有 `fn` ，只是借用 `obj2` 方法）

**5.箭头函数调用**

ES6 提供了箭头函数，增加了开发效率，但是在箭头函数里面，没有 `this` ，箭头函数里面的 `this` 是继承外面的环境。 

```js
let obj={
    a:222,
    fn:function(){    
        setTimeout(function(){console.log(this.a)})
    }
};
obj.fn();//undefined
```

 虽然 **fn()** 里面的 **this** 是指向 **obj** ，但是，传给 **setTimeout** 的是普通函数， **this** 指向是 **window** ， **window** 下面没有 **a** ，所以这里输出 **undefined**

 **换成箭头函数** 

```js
let obj={
    a:222,
    fn:function(){    
        setTimeout(()=>{console.log(this.a)});
    }
};
obj.fn();//222
```

这次输出 222 是因为，传给 setTimeout 的是箭头函数，然后箭头函数里面没有 this ，所以要向上层作用域查找，在这个例子上， setTimeout 的上层作用域是 fn。而 fn 里面的 this 指向 obj ，所以 setTimeout 里面的箭头函数的 this ，指向 obj 。所以输出 222 

### this指向修改

**apply,call,bind**

- 在 javascript 中，`call` 和 `apply` 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 `this` 的指向，apply，call第一个参数都是this指向的对象


```js
function fruits() {}
 
fruits.prototype = {
    color: "red",
    say: function() {
        console.log("My color is " + this.color);
    }
}
 
var apple = new fruits;
apple.say();    //My color is red
------------------------------------
banana = {
    color: "yellow"
}
apple.say.call(banana);     //My color is yellow
apple.say.apply(banana);    //My color is yellow
// 通过call和apply动态改变say方法中的this指向
```

**apply和call的区别**

```js
//call和apply作用相同，接受参数的方式不同
var func = function(arg1, arg2) {
     return arg1 + arg2
};
func.call(this, arg1, arg2);
// call按顺序传参
-------------------------------------
func.apply(this, [arg1, arg2])
// apply则按照数组形式传参
```

- bind()的作用与call()和apply()一样，都是可以改变函数运行时上下文，区别是call()和apply()在调用函数之后会立即执行，而bind()方法调用并改变函数运行时上下文后，**返回一个新的函数**，需要的时候再调用传参即可
```js
var obj = {key:"value"}
var foo = function(){
    console.log(this)    
}.bind(obj) //通过bind方法调用创建的函数，并传参

foo()    //{key:"value"}

/*--------------------------------------*/

var obj = {key:"value"}
var foo = function(){
    console.log(this)    
}
//也可以这样使用bind
foo.bind(obj)()     //{key:"value"}   
```

## prototype和__ proto __

Js中没有类时，通过构造函数（constructor）和原型链（prototype chains）实现类，ES6中的Class语法糖的功能与其相同

注意：

- __ proto __和constructor属性是对象中的独有属性
- prototype是函数独有属性，函数也是对象，所以函数的prototype属性中包含__ proto __和constructor属性
- __ proto __ 并非严格意义的属性，而是类似一个getter和setter属性，只接受 obj.__ proto __ = 函数形式对象，不接受obj.__ proto __ = 字符串

注：__ proto __ 可以用getter和setter模拟

```js
//--------使用getter，setter展示__ proto __只能传值对象的特性 ----------
let hd = {
    action:{},
    get proto(){
        //调用这个对象返回action的值
      return this.action;
    },
    set proto(obj){
       // 判断传入值是否是对象
      if(obj instanceof Object){
          //是对象则把obj的值赋值给action
        this.action = obj
      }
    }
  };
  hd.proto = 'abc'; // 报错，因为'abc'非对象
  hd.proto = {a:function(){}} // 正确方式

//-----------改变__ proto __ 只能传对象特性的方法--------------
let hd = Object.create(null) //去除对象的原型，此时对象没有原型，也就没有原本__ proto __特性
hd.__ proto __ = '字符串' //此时随便设置__ proto __ 属性，字符串也可以正常设置
```

**举例实际说明三者之间的关系**

```js
//函数如下
function Foo() {...};
let f1 = new Foo();
```
**__ proto __属性关系图**
![__proto__](https://img-blog.csdnimg.cn/20190311192930650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70#pic_center)
__ proto __ 属性的作用是当访问一个对象属性时，如果该对象不包含该属性，则会查询该对象 __ proto __ 属性所指向的**父对象**中寻找【这 个查找过程一直持续到原型链末尾的null，如果找到null还没有结果则会报错】

**prototype属性关系图**
![prototype属性](https://img-blog.csdnimg.cn/20190311193033876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70#pic_center)
prototype属性的作用是让该函数的实例化的对象都能找到公用的属性和方法，构造函数中的它和对象中的__ proto __ 相关联【即f1.__ proto __=== Foo.prototype】

**不同数据类型原型关系**

```js
let obj = {} //Object
obj.__proto__ == Object.prototype  //true

let arr = [] //new Array
arr.__proto__ == Array.prototype  //true

let str = "" //new String
str.__proto__ == String.prototype  //true

let bool = true //new Boolean
bool.__proto__ == Boolean.prototype  //true

let reg = /d/  //new RegExp
reg.__proto__ == RegExp.prototype  //true
```



**constructor属性关系图**
![constructor属性](https://img-blog.csdnimg.cn/20190311193745414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70#pic_center)
constructor属性就是指向该对象的构造函数，所有函数最终的构造函数都指向Function

```js
//--------构造函数的原型&【创建新对象=new构造函数】中的constructor指向这个构造函数本身---------
function User(){}
User.prototype.constructor == User  //true
```

**constructor继承图**
![constructor说明](https://img-blog.csdnimg.cn/20190311192013184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NjMTg4Njg4NzY4Mzc=,size_16,color_FFFFFF,t_70#pic_center)

注：Obj.prototype.方法( ){ }和Obj.prototype={方法( )}是不同的【第一种是在原型中添加方法，第二种是创建新原型代替旧原型，旧原型失效】
```js
function User(name){
	this.name = name;
}
//---------创建当前函数的新原型，旧原型失效，旧原型中的constructor属性失效----------
User.prototype = {
    //必须要同时添加原型中constructor指向的构造函数，不然实例对象中调用constructor报错
	constructor:User,
	show(){
		console.log(this.name);
	}
}
let newName = new User.prototype.constructor('new name')
newName.show();  //new name
```

**常用原型方法**

| 方法                                                     | 返回值 | 用途                                                         |
| -------------------------------------------------------- | ------ | ------------------------------------------------------------ |
| Object.setPrototypeOf(obj,prototype)                     | 布尔值 | 为obj(对象)设置新原型(prototype)【新原型是一个对象或者null】，此时obj对象中的prototype属性指向新原型(prototype) |
| Object.isPrototypeOf(obj)                                | 布尔值 | Object对象是否在obj对象的原型链上                            |
| Object.hasOwnProperty("属性")                            | 布尔值 | 检测当前Object对象上是否包含该属性，不会衍生到原型链【"属性" in 对象，则是连同原型链上父对象一同检测，也返回布尔值】 |
| Object.defineProperty(obj, 属性名, {descriptor修改方式}) | 对象   | 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象 |
| Object.create(proto[,propertiesObject])                  | 对象   | proto【必须】为新建对象的关联原型对象，propertiesObject为添加到新创建对象的自身的属性 |

**call和apply引用原型链中其他对象的方法**

| -    | apply                                                        | call                                                       |
| ---- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 语法 | Object.prototype.方法.apply(thisObject[,argArray])           | Object.prototype.方法.call(thisObject[,arg1,arg2,arg3...]) |
| 传参 | 数组                                                         | 列举每个参数                                               |
| 说明 | argArray必须是有效数组或者arguments对象，thisObject不传或null则默认Global对象 | thisObject不传或null则默认Global对象                       |

```js
let hd = {
	data:[1,2,3,4,5];
};
//------给hd对象添加原型------
Object.setPrototypeOf(hd,{
	max(){
		// 排序并返回最大值
		return this.data.sort((a,b)=>b-a[0];)
	}
});
//---------xj对象通过apply借用hd对象中的排序方法------------
let xj = {
    lesson:{js:80,php:60,node:90,linux:70};
    //2.此时再返回data数据，则解决了报错问题
    get data(){
        return Object.value(this.lessons);
    }
};
hd.max.apply(xj) //1.报错，因为max()中的this此时指向xj，但是xj对象中没有data属性

//-----------------call借用法----------------------
let hd = {
	data:[1,2,3,4,5];
};
//------给hd对象添加原型------
Object.setPrototypeOf(hd,{
	max(data){
		// 排序并返回最大值
		return data.sort((a,b)=>b-a[0];)
	}
});
let xj = {
    lesson:{js:80,php:60,node:90,linux:70};

};
hd.max.call(null,Object.values(xj.lessons)) 
```

**原型链判断**

通过`instanceof`判断

语法：A instanceof B【判断B是否在A的原型链上，即B是否是A的父关系】

一般通过`isPrototypeOf()`方法判断

语法：A.isPrototypeOf(B)【判断A是否在B的原型链上】

## 继承

**原型链继承**
将父类的实例作为子类的原型

```js
// 父类
  function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
  Person.prototype.sayHi = function () {
    console.log('hi,' + this.name);
  }
  // 子类
  function Student() {
    this.score = 100;
  }
  Student.prototype = new Person();
  Student.prototype.constructor = Student;

  var s1 = new Student();
  s1.sayHi(); //hi,undefined
  console.log(s1.name, s1.age); //undefined  undefined
  console.log(s1.constructor); //student

//--------原型的继承不是改变构造函数的原型---------
function myProto(){}
//------这是改变构造函数a中的原型，并不是继承------
function a(){}
a.prototype = myProto.prototype;
//--------真正的继承是原型继承-----------
function b(){}
b.prototype.__proto__ = myProto.prototype;
```
特点：子类的实例也是父类的实例 / 方便继承父类的原型中的方法
缺点：无法实现多继承，只能执行一次，无法给属性传值，属性继承是undefined

**构造函数继承**
在子类内部调用父类，通过call，apply，bind改变父类的this指向【复制父类的实例属性给子类】
```js
  // 构造器
  function Animation(name, age) {
    this.name = name;
    this.age = age;
  }
  Animation.prototype.eat = function () {
    console.log(this.name);
  }

  function Cat(name, age, sex, score) {
    Animation.call(this, name, age) // 继承多个父类对象
    this.sex = sex;
    this.score = score;
  }

  var c1 = new Cat('tom', 18, '男', 100) //实例传参
  c1.Cat(); // 报错not a function
  console.log(c1 instanceof Animation);  // false
  console.log(c1 instanceof Cat);   // true
```
特点：子类实例可以向父类传参，可以实现多继承，能够继承父类属性
缺点：无法继承原型中的方法，实例不是父类的实例

**组合继承**
混合原型和构造函数的继承方式，解决了以上两种继承方式的缺陷

```js
  // 组合继承
  function Person(name, age,score) {
    this.name = name;
    this.age = age;
    this.score = score;
    console.log(this);
  }
  Person.prototype.sayHi = function () {
    console.log(this.name);
  }
  function Student(name,age,score,sex){
    Person.call(this,name,age,score);
    this.sex = sex;
  }
  Student.prototype = new Person();
  Student.prototype.constructor = Student;

  var s1 = new Student('张三',19,200,'男');
  console.log(s1);
  console.log(s1.name); // 张三
  s1.sayHi(); // 张三
```

## 多继承

*JS没有多继承方法，只能模拟多继承

**mixin - 混合模式**

```js
const mixinClass = (base, ...mixins) => {
  const mixinProps = (target, source) => {
    Object.getOwnPropertyNames(source).forEach(prop => {
      if (/^constructor$/.test(prop)) { return; }
      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
    })
  };

  let Ctor;
  if (base && typeof base === 'function') {
    Ctor = class extends base {
      constructor(...props) {
        super(...props);
      }
    };
    mixins.forEach(source => {
      mixinProps(Ctor.prototype, source.prototype);
    });
  } else {
    Ctor = class {};
  }
  return Ctor;
};

class A {
  methodA() {}
}
class B {
  methodB() {}
}
class C extends mixinClass(A, B) {
  methodA() { console.log('methodA in C'); }
  methodC() {}
}

let c = new C();
c instanceof C  // true
c instanceof A  // true
c instanceof B  // false
```

这样就简单模拟了间接多继承，通过构造一个中间类，让中间类直接继承 A，并且 mixin 了 B 的原型成员，然后再让 C 去继承这个中间类。由于 B 是通过 mixin 方式浅拷贝了一份，`B.prototype` 并不在 C 的原型链上（`C.__proto__.__proto__`），所以 `c instanceof B` 为 false

## 浅拷贝&深拷贝
简单来说就是B复制了A，A变B也变就是浅拷贝，A变B不变就是深拷贝
**原理**
- 浅拷贝是复制原本对象的堆地址，并没有创建新的对象，所以复制对象的值和原本对象的值始终保持一致
- 深拷贝是创建一个和原本对象一摸一样的新对象，两者不共享内存，所以两个对象不会相互影响

**实现浅拷贝：**
1. for  in循环第一层
```js
// 只复制第一层的浅拷贝
function simpleCopy(obj1) {
   var obj2 = Array.isArray(obj1) ? [] : {};
   for (let i in obj1) {
   obj2[i] = obj1[i];
  }
   return obj2;
}
var obj1 = {
   a: 1,
   b: 2,
   c: {
         d: 3
      }
}
var obj2 = simpleCopy(obj1);
obj2.a = 3;
obj2.c.d = 4;
alert(obj1.a); // 1
alert(obj2.a); // 3
alert(obj1.c.d); // 4
alert(obj2.c.d); // 4
```
2. Object.assign
```js
var obj = {
    a: 1,
    b: 2
}
var obj1 = Object.assign({},obj);
boj1.a = 3;
console.log(obj.a) // 3
```
3. = 赋值
```js
let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);
```

**实现深拷贝：**
1. 采用递归去拷贝所有层级属性
```js
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
```
2. 通过JSON对象实现
```js
function deepClone2(obj) {
  var _obj = JSON.stringify(obj),
    objClone = JSON.parse(_obj);
  return objClone;
}
```
缺点： 无法实现对对象中方法的深拷贝，会显示为undefined

3. 扩展运算符
```js
// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
var car = {brand: "BMW", price: "380000", length: "5米"}
var car1 = { ...car, price: "500000" }
console.log(car1); // { brand: "BMW", price: "500000", length: "5米" }
console.log(car); // { brand: "BMW", price: "380000", length: "5米" }
```

## 数据属性和访问器属性
**数据属性**
定义在对象内部的称之为数据，数据具有四个属性

| 属性         | 默认值    | 作用                                                         |
| ------------ | --------- | ------------------------------------------------------------ |
| Configurable | true      | 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性 |
| Enumerable   | true      | 表示能否通过for-in循环返回属性，直接在对象上定义的属性       |
| Writable     | true      | 表示能否修改属性的值，直接在对象上定义的属性                 |
| Value        | undefined | 包含这个属性的数据值                                         |

**访问器属性**

访问器属性不包含数据值，它包含一对getter和setter函数。当读取访问器属性时，会调用getter函数并返回有效值；当写入访问器属性时，会调用setter函数并传入新值，setter函数负责处理数据。

该属性包含四个特性

| 特性             | 默认值    | 作用                                                         |
| ---------------- | --------- | ------------------------------------------------------------ |
| [[Configurable]] | true      | 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性 |
| [[Enumerable]]   | true      | 表示能否通过for-in循环返回属性                               |
| [[Get]]          | undefined | 在读取属性时调用的函数                                       |
| [[Set]]          | undefined | 在写入属性时调用的函数                                       |

注：定义多个属性：Object.defineProperties( )  /  读取属性特性：Object.getOwnPropertyDescriptor( )

```js
const web = {
    name: '后盾人',
    url: 'houdunren.com',
    set site(value) {
      [this.name, this.url] = value.split(",")
    },
    get site() {
      return `${this.name}++${this.url}`
    }
  }
  web.site = '你好,www.baidu.com'
  console.log(web.site); //你好++www.baidu.com
```

## 面向对象编程(OOP)

*相对于「一个程序只是一些函数的集合，或简单的计算机指令列表。」的传统软件设计观念而言，面向对象编程可以看作是使用一系列对象相互协作的软件设计 。在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器

**三大特征：**

- 封装：将对象运行所需的资源【方法和数据】封装在程序对象中，需要用到时调用即可
- 继承：继承可以使得子类具有父类的各种的公有属性和公有方法，避免方法和属性的重复编写
- 多态：即多种状态，根据程序需求不同，实现方式也不同。表现形式为重写和重载
	- 重写：子类可继承父类中的方法时根据具体需求做出一定的修改	
	- 重载：函数或方法根据参数不同，进行不同处理【JS由于变量提升，没有重载功能】

**运用到的知识点：**

- Namespace 命名空间：允许开发人员在一个独特，应用相关的名字的名称下捆绑所有功能的容器
- Class 类：定义对象的特征。它是对象的属性和方法的模板定义
- Object 对象：类的一个实例
- Property 属性：对象的特征，比如颜色
- Method 方法：对象的能力，比如行走
- Constructor 构造函数：对象初始化的瞬间，被调用的方法。通常它的名字与包含它的类一致
- Inheritance 继承：一个类可以继承另一个类的特征
- Encapsulation 封装：一种把数据和相关的方法绑定在一起使用的方法
- Abstraction 抽象：结合复杂的继承，方法，属性的对象能够模拟现实的模型
- Polymorphism 多态：多意为「许多」，态意为「形态」。不同类可以定义相同的方法或属性

## 常用设计模式

**1. 工厂模式： ** 将其成员对象的实列化推迟到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型 【父类就转变为抽象类，专门接受子类实例对象】

```js
function CreatePerson(name,age,sex) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.sex = sex;
    obj.sayName = function(){
        return this.name;
    }
    return obj;
}
//工厂模式下传入实例对象只要包含三个固定参数即可随意调用函数中的方法，突出无限次数
var p1 = new CreatePerson("longen",'28','男');

console.log(p1.name); // longen
console.log(p1.age);  // 28
console.log(p1.sex);  // 男
console.log(p1.sayName()); 

// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实列
console.log(typeof p1);  // object
console.log(p1 instanceof Object); // true
```

优点： 能解决多个相似的问题 

缺点： 不能知道对象识别的问题(对象的类型不知道) 

**2. 单例模式：**  是保证一个类只有一个实例，并且提供一个访问它的全局访问点 

```js
// 单例模式
var Singleton = function(name){
    this.name = name;
    var instance = null;
};
Singleton.prototype.getName = function(){
    return this.name;
}
// 获取实例对象
function getInstance(name) {
    if(!this.instance) {
        this.instance = new Singleton(name);
    }
    return this.instance;
}
// 返回两个'aa'对象	
var a = getInstance("aa"); 
var b = getInstance("bb");
//返回'aa'字符串
var c = getInstance("cc").getName()
```

注：单例模式下，这个对象只能传入一次实例，并且不可更改 || 且为闭包，该实例对象返回值可以全局调用

**3. 代理模式：** 为对象提供一个代理，用户只能访问代理，代理会将请求数据处理后返回到对象中

```js
// 声明女孩对象
var girl = function (name) {
    this.name = name;
};
// 声明男孩对象
var boy = function (girl) {
    this.girl = girl;
    this.sendGift = function (gift) {
        alert("Hi " + girl.name + ", 男孩送你一个礼物：" + gift);
    }
};
// 声明代理对象
var proxyObj = function (girl) {
    this.girl = girl;
    this.sendGift = function (gift) {
        (new boy(girl)).sendGift(gift); // 代理送花
    }
};
var proxy = new proxyObj(new girl("花花"));
proxy.sendGift("999朵玫瑰");
//如上代码，girl是一个被送礼物的对象，boy是送礼物的对象，他保存了girl这个属性，还有一个送礼物的方法sendGift，然后他通过proxyObj去完成这件事，proxyObj就是代理，他把boy的礼物送给了girl，因此proxyObj同样需要保存girl的属性，同时也有sendGift方法，该方法实例化本体对象boy并调用了boy的sendGift方法，完成了boy送girl礼物的这个过程
```
**实战一：图片加载**
*在前端开发中，使用图片是非常常见的场景，如果直接给img标签设置src属性，如果图片过大，或网速比较慢，图片在加载过程中会有一段时间的空白，用户体验不好
```js
// 不使用代理的预加载图片函数如下
var myImage = (function(){
    var imgNode = document.createElement("img");
    document.body.appendChild(imgNode);
    var img = new Image();
    img.onload = function(){
        imgNode.src = this.src;
    };
    return {
        setSrc: function(src) {
            imgNode.src = "http://img.lanrentuku.com/img/allimg/1212/5-121204193R0.gif";
            img.src = src;
        }
    }
})();
// 调用方式
myImage.setSrc("https://www.baidu.com/img/bd_logo1.png");
```
代理模式解决方案:
```js
var myImage = (function(){
    var imgNode = document.createElement("img");
    document.body.appendChild(imgNode);
    return {
        setSrc: function(src) {
            imgNode.src = src;
        }
    }
})();
// 代理模式
var ProxyImage = (function(){
    var img = new Image();
    img.onload = function(){
        myImage.setSrc(this.src);
    };
    return {
        setSrc: function(src) {
        myImage.setSrc("http://img.lanrentuku.com/img/allimg/1212/5-121204193R0.gif");
        img.src = src;
        }
    }
})();
// 调用方式
ProxyImage.setSrc("https://www.baidu.com/img/bd_logo1.png");
```
如上代码，myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可

代理模式跟本体对象具有相同的对外接口，有两个好处：
一、用户可以放心地请求代理，不需要了解代理的实现过程，只要结果符合预期即可。如果不需要代理对象了，可以换成调用本体对象的该方法
二、在任何使用本体对象的地方，都可以使用代理替换

最后，强调一点，主体对象跟代理对象也可以都返回一个匿名函数，这样也认为他们具有相同的接口
**实战二：缓存代理**
*对第一次运行的结果进行缓存，当再一次运行相同运算的时候，直接从缓存里面取，避免重复运算，如果运算非常复杂的话，对性能很耗费，那么使用缓存对象可以提高性能

```js
var mult = function(){
    var a = 1;
    for(var i = 0,ilen = arguments.length; i < ilen; i+=1) {
        a = a*arguments[i];
    }
    return a;
};
// 计算加法
var plus = function(){
    var a = 0;
    for(var i = 0,ilen = arguments.length; i < ilen; i+=1) {
        a += arguments[i];
    }
    return a;
}
// 代理函数
var proxyFunc = function(fn) {
    var cache = {};  // 缓存对象
    return function(){
        var args = Array.prototype.join.call(arguments,',');
        if(args in cache) {
            return cache[args];   // 使用缓存代理
        }
        return cache[args] = fn.apply(this,arguments);
    }
};
var proxyMult = proxyFunc(mult);
console.log(proxyMult(1,2,3,4)); // 24
console.log(proxyMult(1,2,3,4)); // 缓存取 24

var proxyPlus = proxyFunc(plus);
console.log(proxyPlus(1,2,3,4));  // 10
console.log(proxyPlus(1,2,3,4));  // 缓存取 10
```

**4. 观察者模式：** 发布订阅模式，在这种模式中，一个订阅者一个订阅发布者，当一个特定的事件发生的时候，发布者会通知（调用）所有的订阅者 【对象间的一对多的依赖关系】

```js
// 主题，接收状态变化，触发每个观察者
class Subject {
  constructor() {
      this.state = 0
      this.observers = []
  }
  getState() {
      return this.state
  }
  setState(state) {
      this.state = state
      this.notifyAllObservers()
  }
  attach(observer) {
      this.observers.push(observer)
  }
  notifyAllObservers() {
      this.observers.forEach(observer => {
          observer.update()
      })
  }
}

// 观察者，等待被触发
class Observer {
  constructor(name, subject) {
      this.name = name
      this.subject = subject
      this.subject.attach(this)
  }
 update() {
      console.log(`${this.name} update, state:${this.subject.getState()}`)
  }
}

// 测试代码
let s = new Subject()
let o1 = new Observer('o1', s)
let o2 = new Observer('o2', s)
let o3 = new Observer('o3', s)

s.setState(1)
s.setState(2)
s.setState(3)
```

 优点：对象之间的解耦，时间上的解耦

 需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知 

**5. 策略模式：**  定义一系列的算法，把它们一个个封装起来，并且使它们可以**相互替换** ，目的就是将算法的使用与算法的实现分离开来，避免多重判断条件，更具有扩展性 

注： 一个基于策略模式的程序至少由两部分组成。第一个部分是一组**策略类**，策略类封装了具体 的算法，并负责具体的计算过程。 第二个部分是**环境类Context**，Context 接受客户的请求，随后 把请求委托给某一个策略类 

```js
var calculateBonus = function( performanceLevel, salary ){
        if ( performanceLevel === 'S' ){
            return salary * 4;
        }
        if ( performanceLevel === 'A' ){
            return salary * 3;
        }
        if ( performanceLevel === 'B' ){
            return salary * 2;
        }
};

    calculateBonus( 'B', 20000 ); // 输出：40000
    calculateBonus( 'S', 6000 ); // 输出：24000
```

优点

- 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。
- 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。
- 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。
- 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案。

缺点

- 增加许多策略类或者策略对象，但实际上这比把它们负责的 逻辑堆砌在 Context 中要好。
- 要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点， 这样才能选择一个合适的 strategy。

【但这些缺点并不严重】

## JavaScript对象

JavaScript的对象是无序属性的集合    

其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数

### Array对象

| 方法名      | 语法                        | 用法                                                         |
| ----------- | --------------------------- | ------------------------------------------------------------ |
| slice       | arr.slice(num1,num2)        | 返回从num1到num2下标的组成的新数组                           |
| splice      | arr.splice(index,num)       | 从index下标开始删除num个数的元素，并返回被删除元素组成的数组 |
| pop         | arr.pop()                   | 删除数组的最后一个元素，减少数组的长度，返回被删除的值       |
| push        | arr.push(num...)            | 将num添加到原数组的最后，返回新数组                          |
| shift       | arr.shift()                 | 删除数组的第一个参数,返回新数组                              |
| unshift     | arr.unshift(num...)         | 向数组开头添加多个元素，返回新数组                           |
| sort        | arr.sort()                  | 对数组进行排序，返回排序后数组                               |
| concat      | arr1.concat('参数',arr2)    | 按照arr1+'参数'+arr2拼接成新数组，参数格式不限，也可不设置参数 |
| join        | arr.join('分割符号')        | 给数组元素间添加分割符号并转化为字符串                       |
| indexOf     | arr.indexOf(数组元素)       | 返回数组元素在数组位置的下标，不存在则返回-1                 |
| forEach     | arr.forEach(函数)           | 调用函数处理arr数组元素，返回处理结果                        |
| map         | arr.map(函数)               | 对数组的每一项运行函数处理，返回新数组                       |
| every       | arr.every(函数)             | 每一项函数回调都是true时返回true否则false                    |
| some        | arr.some(函数)              | 只要有一项函数回调是true时返回true否则false                  |
| isArray     | Array.isArray(arr1)         | 判断arr1是否是数组返回布尔值                                 |
| filter      | arr.filter(函数)            | 返回函数处理结果为true的项组成的新数组                       |
| reduce      | arr.reduce(函数)            | 返回函数处理，只有一个最终值                                 |
| reduceRight | arr.reduceRight(函数)       | 函数从数组末端开始执行，返回一个最终值                       |
| fill        | arr.fill(value, start, end) | 将start到end的数组元素替换为value，start和end可省略          |



### Number对象

| 方法名  | 语法 | 用法                                |
| ------- | ---- | ----------------------------------- |
| toFixed |      | Number 四舍五入为指定小数位数的数字 |
|         |      |                                     |
|         |      |                                     |



### Object对象

**Object构造函数方法**

| 方法                     | 语法                                         | 用途                                                         |
| ------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| assign                   | Object.assign(target, ...sources)            | 通过复制一个或多个对象来创建一个新的对象                     |
| create                   | Object.create(proto[, propertiesObject])     | 使用指定的原型对象和属性创建一个新对象                       |
| defineProperty           | Object.defineProperty(obj, prop, descriptor) | 给对象添加一个属性并指定该属性的配置                         |
| defineProperties         | Object.defineProperties(obj, props)          | 给对象添加多个属性并分别指定它们的配置                       |
| entries                  | Object.entries(obj)                          | 返回给定对象自身可枚举属性的 `[key, value]` 数组             |
| freeze                   | Object.freeze(obj)                           | 冻结对象：其他代码不能删除或更改任何属性                     |
| getOwnPropertyDescriptor | Object.getOwnPropertyDescriptor(obj, prop)   | 返回对象指定的属性配置                                       |
| getOwnPropertyNames      | Object.getOwnPropertyNames(obj)              | 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名 |
| getOwnPropertySymbols    | Object.getOwnPropertySymbols(obj)            | 返回一个数组，它包含了指定对象自身所有的符号属性             |
| getPrototypeOf           | Object.getPrototypeOf(object)                | 返回指定对象的原型对象                                       |
| is                       | Object.is(value1, value2)                    | 比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）     |
| isExtensible             | Object.isExtensible(obj)                     | 判断对象是否可扩展                                           |
| isFrozen                 | Object.isFrozen(obj)                         | 判断对象是否已经冻结                                         |
| isSealed                 | Object.isSealed(obj)                         | 判断对象是否已经密封                                         |
| keys                     | Object.keys(obj)                             | 返回一个包含所有给定对象**自身**可枚举属性名称的数组         |
| preventExtensions        | Object.preventExtensions(obj)                | 防止对象的任何扩展                                           |
| seal                     | Object.seal(obj)                             | 防止其他代码删除对象的属性                                   |
| setPrototypeOf           | Object.setPrototypeOf(obj, prototype)        | 设置对象的原型（即内部 `[[Prototype]]` 属性）                |
| values                   | Object.values(obj)                           | 返回给定对象自身可枚举值的数组                               |

### String对象

| 方法              | 语法                                                | 用途                                                         |
| ----------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| charAt            | str.charAt(num)                                     | 返回对应下标是num的字母                                      |
| charCodeAt        | str.charCodeAt(num)                                 | 返回对应下标是num的字母的Unicode值                           |
| concat            | str1.concat(str2)                                   | 将str1和str2字符串拼接                                       |
| indexOf           | str1.indexOf(str2)                                  | 检索str1中是否包含str2字符串并返回str2第一个字符的下标值     |
| match             | str1.match(str2)                                    | 检索str1中是否包含str2字符串并返回str2相关属性               |
| replace           | str1.replace(str1.match(oldStr),str2.match(newStr)) | 找到str1中match的oldStr字符串，用str2match的newStr替换       |
| search            | str1.search(str2)                                   | 找到str1中str2的位置并返回str2第一个字符所在位置的下标，没有找到则返回-1 |
| slice             | str.slice(num1,num2)                                | 截取str从num1到num2下标的字符串并将这部分作为新字符串返回    |
| split             | str.split( 可以是' ',也可以是'特定符号' )           | 将字符串按规则裁剪并作为数组返回                             |
| toLocaleLowerCase | str.toLocaleLowerCase()                             | 针对一种地区语言，转化为全小写                               |
| toLocaleUpperCase | str.toLocaleUpperCase()                             | 针对一种地区语言，转化为全大写                               |
| toLowerCase       | str.toLowerCase()                                   | 转化为全小写                                                 |
| toUpperCase       | str.toUpperCase()                                   | 转化为全大写                                                 |
| substr            | str.substr(num1,num2)                               | 提取str中num1到num2之间指定的字符                            |
| subString         | str.subString(num1,num2)                            | 提取str中num1到num2之间的字符                                |



## Proxy代理

设置Proxy代理在用户和对象之间，修改代理对象操作的默认行为，常用于对数据和构造函数的处理，数据验证还有过滤操作

语法：*const* proxy = new Proxy(target,handler)

参数：

- target：需要Proxy代理的目标对象的名称
- handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数【理解为触发器】

```js
// -----设置proxy代理hd，通过proxy创建修改hd属性的方法------
const hd = { name: 'old name' }
  const proxy = new Proxy(hd, {
    get(obj, property) {
      return obj[property]
    },
    set(obj, property, value) {
      obj[property] = value;
    }
  })
  console.log(proxy.name);
  proxy.name = 'new name'
```



# ES6.0(ES2015)

## let&const
es6之前只有全局作用域和函数作用域，es6添加了一个块级作用域
- var的缺点：不能声明常量，没有块级作用域，可以重复声明
- let：不能声明常量，变量可以在块级作用域中
- const：只能声明常量，常量可以在块级作用域中
注：ES6对let和const默认使用严格模式，不可以重复声明
注：块级作用域，优势是外层作用域无法获取到内层作用域，即内外层变量名相同也互不干扰，但是块级作用域必须声明在 { } 中【避免了变量全局污染】

##  箭头函数
简化匿名函数的写法，用箭头函数代替
- function( ){ }  变为   ( ) => { }
- 函数只有return语句时可以省去 { }
- 函数只有一个变量时可以省去 ( )
注：箭头函数的优势是改变了函数中this的指向，箭头函数的this是继承了外层作用域的this指向

## 解构赋值
ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，此过程是解构
当等号两边的格式、模式、数据类型相同时，左边的变量就会获取到等号右边对应的值

**... - 扩展运算符**
【解构】ES6引用了rest参数，可以通过 ...Array 的语法将  多个剩余的参数集合  遍历后展开 Array数组的方式

## 数组方法
**map，filter，reduce**
- map-映射
  语法：var newArr = array.map((currentValue, index, array) => { return ... }, thisValue);

| 参数         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| currentValue | 必须，当前的元素值                                           |
| index        | 可选，当前元素值的索引                                       |
| array        | 可选，原数组                                                 |
| thisValue    | 可选，对象作为该执行回调时使用，传递给函数，用作 "this" 的值 |
| return       | 新数组                                                       |

```js
var array = [1,4,9,16];
const map = array.map(x => x * 2);
 
console.log(map);  // [2,8,18,32]
```
- filter-过滤，筛选

语法：var newArr = array.filter((currentValue, index, array) => { return ... }, thisValue);

| 参数         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| currentValue | 必须，当前的元素值                                           |
| index        | 可选，当前元素值的索引                                       |
| array        | 可选，原数组                                                 |
| thisValue    | 可选，对象作为该执行回调时使用，传递给函数，用作 "this" 的值 |
| return       | 新数组                                                       |

```js
// 过滤小于40的item
var arr = [20,30,50, 96,50]
var newArr = arr.filter(item => item>40) 
 
console.log(newArr)  // [50, 96, 50]
```

注意：filter主要用来过滤数组不符合条件的参数，数组去重

- reduce-归纳

**reduce()** 方法对数组中的每个元素执行一个reducer函数(升序执行)，将其结果汇总为单个返回值

语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue)

| 参数         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| total        | 必须，初始值，第一次循环之后是计算后的返回值                 |
| currentValue | 必须，当前的元素值                                           |
| currentIndex | 可选，当前元素值的索引                                       |
| array        | 可选，原数组                                                 |
| initialValue | 可选，传递给函数的初始值，即此值会在第一次循环之前赋值给 total |

```js
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// expected output: 10

// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// expected output: 15
```




## import&export

## Class - 类
面向对象的概念，ES6的【构造函数&原型】语法糖，为了简化创建构造函数添加原型方法的代码，并且使代码更加清晰
**对比不同写法**

```js
//-------简化说明--------
Class User{
	show(){}
}
//类的操作本质也是将方法定义在原型上，节省内存空间
//-------------------------
function User(){}
User.prototype.show = function(){}
```
```js
// --------传统写法---------
function Animal(type, name) {
  this.type = type;
  this.name = name;
};

Animal.prototype.toString = function () {
  return '(' + this.type + ',' + this.name + ')';
};
var m = new Animal('monkey', 'yuan');

// ------class 写法-------
class Animal {
//------类的方法之间不可以加逗号-------
  constructor (type, name) {
  //----constructor在类中会自动执行，用作参数初始化-----
    this.type = type;
    this.name = name;
  }
  toString() {
    return '(' + this.type + ',' + this.name + ')';
  }
}
var m = new Animal('monkey', 'yuan');
m.toString(); // (monkey,yuan)
```
**类的要点**

1. 声明不会被提升，这与ES6之前通过函数定义不同。类声明与使用let定义一样，因此也存在暂时性死区
类声明中的所有代码会自动运行在严格模式下，并且无法退出严格模式；

2. 类的所有方法都是不可枚举的【不可遍历，默认"enumerable":false】；

3. 类的所有内部方法都没有`[[Constructor]]`，因此使用new来调用他们会抛出错误；

4. 调用类构造器时不使用`new`，会抛出错误；

5. 试图在类的内部方法中重写类名，会抛出错误；

6. 类声明中的所有代码会自动运行在严格模式下，并且无法退出严格模式
  

  

### 类关键字

**static|public|private|protected**

**static** - 静态属性和静态方法

注：静态属性是在类的内部创建，使用类名来调用，保存在内存中，不会回收，节省内存占用，公用的属性和方法

```js
//-----静态属性------
Class A {
    static a = 'a'
}
let obj = new A();
obj.a //a

//----原型方法----
function B(){
    B.prototype.show = function(){
        console.log('prototype.show')
    }
}
let obj = new B();
obj.show(); //prototype.show

//----静态方法【将方法直接定义在对象上，而不是原型上】-----
function B(){}
B.show = function(){
    console.log('static.show')
}
B.show();  //static.show

//----静态方法在类上的体现----
Class B{
    static show = function(){
        console.log('static.show')
    }
}
B.show(); //static.show
```

**public** - 对象内容公共性质

注：当一个类、成员、方法被public修饰时，则它们可以在外部任何地方都可以随意调用【对象的成员都是public成员】

**private** - 对象内容私有性质

注：当一个类、成员、方法 被 **private** 修饰时，表示该类、成员、方法 是私有的，成员、方法 只能被本类所使用

1.私有属性语法：# + '属性名'【定义私有属性】

私有属性无法直接通过实例对象调用，但是可以使用访问器【class中定义set + '方法'{ }】的方式调用修改

2.私有方法语法：#+'方法名' = () => {}

私有方法不能直接用#+'方法名'形式，但是可以将方法转化为属性形式再定义

```js
class User {
    //---定义私有属性---
	#host = 'https://xxx';
    constructor(name){
        this.name = name;
        this.#check(name);
    }
	set host(url){
        if(!/^https?:/i.test(url)){
            throw new Error('error http')
        } else {
         	this.#host = url;   
        }
    }
	//-----定义私有方法------
	#check = () => {
    if(this.name.length < 5){
        throw new Error('长度不够')
    }
	return true;
 }
}
let hd = new User('后盾人');
hd.host = 'https://www.xx.com';
```

**protected** - 具备私有和公共的特性

注：对于子类来说就是public，但是对于外部Class来说，就是private

方法：通过定义Symbol来创建这种属性,通过WeakMap的方式保护属性【即对象中不显示，但是可以通过实例化对象调用】

```js
const HOST = Symbol();
class Commmon{
    [HOST] = 'https://xxxx';
	set host(url){
    	this[HOST] = url;
	}
	get host(){
        return this[HOST];
    }

}
```

### extends - 子类

extends关键字用在类声明上，表明创建的这个类是另一个类的子类

语法：class ChildClassName extends ParentClassName{ }

注：子类继承的prototype属性值**必须**是 Object 或者 null

注：子类必须包括super()这个方法才能正常调用父类的属性和方法

### 类的继承

**类属性的继承**

子类通过super()方法继承父类属性

```js
//------构造函数原型继承-------
function User(name) {
    this.name = name;
}
function Admin(name){
    User.call(this,name);
}  
Admin.prototype = new User()
Admin.prototype.show = function(){}

let hd = new Admin('后盾人');
console.log(hd);

//-------类的属性通过super继承---------
class User {
    constructor(name){
        this.name = name;
    }
}
class Admin extends User{
    constructor(name){
        //super需要放在子类的构造器中执行
        super(name);
    }
}
let hd = new Admin('后盾人');
console.log(hd); // 后盾人
```

**类的方法继承**

注：父类的方法存在于子类的原型链，所以子类可以直接调用父类的方法

### super()

ES6中的super相当于ES5中的call继承，用于访问和调用子对象【或者类】对应的父对象上的属性和方法

**super()和this区别**

- this指向的是函数所在的当前对象，即谁调用指向谁【在多重继承(不止父子，父类之上还有一个父类的情况)时，this会出现死循环，由于this的指向始终是实例对象】
- super指向的是当前对象的原型对象，即原型链上的父对象，super只能以 `obj(){super.'父类方法'+()}`的格式调用，遵循类的语法【不可以使用函数的方式调用，即 `obj:function(){}`的格式】

语法：

```js
super([arguments]); 
// 调用 父对象/父类 的构造函数

super.functionOnParent([arguments]); 
// 调用 父对象/父类 上的方法
```

## Set&Map

Set是一种ES6新定义的数据类型，是一组Key

的集合，由于是Key的集合所以没有重复，具有唯一性优势

```js
const s = new Set();
[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
for (let i of s) {
  console.log(i);
}
// 输出 2 3 5 4
```
注：Set结构不会添加重复元素，它返回全部元素，可以使用 Array.from() 方法将返回值转化为数组

| 方法                    | 作用                     |
| ----------------------- | ------------------------ |
| Set.prototype.keys()    | 返回键名的遍历器         |
| Set.prototype.values()  | 返回键值的遍历器         |
| Set.prototype.entries() | 返回键值对的遍历器       |
| Set.prototype.forEach() | 使用回调函数遍历每个成员 |
| Set.add()               | 添加元素                 |
| Set.delete()            | 删除元素                 |

Map是一组键值对结构，具有极快的查找速度

```js
// 普通存储学生和成绩的数组相互独立，无法对应
var names = ['Michael', 'Bob', 'Tracy'];
var scores = [95, 75, 85];

// Map初始化，需要创建一个空的二维数组，然后添加键值对
var m = new Map(); // 空Map
m.set('Adam', 67); // 添加新的key-value
m.set('Bob', 59);
m.has('Adam'); // 是否存在key 'Adam': true
m.get('Adam'); // 67
m.delete('Adam'); // 删除key 'Adam'
m.get('Adam'); // undefined
```

注：一个Key对应一个value，所以Map永远只存储最后一个输入的value

## WeakSet&WeakMap

WeakSet和Set类型同样不可以存储重复的值，但是WeakSet只能存储对象类型的值

注：WeakSet是弱引用类型，它不会引用内存中的数据，如果内存中WeakSet引用的数据已被垃圾回收处理，WeakSet仍可以调用已删除数据但是内存中没有值【显示[[Entries]] No properties】，然后，WeakSet才会清空其集合中的数据

```js
//初始化一个WeakSet对象
    let ws = new WeakSet([{"age":18}]);
    //结果：WeakSet {Object {age: 18}}

//初始化一个WeakSet对象
    let ws = new WeakSet([1,2]);
    //结果：报错
```

WeakMap和Set类型同样不可以存储重复的值，但是WeakMap只能存储对象类型的值

注意：WeakSet和WeakMap当内存中数据失效后，它们包含的相关数据也会自动失效，不需要人工清空，所以它们无法使用keys和value的方法，它们主要用来保存受外部影响的数据

**Set、Map、WeakSet和WeakMap区别简述**

- Set：成员不能重复 / 只有键值，没有键名，类似于数组 / 可以遍历
- WeakSet：成员都是对象 / 成员都是弱引用，随时会消失【可以保存DOM节点，不容易造成内存泄露】/ 不能遍历 
- Map：键值对的集合 / 可以遍历【可以跟各种数据格式转换】
- WeakMap：只接受对象作为键名(null除外) / 键名是弱引用 / 不能遍历

## Symbol

ES6中引入的一种新的基础数据类型，Symbol类型

Symbol类似于一种标识，一种唯一性的ID，通常通过调用`Symbol()`函数创建Symbol实例

```js
//1.创建方法
let a = Symbol()
//-----使用symbol作为对象属性------
const mySymbol = Symbol();
let obj = {
    [mySymbol]:'属性值'
}

//更改属性值
obj[mySymbol] = 1;
console.log(obj[mySymbol]); //1

//2.添加描述
let b = Symbol("描述")
console.log(b.description) //描述

//3.记录在内存的创建方法，且数据全局可用
let c = Symbol.for("描述")
Symbol.keyFor(c) //描述
```

**getOwnPropertyName和getPropertySymbols**

Symbol类型的key无法通过Object.key( )或者for...in...来枚举，优势是外界无法获取key值，Object.getOwnPropertyNames和Object.key( )都无法获取Symbol属性，而getOwnPropertySymbols可以获取属性

```js
var obj = {
  name:'ConardLi',
  [Symbol('name2')]:'code秘密花园'
}
Object.getOwnPropertyNames(obj); // ["name"]
Object.keys(obj); // ["name"]
for (var i in obj) {
   console.log(i); // name
}
Object.getOwnPropertySymbols(obj) // [Symbol(name)]
```



## 循环遍历

ES6引入了 for...of 循环方法，作为遍历所有数据结构的统一方法
```js
const arr = ['red', 'green', 'blue'];

for(let v of arr) {
  console.log(v); // red green blue
}

const obj = {};
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);

for(let v of obj) {
  console.log(v); // red green blue
}
```
注：for..of 循环可以代替数组实例的 forEach 方法

**for in和for of**

for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值

for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name

## Promise

Promise是异步编程的一种解决方案，比传统的Ajax-callback模式更加合理。Promise实际上是一个容器，里面保存的是某个未来才会结束的事件(通常是一个异步操作)。从语法上来说Promise是一个对象，从它可以获取异步操作消息。Promise提供了统一的API，各种异步操作都可以用同样的方法进行处理

**Promise对象的四个特点**

1. 对象的状态不受外界影响：对象的状态有三种【 **pending(进行中) , fulfilled(已成功) , rejected(已失败)** 】只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
2. 一旦状态改变了，就不会再改变，任何时候都可以得到这个结果：Promise对象的状态改变只有两种：从pending到fulfilled 或者 从pending到rejected 。改变成fulfilled或者rejected后，就不会再发生改变，一直保持这个结果，这时称之为**resolved(已定型)**。对这个Promise对象添加回调函数可以立即得到这个结果。【也就是resolved可以是fulfilled或者rejected】
3. 无法取消：一旦新建就会立即执行，中途无法取消
4. 必须设置回调函数：不设置回调函数，外部无法获取结果

**基本用法**

*ES6规定，Promise对象是一个构造函数，用来生成Promise实例

```js
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

Promise构造函数接受一个函数作为参数，该函数提供两个参数分别是resolve和reject

- resolve：将Promise对象的状态从 未完成 改成 成功，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去
- reject：将Promise对象的状态从 未完成 改成 失败，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

```js
//这个promise是promise实例
promise.then(function(value) {
  // success
    //这里是使用reject方法处理错误回调
}, function(error) {
  // failure
});
```

Promise实例生成后，可以用原型的then方法分别指定resolved和rejected状态的回调函数。then接受两个回调函数作为参数，一个Promise状态是resolved时调用(必须)，另一个是非必须的Promise对象状态为rejected时调用

### Promise.prototype

**.then()** 

then为Promise实例添加状态改变时的回调函数是必须的，否则外面无法得知，第一个参数是resolved状态的回调函数，第二个是rejected状态的回调函数。

```js
Promise.then(function(){return...}).then(function(){return...}).then...
```

then方法返回一个新的Promise实例(与最初的Promise实例不同)，因此可以采用链式写法。链式的then可以指定一组按照次序调用的回调函数【前一个回调函数有可能返回的还是Promise对象，后一个回调函数会等待Promise状态改变再被调用】

**.catch()**

catch方法是 .then(null/undefined,rejection)的别名，用于指定发生错误时的回调函数

*尽量使用catch捕捉异常，因为Promise返回的错误再reject中处理，接下来的.then方法会接受到一个resolve回调，但是本意是遇到错误中断后续的.then操作

```js
//reject处理
promise
.then(function(){resolve回调},function(){reject回调})
//catch处理
promise
.then(result => {···})
.catch(error => {···})
```

Promise对象的错误具有'冒泡'性值，会一直向后传递直到被catch捕获。catch方法同样返回一个Promise对象，可以继续使用then方法

**.finally()**

finally是用于不管Promise对象最后状态如何都会执行的操作

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···}); 
```

不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数

finally方法的回调函数不接受任何参数！它不需要知道 前面其他方法 返回的Promise对象的状态，finall方法中的回调函数与Promise对象状态无关，不依赖于Promise的执行结果。本质上finally是then方法的特例

### Promise API

**.all()**

用于将多个Promise实例，包装成一个新的Promise实例，相当于多个.then并行处理

```js
const p = Promise.all([p1, p2, p3]);
p.then(function(){
	...
}).catch(function(){
   ...
})
```

Promise.all()方法接受一个数组作为参数，p1p2p3都是Promise实例，如果不是Promise实例会通过Promise.resolve转化为实例。

p的状态由p1p2p3决定，分为两种情况：
- 只有p1p2p3三个状态都是fulfilled，p的状态才会变成fulfilled，此时p1p2p3的返回值组成一个数组传给p的回调函数
- 只要p1p2p3有一个状态时rejected，p的状态就是rejected，此时第一个被reject的实例的返回值会传递给p的回调函数

**.race()**
用于将多个Promise实例，包装成一个新的Promise实例
```js
const p = Promise.race([p1,p2,p3])
```
race和all不同的地方在于，race里面的p1p2p3不再是合作关系，而是竞争关系，哪个先得到结果，p就是什么结果，无论结果是好还是坏

**.allSettled()**
用于接受多个Promise实例，包装成一个新的Promise实例
和all方法类似，但是解决了all短路问题【all只要有一个失败了就不会继续执行了】，allSettled会等待全部实例处理完毕得到结果后返回每个Promise的状态，不管其是否成功

**.resolve()**
将现有对象转化为Promise对象

**.reject()**
返回一个新的Promise实例，实例状态为rejected

### Promise源码

```js
var Promise = (function() {
    function Promise(resolver) {
        if (typeof resolver !== 'function') { //resolver必须是函数
            throw new TypeError('Promise resolver ' + resolver + ' is not a function')
        }
        if (!(this instanceof Promise)) return new Promise(resolver)

        var self = this //保存this
        self.callbacks = [] //保存onResolve和onReject函数集合
        self.status = 'pending' //当前状态

        function resolve(value) {
            setTimeout(function() { //异步调用
                if (self.status !== 'pending') {
                    return
                }
                self.status = 'resolved' //修改状态
                self.data = value

                for (var i = 0; i < self.callbacks.length; i++) {
                    self.callbacks[i].onResolved(value)
                }
            })
        }

        function reject(reason) {
            setTimeout(function(){ //异步调用
                if (self.status !== 'pending') {
                    return
                }
                self.status = 'rejected' //修改状态
                self.data = reason

                for (var i = 0; i < self.callbacks.length; i++) {
                    self.callbacks[i].onRejected(reason)
                }
            })
        }

        try{
            resolver(resolve, reject) //执行resolver函数
        } catch(e) {
            reject(e)
        }
    }

    function resolvePromise(promise, x, resolve, reject) {
        var then
        var thenCalledOrThrow = false

        if (promise === x) {
            return reject(new TypeError('Chaining cycle detected for promise!'))
        }

        if ((x !== null) && ((typeof x === 'object') || (typeof x === 'function'))) {
            try {
                then = x.then
                if (typeof then === 'function') {
                    then.call(x, function rs(y) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return resolvePromise(promise, y, resolve, reject)
                    }, function rj(r) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return reject(r)
                    })
                } else {
                    return resolve(x)
                }
            } catch(e) {
                if (thenCalledOrThrow) return
                thenCalledOrThrow = true
                return reject(e)
            }
        } else {
            return resolve(x)
        }
    }

    Promise.prototype.then = function(onResolved, onRejected) {
        //健壮性处理，处理点击穿透
        onResolved = typeof onResolved === 'function' ? onResolved : function(v){return v}
        onRejected = typeof onRejected === 'function' ? onRejected : function(r){throw r}
        var self = this
        var promise2

        //promise状态为resolved
        if (self.status === 'resolved') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() {
                    try {
                        //调用then方法的onResolved回调
                        var x = onResolved(self.data)
                        //根据x的值修改promise2的状态
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        //promise2状态变为rejected
                        return reject(e)
                    }
                })
            })
        }

        //promise状态为rejected
        if (self.status === 'rejected') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() {
                    try {
                        //调用then方法的onReject回调
                        var x = onRejected(self.data)
                        //根据x的值修改promise2的状态
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        //promise2状态变为rejected
                        return reject(e)
                    }
                })
            })
        }

        //promise状态为pending
        //需要等待promise的状态改变
        if (self.status === 'pending') {
            return promise2 = new Promise(function(resolve, reject) {
                self.callbacks.push({
                    onResolved: function(value) {
                        try {
                            //调用then方法的onResolved回调
                            var x = onResolved(value)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    },
                    onRejected: function(reason) {
                        try {
                            //调用then方法的onResolved回调
                            var x = onRejected(reason)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    }
                })
            })
        }
    }

    //获取当前Promise传递的值
    Promise.prototype.valueOf = function() {
        return this.data
    }

    //由then方法实现catch方法
    Promise.prototype.catch = function(onRejected) {
        return this.then(null, onRejected)
    }

    //finally方法
    Promise.prototype.finally = function(fn) {
        return this.then(function(v){
            setTimeout(fn)
            return v
        }, function(r){
            setTimeout(fn)
            throw r
        })
    }

    Promise.prototype.spread = function(fn, onRejected) {
        return this.then(function(values) {
            return fn.apply(null, values)
        }, onRejected)
    }

    Promise.prototype.inject = function(fn, onRejected) {
        return this.then(function(v) {
            return fn.apply(null, fn.toString().match(/\((.*?)\)/)[1].split(',').map(function(key){
                return v[key];
            }))
        }, onRejected)
    }

    Promise.prototype.delay = function(duration) {
        return this.then(function(value) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    resolve(value)
                }, duration)
            })
        }, function(reason) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    reject(reason)
                }, duration)
            })
        })
    }

    Promise.all = function(promises) {
        return new Promise(function(resolve, reject) {
            var resolvedCounter = 0
            var promiseNum = promises.length
            var resolvedValues = new Array(promiseNum)
            for (var i = 0; i < promiseNum; i++) {
                (function(i) {
                    Promise.resolve(promises[i]).then(function(value) {
                        resolvedCounter++
                        resolvedValues[i] = value
                        if (resolvedCounter == promiseNum) {
                            return resolve(resolvedValues)
                        }
                    }, function(reason) {
                        return reject(reason)
                    })
                })(i)
            }
        })
    }

    Promise.race = function(promises) {
        return new Promise(function(resolve, reject) {
            for (var i = 0; i < promises.length; i++) {
                Promise.resolve(promises[i]).then(function(value) {
                    return resolve(value)
                }, function(reason) {
                    return reject(reason)
                })
            }
        })
    }

    Promise.resolve = function(value) {
        var promise = new Promise(function(resolve, reject) {
            resolvePromise(promise, value, resolve, reject)
        })
        return promise
    }

    Promise.reject = function(reason) {
        return new Promise(function(resolve, reject) {
            reject(reason)
        })
    }

    Promise.fcall = function(fn){
        // 虽然fn可以接收到上一层then里传来的参数，但是其实是undefined，所以跟没有是一样的，因为resolve没参数啊
        return Promise.resolve().then(fn)
    }

    Promise.done = Promise.stop = function(){
        return new Promise(function(){})
    }

    Promise.deferred = Promise.defer = function() {
        var dfd = {}
        dfd.promise = new Promise(function(resolve, reject) {
            dfd.resolve = resolve
            dfd.reject = reject
        })
        return dfd
    }

    try { // CommonJS compliance
        module.exports = Promise
    } catch(e) {}

    return Promise
})()
```

Promise构造函数执行：

- 构造函数接受一个executor立即执行函数，以它作为实参   【在源码中executor = resolver函数】
- resolve和reject函数作为实参传入executor函数
- value作为实参传入resolve和reject函数
- then方法用来注册promise对象状态改变时的回调，且返回一个新promise对象



## 兼容性

*ES6的兼容性不高，可以通过babel完成向下兼容的编译

1. 在线(不常用)

   ```javascript
   <script type="text/babel">
   ```

2. 编译(安装node.js)

   - 安装方法(cmd):

   ```c
   目标文件>npm init -y//生成工程文件
   目标文件>npm i @babel/core @babel/cli @babel/preset-env -D//安装Babel
   ```

   - 设置转化过程：

   ```javascript
   //js文件必须使用src方式引入
   //package.json:
   "script":{
   	"build":"babel A -d B"//A是目标文件目录 B是转化目标目录
   }
   //在A目录下创建.babelrc文件---声明preset
   {
       "presets":["@babel/preset-env"]
   }
   //cmd中运行npm run build
   ```




## ES6模块化

*发展过程：没有模块 ——》CMD(公共模块声明的方法) ——》AMD(异步模块加载) ——》ES6模块化支持

*浏览器不支持模块化 ——》通过**webpack**编译支持(模块化需要配合webpack使用)

### webpack(打包/项目管理)

*安装方式(cmd)：

```c
npm install -g webpack //全局安装
npm install --save-dev webpack  //目标文件安装
```

*在目标文件下新建一个webpack.config.js文件，在其中：

```javascript
const path=require('path');
module.exports={   
    mode:'production',  //声明生成模式:开发模式(出错时标出代码具体错误)
	entry:'./A.js', //同级目录下必须加./
	output:{
		path:path.resolve(__dirname,'目录'),  //path必须传绝对路径，这里目录是自动寻找
		filename:'B.js' //创建打包后的文件
	}
};
```

*webpack编译：

1. entry --入口地址
2. output--对外输出，不可是字符串，必须是JSON和path/filename：文件名
3. mode--指定模式
4. 所有的当前路径需要加`./`

**export(导出)写法**

```javascript
export let a=xx;
export const a=xx;

let a=x;let b=xx;let c=xxx;
export{a,b,c};

export function xxx(){};
export class xxx{};		
export default xx;   //默认值
```

*从另一个模块导出：

```javascript
export*from'./模块';
export{x,x,x,x} from'./模块';
export{default} from'./模块';
```

**import(导入)写法**

```javascript
import * as mod from "./xxx"  //路径文件中的所有内容
import {a,b,c,...}from "./xxx" //只取部分内容
import xxx from './mod'  //专门引入export default的默认值,相当于取出export的默认值并且存放在xxx变量中 
```

# ES2017新特性

## async&await

*类似于ES6中的promise，现在异步处理最好的方式

- ES6 promise方式：

  ```js
  // promise.js
  const fs = require("fs");
  const read = function(fileName){
      return new Promise((resolve,reject)=>{
          fs.readFile(fileName,(err,data)=>{
              if (err) {
                  reject(err);
              } else{
                  resolve(data);
              }
          });
      });
  };
  read('1.txt').then(res=>{
      console.log(res.toString());
      return read('2.txt');  // 返回新的数据，然后输出
  }).then(res => {
      console.log(res.toString());
      return read('3.txt');
  }).then(res => {
      console.log(res.toString());
  });
  ```

- ES2017 async方式：

  ```js
  const fs = require("fs");
  const read = function(fileName){
      return new Promise((resolve,reject)=>{
          fs.readFile(fileName,(err,data)=>{
              if (err) {
                  reject(err);
              } else{
                  resolve(data);
              }
          });
      });
  };
  async function readByAsync(){
      let a1 = await read('1.txt');
      let a2 = await read('2.txt');
      let a3 = await read('3.txt');
      console.log(a1.toString());
      console.log(a2.toString());
      console.log(a3.toString());
  }
  readByAsync();
  ```

  *async函数在function前使用async作为标识，意思就是异步函数，它搭配await使用，每到await的地方就是程序需要等待执行后面的程序，语义化强

**async函数特点:**

- 强语义化
- await只能在async函数中使用
- await后的语句可以是promise对象、数字、字符串等
- async函数返回的是一个promise对象
- 缺点：函数包含多个await关键字时，一条await语句后的promise对象变成reject状态时，那么整个async函数会中断，后面的程序不会继续执行

# 正则表达式

正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

### 风格

*JS风格：

```javascript
let re=new RegExp('\\d+','g');
```

*perl风格:

```javascript
let re=/\d+/g;
```

*模式：贪婪匹配(默认)

*ig \d {n}/+  ?

### 元字符[]

1. 任何一个

   /a[abc]d/     表示中间的字符可以是abc中任意一个

2. 范围

   [a-z] [0-9] [a-z0-9] 

3. 排除

   [^+]   表示不想要+    [^]

### 转义字符

​	\d   [0-9]

​	\D   [ ^0-9]

​	\w  [a-z0-9_]  注意有 _ 字符

​	\W  [ ^a-z0-9_]

​	\s    空格空字符

​	\S   非空白字符

​	`.`   可以匹配任意字符

​	\ .    表示`.`

### 量词---数量

{n}      /a{6}/   /\d{11}/   具体字符个数

{n,m}  /\d{5,12}/			最少到最多多少位

{n，}                                最少多少位

+表示{1，}

?表示{0，1}                     没有或者一个

### 修饰符

^   放在[]表示非    在这里放在[]外表示行首

$   放在[]外表示行尾

^$ 一同使用即可以独立出单个字符串

例如：

```javascript
//网址判断:
/^[https]?:\/\//
```

### 或

*或`|`的优先级很低，使用或时需要用**括号**提高优先级

```javascript
let re=/^(\d|[1-9]\d+)$/; 
//如果不加括号，会自动翻译为字符串头或者尾有数字即可不约束中间部分
```

### 方法

- search： //寻找相关字符串在总字符串中的位置，返回数组元素位置

  ```javascript
  let str="xxxxxxx";
  let re=/x/; //或者/x/i  i代表忽略大小写;
  console.log(str.search(re)); //此方法返回第一个匹配字符串的位置
  ```

- match: //匹配

  ```javascript
  let str="xxxx0xxxx0xxx0xx";
  let re=/\d+/g;   //\d表示0-9   g-global表示全局匹配
  //+表示越多越好(贪婪模式) 不加就只匹配一个
  console.log(str.match(re)); //此方法返回index
  ```

- replace:  //替换字符串

  ```javascript
  let str="axxxxaxxxxAxxxx" //将a、A替换成*
  console.log(str.replace(/a/ig,'*'));
  ```

- test:  //测试用，返回布尔值true或者false    

  ```javascript
  <input type="text" id="txt" >
  let txt=document.getElementById('txt')
  let re=/[1-9]+/;
  console.log(re.test(txt.value));
  ```

  *缺点是默认整个字符串只有一部分符合要求既可以返回true

  

# jQuery

# XML

# Ajax

通过对服务器发送请求，获得服务端数据之前只有三种：

- 地址栏输入地址访问
- 特定元素的href和src属性
- 表单提交

*这些方案以前无法通过代码的方式进行编程(对服务端发出请求并且接受服务端返回的响应)

Ajax(Asynchronous JavaScript and XML)最早出现在2005年的*Google Suggest*，是在浏览器端进行网络编程(**发送请求、接收响应**)的技术方案，它使我们可以通过JavaScript直接获取服务端最新的内容而不必重新加载页面。让Web更接近桌面应用的用户体验。

Ajax就是浏览器提供的一套**API**，可以通过JavaScript调用，从而实现通过代码控制请求和响应，实现网络编程

***XMLHttpRequest对象：**所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新

## Ajax工作原理

1. 浏览器发生请求事件，创建XMLHttpRequest对象，发送HttpRequest
2. 服务器处理HttpRequest，创建响应并将数据返回浏览器
3. 浏览器使用JS处理返回的数据，更新页面内容

## Ajax创建

*AJAX是一套API核心提供的类型：XMLHttpRequest

*涉及到AJAX操作的页面不能使用**文件协议**访问(文件方式访问)

请求响应流程核心：

1. 安装浏览器(用户代理)

   ```javascript
   //xhr类似于浏览器的作用(发送请求接受响应)
   var xhr=new XMLHttpRequest()
   //console.log(xhr.readyState==0) 初始化请求代理对象
   ```

2. 打开浏览器输入网址

   ```javascript
   xhr.open('GET','网址')   //get是请求方式
   //console.log(xhr.readyState==1) open方法被调用，建立好了一个与服务器特定端口的连接
   ```

3. 开始请求

   ```javascript
   xhr.send()
   //因为响应需要事件，所以无法通过返回值的方式返回响应
   //因为客户端永远不知道客户端何时返回响应，所以AJAX API采取事件的机制
   xhr.onreadystatechange=function(){   //返回的是0，1，2，3，4
    //这个事件并不只是在响应时触发，状态改变即触发
       if(this.readyState == 4){     //加载完毕后判断
           if(ajax.status>=200 && ajax.statu<300 || ajax.statu==304){
               //status在[200，300)时说明成功，304表示重定向到缓存，说明已经拥有该数据	
               alert('成功');
               alert(ajax.responseText);
           }else{
               alert('失败');
           }
       }
     		
   }
   ```

4. 等待响应

5. 看结果

## readyState(状态值)

| readyState状态值 | 状态描述         | 说明                                                     |
| ---------------- | ---------------- | -------------------------------------------------------- |
| 0                | UNSENT           | 代理(XHR)被创建但是没有调用`open()`方法                  |
| 1                | OPENED           | `open()`方法已经被调用，建立了连接                       |
| 2                | HEADERS_RECEIVED | `send()`方法已经被调用，并且已经获取了状态行和响应头     |
| 3                | LOADING          | 响应体下载中，`responseText`属性可能已经包含了部分数据。 |
| 4                | DONE             | 响应体下载完成，可以使用`responseText`                   |

*通过理解每一个状态值的含义得出一个结论，一般是在`readyState`值为4时，执行响应后续逻辑

## Ajax跨域
*Ajax出现跨域错误问题，主要原因是由于浏览器的同源策略
### CORS请求原理
*CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制【目前几乎所有的浏览器ajax请求都是基于CORS机制】
#### CORS两类请求
**简单请求：**

- 使用HEAD，GET，POST三种请求方法

*HTTP头信息不超过以下几种字段*

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type【只限于三个值application/x-www-form-urlencoded、 multipart/form-data、text/plain】        

**非简单请求：**凡不能满足两个简单请求约束条件的都是非简单请求

### Ajax跨域时报错表现

*ajax请求时,如果存在跨域现象,并且没有进行解决,会有如下表现

**第一种：**`No 'Access-Control-Allow-Origin' header is present on the requested resource`,并且`The response had HTTP status code 404`

原因：本次ajax请求是非简单请求，所以请求前发送了一次预检请求(OPTIONS),服务器后台不允许OPTIONS请求，导致无法找到对应接口地址

解决：后端允许OPTIONS请求

**第二种：**`No 'Access-Control-Allow-Origin' header is present on the requested resource`,并且`The response had HTTP status code 405`

原因：后端允许OPTIONS请求，但是一些配置文件阻止了OPTIONS请求

解决：后端关闭对应的配置

**第三种：**`No 'Access-Control-Allow-Origin' header is present on the requested resource`,并且`status 200`

原因：服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象

解决：端增加对应的头部支持

**第四种：**`heade contains multiple values '*,*'`，后台响应的http头部信息有两个`Access-Control-Allow-Origin:*`

原因：进行跨域配置的人不了解原理，导致了重复配置【如.net后台(在IIS和项目的webconfig中同时设置Origin:*)，*.net后台(一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回*))】

解决：删除代码手动添加的*，删除IIS下的配置 *



### 解决ajax跨域

*在跨域部分详细分析

## fetch(原生、xhr)

*fetch是一种HTTP数据请求的方式，是XMLHttpRequest的一种代替方案，fetch不是Ajax的进一步封装，而是原生JS【IE不兼容fetch】

*兼容promise、async、await，缺点是需要整个页面加载完毕才请求

```javascript
fetch(url)
.then(response => response.json())
.then(data => console.log(data))
.catch(err => cconsole.log(err))
```
**fetch和jQuery.ajax()的区别**

- 当接受到一个代表错误的HTTP状态码时，**从fetch()返回的Promise不会被标记为reject**，即使响应的HTTP状态码是404或者500。相反，它会将Promise状态标记为resolve(此时resolve的返回值里ok属性被设置为false)，仅当网络故障或者请求被阻止时，才会标记为reject
- **fetch()不会接受跨域cookies**，不能使用fetch()建立起跨域会话
- **fetch()不会发送cookies**，除非使用credentials的初始化选项


## jsonp(安全性较低，被淘汰)

*本质上就是一个script标签<script src="其他.js”>

1. 原理 
2. jQuery

## Ajax2.0(FormData)

## WebSocket(高性能，双向通信)

*是通过单个TCP连接提供全双工通讯信道的计算机通讯协议，用户可以向服务器发送并接受事件驱动响应，无需轮询服务器。让多个用户连接同一个实时服务器，并通过API进行通讯并获得实时响应

### socket.io(WebSocket库)

1. 简单、方便
2. 兼容IE5
3. 自动数据解析

```javascript
//安装：
npm i socker.io -D
//加载:
const io=require('socket.io');
```

```javascript
//1.建立普通http:
let server=http.createServer((req,res)=>{});
server.listen(8080);
//2.建立WS:
let wsServer=io.listen(server);  //监听http服务，如果是ws请求则交互
wsServer.on('connection',sock=>{
   //sock.emit('name',数据)    服务器发送的数据
   //sock.on('name',function(数据){})   接受数据
});
```

*在html页面中：

```javascript
<script src="http://localhost:8080/socket.io/socket.io.js"><script>
<script>
	let sock=io.connect('ws://localhost:8080/');//告诉浏览器这是一个ws请求,ws是可以跨域的
	//sock.emit
	//sock.on
<script>
```

### 原生WebSocket

*WebSocket的服务器不是独立的，而是依附在http上

```javascript
const http=require('http');
const net=require('net');

let server=net.createServer(sock=>{   //http会给解析原始sock得到的req,res,而net不会 
    sock.once('data',buffer=>{   //on表示一直执行,once表示只执行一次
        let str=buffer.toString();  //因为buffer是一个特殊的http头是字符串所以用toString没有问题
    })
});
```

```javascript
let ws=new WebSocket('ws://localhost:8080/');
ws.onopen=function(){}; //当连接后交换数据后
ws.onmessage=function(){}; //有消息过来时
ws.onclose=function(){};  //当连接正常关闭时
ws.onerror=function(){};   //连接非正常关闭
```



# Node.js

Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。

*基本网站开发能力包括：

- 服务端
- 前端
- 运维部署

## Node.js是什么

- Node.js is a javaScript runtime built on V8 engine.

  - Node.js不是一门语言
  - Node.js不是库、不是框架
  - Node.js是一个JavaScript运行时环境
  - 简单点讲Node.js可以解析和执行JavaScript代码，JavaScript由此可以脱离浏览器运行	

- 浏览器中的JavaScript

  - EcmaScript：只有基本的语法
  - BOM
  - DOM

- Node.js中的JavaScript

  - 没有BOM、DOM
- EcmaScript
  
- 在Node这个JavaScript执行环境中为JavaScript提供了**一些服务器级别的操作API**（文件读写、网络服务构建、网络通讯、http服务器等）
  
- Node.js uses an event-driven、non-blocking I/O model that makes it lightweight and efficient.

  - event-driven事件驱动
  - non-blocking I/O model非阻塞IO模型（异步）
  - lightweight and efficient轻量高效化

- Node.js package ecosystem,**npm**,is the largest ecosystem of open source libraries in the world

  - npm是世界上最大的开源库生态系统

  - 绝大多数JavaScript相关的包都存放在npm上，为了让开发人员更方便的下载使用

  - ```
    npm install jquery
    ```

- 构建于Chrome的V8引擎上
  - 代码只是具有特定格式的字符串
  - 引擎可以识别代码，帮助解析和执行
  - V8引擎目前解析执行JavaScript最快
  - Node.js作者将V8引擎移植出来，开发了独立的JavaScript运行时环境(不包含DOM和BOM)

## Node.js用途

1. 中间层：位于客户端和主服务器之间，提高了数据交互时的安全性，提升性能，降低主服务器的复杂度
2. 小型服务
3. 工具

## Node.js优势 

1. 便于前端入手：基于JS语言开发
2. 性能高：Node 为优化 web 应用的吞吐量和扩展度而生
3. Node 包管理工具（node package manager，NPM）提供了数十万个可重用的工具包
4. 可移植：可运行于 Microsoft Windows、macOS、Linux、Solaris、FreeBSD、OpenBSD、WebOS 和 NonStop OS
5. 非阻塞I/O    (解决高并发处理(大量用户同时数据请求处理)==>正常情况下I/O的操作【网络请求、数据库请求、文件读写】都是阻塞的(ajax同步))

## 模块化

- 内置模块
- 第三方模块
- 自定模块
  - 创建一个模块(一个js文件就是一个模块)
  - 导出一个模块{module.exports=name}
  - 引入一个模块并且调用

## NodeJS同步错误处理

正常情况下NodeJS同步代码发生异常以后，进程会退出，整个程序终止执行

通过设置`try`和`catch`语法进行异常捕捉

```
try{
	//这里写可能会报错的代码
}
catch(err){
	//这里写出错后执行的代码
}
```

## fs - 文件系统

-每个fs操作都分同步和异步的形式

--同步的操作发生异常会导致程序阻塞终止，可以使用`try...catch`处理

--异步操作无法保证操作的顺序,异步操作无回调参数

| 方法                                          | 用途               |
| --------------------------------------------- | ------------------ |
| fs.appendFile(path,'string&number',(err)=>{}) | 写入文件           |
| fs.readFile(path,(err,data)=>{})              | 读取文件           |
| fs.unlink(path,(err)=>{})                     | 删除文件           |
| fs.writeFile(path,'string&number',(err)=>{})  | 创建文件，覆盖写入 |

## path - 路径

| 方法                         | 用途                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| path.join(path1,path2,path3) | 将路径片段使用的特定分隔符(window:\)连接起来形成路径，并规范化生成的路径 // 配合__dirname使用 |
| path.resolve([from...],to)   | 把一个路径或路径片段的序列解析为一个绝对路径，相当于执行cd操作 |

## querystring - 寻查字符串

引入：const qs = require('querystring')

| 方法                                                         | 用途                         |
| ------------------------------------------------------------ | ---------------------------- |
| **qs.parse**(queryString, ' 切分键值对的符号(默认#) ', ' 切分键和值的符号(默认=) ') | 将query字符串转换为query对象 |
| **qs.stringify**(obj, ' 切分键值对符号(默认无) ', ' 切分键和值符号(默认无) ')   //  相当于JSON.stringify | 将query对象转化为query字符串 |
| **qs.escape**(未编码queryString)                             | 将query字符串编码            |
| **qs.unescape**(编码后queryString)                           | 将query编码字符串解码        |

## nodemailer邮件插件

安装：npm i nodemailer -D

设置mail.js文件存放示例代码

```js
'use strict';
const nodemailer = require('nodemailer');
    // 创建邮件发送对象
    let transporter = nodemailer.createTransport({
        host: 'smtp.ethereal.email', //发送方邮箱host
        /**  注意：对应邮箱的参数在node_modules/nodemailer/lib/well-known/services.json中寻找  **/
        port: 587,  //端口号
        secure: false, // true for 465, false for other ports
        auth: {
            user: testAccount.user, // 发送方邮箱具体地址
            pass: testAccount.pass // 对应邮箱的mtp验证码 / 授权码
        }
    });

    //邮件信息
let mailobj = {
    	//发送方邮箱地址
        from: '"Fred Foo 👻" <foo@example.com>', 
    	//接受方邮箱地址
        to: 'bar@example.com, baz@example.com', 
        subject: 'Hello ✔', // 邮件标题
       /**纯文本和html信息只能发送其中一个**/
    	text: 'Hello world?', // 文本信息
        html: '<b>Hello world?</b>' // 发送html信息
}
//发送邮件
transporter.sendMail(mailobj,(err,data)=>{
    if(err) throw err;
});
```

## nodemon热更新插件

在编写调试Node.js项目时，修改代码需要频繁开关服务器，使用nodemon工具实现热重启功能，当代码改变时，nodemon会自动重启项目

安装：npm i -g nodemon -g

使用：nodemon js入口文件【即用nodemon代替node】

问题：在windows上容易遇到nodemon启动问题，因为系统禁止启动脚本

解决方法：管理员身份打开powerShell，输入 set-ExecutionPolicy RemoteSigned，输入Y即可

## Node.js Express框架

Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具 

Express提供多种机制：

- 为不同 URL 路径中使用不同 HTTP 动词的请求（路由）编写处理程序
- 集成了“视图”渲染引擎，以便通过将数据插入模板来生成响应
- 设置常见 web 应用设置，比如用于连接的端口，以及渲染响应模板的位置
- 请求处理管道的任何位置添加额外的请求处理“中间件”

安装：npm i express -S  同时再安装一些express中间件

安装express应用程序生成器

1. express创建服务器

```js
const express = require('express')
// express实例化
const app = express()
//设置监听端口
app.listen(3000, () => {
  console.log('server start')
})
```

2. 添加api接口

```js
//设置接口路径
app.get('/user/login', (req, res) => {
  console.log('hello express')
  res.send('注册ok')
  res.end()
})
```

*get请求参数，通过req.query获取

```js
//localhost:3000/user/login?name=rene&age=18
//url地址 ? 之后是 get请求  
app.get('/user/login', (req, res) => {
	//req.query是get请求返回值组成的对象
    console.log(req.query)   ==>  { name: 'rene', age: '18' }
    //处理req.query对象中的数据
    let {name,age}=req.query
    if(name==='rene'&&age==='18'){
        res.send({err:0,msg:'登录成功'})
    }else{
        res.send({err:-1,msg:'用户不存在'})
    }
})
```

注意：get请求 可以通过浏览器模拟，所以方便测试，但是post请求   浏览器无法模拟，这里推荐通过  请求模拟工具  postman进行模拟操作

 *post数据 放在 消息体和请求体 中 ，通过 req.body获取， 但是express无法直接解析消息体【返回值永远是undefined】， 需要通过第三方插件(中间件)协助解析 ====> body-parser

3. 添加body-parser插件解析post请求

安装：npm i body-parser

配置：

```js
const express = require('express')
const bodyParser = require('body-parser')

let app = express()
//app.use  使用中间件(插件)
//urlencoded  解析表单数据  数据格式为:x-www-form-urlencode
app.use(bodyParser.urlencoded({ extended: false }))
//json 解析json数据
app.use(bodyParser.json())
```

### middlewear 中间件

中间件是一个函数，可以访问request obj和response obj，相当于是一个拦截器，会先于post或者get请求处理函数之前执行

中间件功能:

- 执行任何代码
- 对请求和响应对象进行更改
- 终止req-res的循环
- 调用堆栈中的下一个中间件

中间件分类：

- 内置中间件 static
- 自定义中间件( 全局  局部 )
- 第三方中间件( 如 body-parser  /  拦截器 )

全局中间件：

```js
app.use('/', (req, res, next) => {
    //设置中间件监听的路径
  console.log('中间件')
  const {token} = req.query//获取token
  if(token){
      //next是负责定义函数是否继续执行，如果没有next，中间件以下的函数都不会执行
      next()
  }else{
      res.send('缺少token')
  }
})
//只有请求地址包含token才会执行以下函数，否则只会传回 缺少token 字符串
app.get('/add', (req, res) => {
  res.send('请求成功')
})
```

*中间件的next一定要注意，在合适的地方next

局部中间件：

```js
//请求内部传入next参数，将请求响应分层
app.get('/add', (req, res, next) => {
  console.log('fun1')
  //上一层必须要传入next下一层才能执行
  next()
},
 //每一层需要重新设置请求参数，可以继续设置next
(req, res) => {
  console.log('fun2')
  res.send('add')
})
```

总结：中间件之间通过next续航

**body-parser**

是HTTP请求体解析的第三方中间件，使用它可以解析JSON，Raw，文本，URL-encoded格式的请求体

```js
const bodyParser = require('body-parser')
//urlencoded用来解析x-www-form-urlencoded
//当extended为false时，解析出来的值就是String或者Array的格式
//为true时，则可为任何数据类型
app.use(bodyParser.urlencoded({extended:false}))
//解析json数据
app.use(bodyParser.json())
```

### static 静态资源目录

指定一个静态资源目录，该目录可以被访问

```js
const express = require('express')
//static方法需要传入绝对路径，所以需要用到path方法
const path = require('path')
const app = express()
//__dirname返回这个文件的绝对路径
//注意：path.join则将这个文件的绝对路径和'这个文件中的相对目标文件路径'中的相对路径进行拼接，拼接成static所需要的目标文件的绝对路径
app.use(express.static(path.join(__dirname, './a')))
//这样定义以后  域名:3000就会直接指向我们定义的静态目录
app.listen(3000, () => {
  console.log('server start')
})
```

*这样设置以后可以通过  localhost:3000/文件名  的格式访问  a文件夹下的对应文件

### Express.Router

在根目录创建一个router文件夹，用来存放路由相关JS文件

配置业务相关JS文件：

```js
//假设bird.js为例
var express = require('express')
var router = express.Router() //获取路由的实例

// middleware that is specific to this router
router.use(function timeLog (req, res, next) {
  console.log('Time: ', Date.now())
  next()
})
// 定义路由请求方式及参数
router.get('/about', function (req, res) {
  res.send('About birds')
})
//向外暴露路由模块
module.exports = router
```

在应用程序中加载路由模块

```js
const bird = reuqire('./birds') //在server.js文件中引入路由文件
// ...
app.use('/birds',birds) //启用路由中间件，定义path
```

## Node.js爬虫

**相关流程**

- 获取网页内容(http\request\superagent)
- 筛选网页信息(cheerio)
- 输出或存储信息(console\fs\mongodb\mysql)

项目依赖：request/express/cheerio【注：通过 express spider命令直接创建express项目】

# 服务器 

**服务器三大要素**

1. 响应请求
2. 数据交互
3. 数据库

服务器包含硬件，服务器软件和服务器ip及端口号

通常通过ip寻找对应服务器主机，端口号用来划分服务器里的不同程序

## URL模块

url模块就是处理url地址，返回可用数据的工具集

| 方法                 | 用途                    |
| -------------------- | ----------------------- |
| url.parse(urlString) | 解析url字符串，返回对象 |
| url.format(obj)      | 转化url对象为字符串     |
|                      |                         |
|                      |                         |

## HTTP模块

http模块中封装了一个http服务器和一个http客户端工具

http.server是基于事件的http服务器，其中包含API  ///   http.request是http客户端工具，用户向服务器发送请求



*创建一个server.js

```javascript
const http=require('http');
let server=http.createServer(()=>{			//回调函数,收到请求时回调
    console.log("请求来了");
});
//监听:等待客户端连接
server.listen(8080);  //任意不被占用的端口
//在控制台使用node http.js开启服务器
```

客户端发送请求接受响应

```javascript
let server=http.creatServer(function(req,res){ //request是用户请求
    res.write();	//发送给客户端内容
    res.end();     //结束请求，即不再继续响应
}).listen(8080)
```

*通过if.else来实现逻辑，`response.end()`是每个阶段都需要的

*response和request可以简写为res和req

从文件中读写数据(创建fs.js)

```javascript
const fs=require('fs');//fs是filesystem的缩写，该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。
fs.writeFile(path,data,callback);
fs.readFile(path,callback);
```

*callback一般是error回调函数

*fs写在`http.creatServer`的上面

## HTTP详解

*HTTP：HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP），是一种用于分布式、协作式和超媒体信息系统的应用层协议

**HTTP工作原理(请求/响应)：**

1. 客户端连接到Web服务器:浏览器与web服务器的HTTP端口建立一个TCP套接字连接
2. 发送HTTP请求:通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成
3. 服务器接受请求并返回HTTP响应:Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成
4. 释放连接TCP连接:若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求
5. 客户端浏览器解析HTML内容:客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示

### http报文结构

http主要分成头(header)和体(body)两个部分，头包含信息(<=32k)，体包含数据(<=2G)

### 状态码

| 状态码 | 类别             | 原因                     |
| ------ | ---------------- | ------------------------ |
| 1XX    | 信息性状态码     | 接受的请求正在处理       |
| 2XX    | 成功状态码       | 请求正常处理完毕         |
| 3XX    | 重定向状态码     | 需要进行附加操作完成请求 |
| 4XX    | 客户端错误状态码 | 服务器无法处理请求       |
| 5XX    | 服务器错误状态码 | 服务器处理请求出错       |

### 请求方式

GET：获取数据(数据是放在url中传输的，url作为请求地址是放在http头里的)

*GET数据只能放在头里

​	特点：容量小<=32k

POST：向服务器发送数据

​	特点：容量大

### URI和URL
**URI：**统一资源标志符，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行定位的
*URI结构组成：访问资源的命名机制 + 存放资源的主机名 + 资源自身的名称
**URL：**统一资源定位符，URL是URI的一个子集，采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式
*URL结构组成：协议 + 存有资源的主机IP地址 + 主机资源的具体地址

### 接受浏览器的GET数据

*GET请求必须放在url中

url模块：

```javascript
let url=require('url');
let {pathname,query}=url.parse(req.url,true); //true时使用查询模块分析查询字符串。默认为false
```

例如：

```javascript
const http=require('http');
const url=require('url');

let server=http.createServer(function(req,res){
	let {pathname,query}=url.parse(req.url,true); //指定解析req.url中的对象
    console.log(pathname,query);		
});
server.listen(8080);
```

### 接受浏览器的POST数据

*GET数据一次给到底，POST多次切片返回，因为POST体量较大

```javascript
const http=require('http');
const url=require('url');

let server=http.createServer(function(req,res){
		let arr=[];        //由于是切片数据，创建数组存放
   		req.on('data',buffer=>{
			arr.push(buffer);
		});
		req.on('end',()=>{			//此时存了一组buffer 需要拼接
            let buffer=Buffer.concat(arr);  
            console.log(buffer);
        });
});
server.listen(8080);
```

*buffer是个转化后的二进制的数据(因为机器和机器之间是用二进制传输数据),可以用`buffer.toString()`的方法转化回原字符串

*GET--url/POST--body

*GET=>"/aaa/b?xx=xxx&xxx=xx"     POST=>"xx=xxx&xxx=xx"

*GET:url.parse('xx')     POST:querystring.parse('xx')

### GET和POST整合

```javascript
const http=require('http');//帮助建立服务
const url=require('url');//帮助解析url地址及其中的数据
const querystring=require('querystring');//处理&符号
const fs=require('fs'); //文件相关操作

http.creatServer(function(req,res)=>{
	let path='',get={},post={};
    //接受数据,判断get和post
    if(req.method=='GET'){
    	let{pathname,query}=url.parse(req.url,true);
        path=pathname;
        get=query;
	}else if(req.method=='POST'){
        path=req.url;
        let arr=[];
    	req.on('data',buffer=>{
            arr.push(buffer);
        });
        req.on('end',()=>{
           let buffer=Buffer.concat(arr);
           post=quertstring.parse(buffer,toString());
           complete();
        });
	}
	function complete(){
        console.log(path,get,post);
    }
	
}).listen(8080);
```

### 接口-API

接口就是后端在服务器中定义好的访问地址，前端通过访问该地址即可获得相关数据

*前端调用接口，后端开发接口

```javascript
const express = require('express')
const router = express.Router()
// $route GET/POST path
// @desc 数据格式：json/其他
// @access public公共接口/token私有接口
router.get('/test', (req, res) => {
  res.json({err:0,msg:'login works'})
})
```
### REST
REST是表述性状态转移的缩写
**资源**：REST是面向资源的，资源是网络上的一个实体(文件、图形、音频等)，其本质是一串二进制数据，每个资源都有对应的URL，可以通过URL寻找资源
**表述**：资源在某个特定时刻的状态说明被称之为表述，表述由数据和描述数据的元数据组成。资源的表述有多种格式(文本的txt格式、图像的png格式、JSON格式数据)
**表述性状态转移：**表述性状态转移的目的是操作资源，通过转移和控制资源的表述就能实现此目的。例如客户端可以向服务器发送GET请求，服务器将资源的表述转移到客户端；客户端也可以向服务器发送POST请求，传递表述改变服务器中的资源状态

####REST的约束条件
*REST给出了6种约束条件，通信两端在遵循这些约束后，就能提高工作效率，改善系统的可伸缩性、可靠性和交互的可见性，还能促进服务解耦
**客户端-服务器：**客户端与服务器分离关注点，客户端关注用户接口，服务器关注数据存储客户端向服务器发起接口请求（获取数据或提交数据），服务器返回处理好的结果给客户端，客户端再根据这些数据渲染界面，同一个接口可以应用于多个终端（例如Web、iOS或 Android）大大改善了接口的可移植性，客户端应用程序和服务器应用程序必须能够单独进化而不相互依赖，客户端应该只知道资源URI
**无状态：**两端通信必须是无状态的，服务器不会保存上一次请求的会话状态，会话状态要全部保存在客户端，从客户端到服务器的每个请求都要附带一些用于理解该请求的信息，如果客户端应用程序需要是最终用户的有状态应用程序，用户登录一次并在此后执行其他授权操作，则客户端的每个请求都应包含服务请求所需的所有信息 - 包括身份验证和授权详细信息
**可缓存：**响应的资源可以被标记为可缓存或禁止缓存，如果可以缓存，那么客户端可以减少与服务器通信的次数，降低延迟、提高效率
**统一接口：**统一接口是REST区别于其他架构风格的核心特征，接口定义包括4个部分

1. 资源的识别（identification of resources）也就是用一个URL指向资源，要获取这个资源，只要访问它的URL即可，URL就是资源的地址或标识符。REST对URL的命名也有要求，在URL中不能有动词，只能由名词组成
2. 通过表述对资源执行操作（manipulation of resources through representations）在表述中包含了操作该资源的指令
3. 自描述的消息（self-deive messages）包含如何处理该消息的信息，例如消息所使用的表述格式、能否被缓存等
4. 作为应用状态引擎的超媒体（hypermedia as the engine of application state）超媒体并不是一种技术，而是一种策略，建立一种客户端与服务器之间的对话方式。超媒体可以将资源互相连接，并能描述它们的能力，告诉客户端如何构建HTTP请求

**分层系统：**REST允许您使用分层系统体系结构，在服务器A上部署API，并在服务器B上存储数据，并在服务器C中验证请求。客户端通常无法判断它是直接连接到终端服务器，还是沿途的中介
**按需编码：**这是一条可选的约束，支持客户端下载并执行一些代码（例如 Java AppletJava或 Flash）进行功能扩展

#### RESTful风格

RESTful的关键是定义可表示流程元素/资源的对象。在REST中，每一个对象都是通过URL来表示的，对象用户负责将状态信息打包进每一条消息内，以便对象的处理总是无状态的 

RESTful API（应用程序接口）是符合RESTful规范的框架，用它可以实现跨平台、广泛覆盖客户端（包括浏览器和移动设备）的HTTP服务 

**对比传统接口定义和RESTful方式：**

|          | 传统                | RESTful(uri)               |
| -------- | ------------------- | -------------------------- |
| 列表查询 | getMemberlist       | member/list【GET请求】     |
| 查询     | getMember?id=xxx    | member/{id}【GET请求】     |
| 添加     | addMember?xxx       | member【POST请求】         |
| 修改     | updateMember?id=xxx | member/{id}【PUT请求】     |
| 删除     | deleteMember?id=xxx | memeber/{id}【DELETE请求】 |

*即操作不体现在URL上，而是改变不同接口来完成操作

**设计REATful API要点：**

- 协议：API与用户的通信协议，总是使用HTTPs协议
- 域名：应该尽量将API部署在专用域名之下
- 版本：应该将API的版本号放入URL
- 路径：在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应
- HTTP动词：对于资源的具体操作类型，由HTTP动词表示
- 过滤信息：如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果
- 状态码：服务器向用户返回的状态码和提示信息
- 错误处理：如果状态码是4xx，就应该向用户返回出错信息
- 返回格式：服务器返回的数据格式，应该尽量使用JSON，避免使用XML
- Hypermedia API：RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么

【**HTTP动词**】

- GET（SELECT）：从服务器取出资源（一项或多项）。
- POST（CREATE）：在服务器新建一个资源。
- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
- DELETE（DELETE）：从服务器删除资源。
- HEAD：获取资源的元数据。
- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

### **使用Http状态码处理错误**

**1XX:信息状态码**

| **状态码** | **含义** | **描述**                                     |
| ---------- | -------- | -------------------------------------------- |
| 100        | 继续     | 初始的请求已经接受，请客户端继续发送剩余部分 |
| 101        | 切换协议 | 请求这要求服务器切换协议，服务器已确定切换   |

**2XX:成功状态码**

| **状态码** | **含义**   | **描述**                                             |
| ---------- | ---------- | ---------------------------------------------------- |
| 200        | 成功       | 服务器已成功处理了请求                               |
| 201        | 已创建     | 请求成功并且服务器创建了新的资源                     |
| 202        | 已接受     | 服务器已接受请求，但尚未处理                         |
| 203        | 非授权信息 | 服务器已成功处理请求，但返回的信息可能来自另一个来源 |
| 204        | 无内容     | 服务器成功处理了请求，但没有返回任何内容             |
| 205        | 重置内容   | 服务器处理成功，用户终端应重置文档视图               |
| 206        | 部分内容   | 服务器成功处理了部分GET请求                          |

**3XX:重定向状态码**

| **状态码** | **含义**     | **描述**                                                     |
| ---------- | ------------ | ------------------------------------------------------------ |
| 300        | 多种选择     | 针对请求，服务器可执行多种操作                               |
| 301        | 永久移动     | 请求的页面已永久跳转到新的url                                |
| 302        | 临时移动     | 服务器目前从不同位置的网页响应请求，但请求仍继续使用原有位置来进行以后的请求 |
| 303        | 查看其他位置 | 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码 |
| 304        | 未修改       | 自从上次请求后，请求的网页未修改过                           |
| 305        | 使用代理     | 请求者只能使用代理访问请求的网页                             |
| 307        | 临时重定向   | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 |

**4XX:客户端错误状态码**

| **状态码** | **含义**       | **描述**                                         |
| ---------- | -------------- | ------------------------------------------------ |
| 400        | 错误请求       | 服务器不理解请求的语法                           |
| 401        | 未授权         | 请求要求用户的身份演验证                         |
| 403        | 禁止           | 服务器拒绝请求                                   |
| 404        | 未找到         | 服务器找不到请求的页面                           |
| 405        | 方法禁用       | 禁用请求中指定的方法                             |
| 406        | 不接受         | 无法使用请求的内容特性响应请求的页面             |
| 407        | 需要代理授权   | 请求需要代理的身份认证                           |
| 408        | 请求超时       | 服务器等候请求时发生超时                         |
| 409        | 冲突           | 服务器在完成请求时发生冲突                       |
| 410        | 已删除         | 客户端请求的资源已经不存在                       |
| 411        | 需要有效长度   | 服务器不接受不含有效长度表头字段的请求           |
| 412        | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |
| 413        | 请求实体过大   | 由于请求实体过大，服务器无法处理，因此拒绝请求   |
| 414        | 请求url过长    | 请求的url过长，服务器无法处理                    |
| 415        | 不支持格式     | 服务器无法处理请求中附带媒体格式                 |
| 416        | 范围无效       | 客户端请求的范围无效                             |
| 417        | 未满足期望     | 服务器无法满足请求表头字段要求                   |

**5XX:服务端错误状态码**

| 状态码 | 含义       | 描述                                 |
| ------ | ---------- | ------------------------------------ |
| 500    | 服务器错误 | 服务器内部错误，无法完成请求         |
| 501    | 尚未实施   | 服务器不具备完成请求的功能           |
| 502    | 错误网关   | 服务器作为网关或代理出现错误         |
| 503    | 服务不可用 | 服务器目前无法使用                   |
| 504    | 网关超时   | 网关或代理服务器，未及时获取请求     |
| 505    | 不支持版本 | 服务器不支持请求中使用的HTTP协议版本 |

### HTTP和HTTPS的区别
- HTTP：互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少
- HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL

*HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS

**HTTP和HTTPS的主要区别：**
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

# 数据通信
## token

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码

为什么使用token：

​	客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端 

​	服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝

   分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时

## bcrypt

bcrypt是一个跨平台的文件加密工具

引入：const bcrypt = require('bcrypt')  【npm i bcrypt】

使用：

```js
//salt的值是随机生成，每次请求的值都不同，所以每次加密的结果也不同
bcrypt.genSalt(10,function(err,salt){
          bcrypt.hash(newUser.password,salt,(err,hash)=>{
            if(err) throw err
            newUser.password = hash
            newUser.save()
              .then(user => res.json(user))
              .catch(err => console.log(err))
          })
        })
```

## Mock.js

动态的假数据生成器----拦截Ajax请求，生成随机数据

安装：npm i mockjs

基本语法： Mock.mock('地址',{ "dataname|rule":{接口中的json数据} })  

Mock数据模板规范(DTD)：

```js
const Mock = require('mockjs')
const data = Mock.mock({
    //定义数据生成规则，指定生成多少条包含以下全部属性的数据
  'memberList|4':[
    {
      'id': 1,
      //注意：属性名和规则在一个单引号中
        
        
      //name|number ==> 输出number个name，这里number是2所以输出renerene
      //number也可以为1-4这样的区间，则随机生成
      'name|2': 'rene',
      'age|1-120': 1,//随机生成1-120之间的数字
      'salary|6000-8000.1-3': 1,//随机生成6000-8000之间的数字，并且小数是随机的1-3位
        
      //boolean值规则
      'status|1':true,//表示1/2的概率随机生成true或者false
      'open|2-4':false,//【2+4=6】 false的几率为2/6，true的概率为4/6
        
      //对象属性个数规则
       'order|2':{id:1,name:xx,price:5}//此处定义为2，则只输出2个属性，自动在对象中随机挑选两个属性输出==>{id:1,name:xx} 
        //可以是数字也可以是区间，与上同理
        
      //正则表达式规则
       	'属性名':/\d{2}|\d{3}/   //正则表达式中不可以加引号
    }
  ]
})
//格式化json
console.log(JSON.stringify(data, null, 2))
```

Mock数据占位符规范(DPD):

```js
//由于DTD中，多个字符串数据会自动拼接成一整个字符串，不符合真实的数据，所以需要采用DPD模拟
//mock随机文本内容默认为英文，在内容前加上c即可生成中文
const Mock = require('mockjs')
const data = Mock.mock({
  'empList|6': [
    {
    	//每生成一条数据id+1
      'id|+1': 1,
      //随机输出中文名
      'name': '@cname',
      'price': '@float',
      'status': '@boolean',
      //随机生成时间
      'birthday': '@date("yyyy/mm/dd")',
      'createDate': '@datetime("yyyy/mm/dd HH:mm:ss")',
      //随机生成一张空白随机尺寸的图片
      'pic': '@image',
      //随机生成一个标题
      'title':'@title',
      //随机生成一个10-30个字的中文标题
      'ctitle': '@ctitle(10,30)',
      //随机生成一段文章内容
      'content': '@sentence',
      //随机生成中文姓和名
      'first':'@cfirst',
      'last': '@clast',
       //区域,地址
      'area': '@region',
      'address': '@country(true)'
    }
  ]
})
console.log(JSON.stringify(data, null, 2))
```

### Easymock数据接口

是一个可视化，并且可以快速生成模拟数据的服务，其内部内置了Mock.js

用户名&密码：reneforever / wsawsdws95

easymock会提供一个公共的API接口，前端请求需要通过该接口访问

将Mock.mock({})中的内容粘贴到接口的{}内容中即可使用该接口

# 跨域
*广义上的跨域是指一个域下的文档或脚本试图请求另一个域下的资源
*狭义上的跨域是指由浏览器同源策源限制的请求场景

**同源策略/SOP：**是一种约定，同源指的是 **协议 / 域名 / 端口** 三者相同，缺少同源策略，浏览器很容易受到XSS、CSFR攻击
*同源策略规定非同源时限制以下行为： 

1. Cookie、LocalStorage、IndexedDB无法读取
3. DOM和JS对象无法获取
4. Ajax请求不能发送【Ajax XHR对象受同源约束】

**常见跨域场景**

|URL   |说明   | 是否允许通讯 |
|-----|----------------|------------|
|http://www.domain.com/a.js / http://www.domain.com/b.js/ / http://www.domain.com/lab/c.js | 同一域名，不同文件或路径 |允许|
|http://www.domain.com:8000/a.js / http://www.domain.com/b.js|同一域名，不同端口|不允许|
|http://www.domain.com/a.js / https://www.domain.com/b.js|同一域名，不同协议|不允许|
|http://www.domain.com/a.js / http://192.168.4.12/b.js|域名和域名对应相同ip|不允许|
|http://www.domain.com/a.js / http://x.domain.com/b.js / http://domain.com/c.js|主域相同，子域不同|不允许|
|http://www.domain1.com/a.js / http://www.domain2.com/b.js|不同域名|不允许|

## 跨域解决方案
1. jsonp
2. document.domain + iframe
3. location.hash + iframe
4. window.name + iframe
5. postMessage
6. 跨域资源共享（CORS）基于XHR2
7. nginx代理跨域
8. nodejs中间件代理跨域
9. WebSocket协议跨域

*简单的跨域请求jsonp即可，复杂的CORS，窗口之间JS跨域postMessage，开发环境下接口跨域用nginx反向代理或node中间件比较方便

**jsonp**
原理：动态创建script，利用<script>标签的src 不受同源策略约束来跨域获取数据
缺点：只能实现get请求

**注意：**jsonp的回调参数需要前后端保持一致，约定俗称一般是callback

前端部分：

```js
//------原生JS-------
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 //--------Ajax--------
 $.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
//------vue--------
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```
Nodejs后台：

```js
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();

server.on('request', function(req, res) {
    var params = qs.parse(req.url.split('?')[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');

    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```



**document.domain+iframe**
原理：两个页面都通过JS强制设置document.domain为基础主域，实现同域
*仅限主域相同，子域不同的应用场景

```html
//父窗口 (http://www.domain.com/a.html)
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>

//子窗口 (http://child.domain.com/b.html)
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```
**location.hash+iframe**
原理：a欲与b跨域通讯，通过中间页c来实现， 三个页面不同域之间利用iframe的location.hash传值，相同域之间用js访问
```html
场景 ab不同域，bc不同域，ac同域
a.html：(http://www.domain1.com/a.html)
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>

b.html：(http://www.domain2.com/b.html)
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>

c.html：(http://www.domain1.com/c.html)
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
```

**window.name+iframe**

window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

```html
a.html：(http://www.domain1.com/a.html)
<script>
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};
</script>

// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});

//中间代理页，和a同域即可，不需要内容
proxy.html：(http://www.domain1.com/proxy....
            
b.html：(http://www.domain2.com/b.html)
<script>
    window.name = 'This is domain2 data!';
</script>
```

*总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作

**postMessage**

*postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一

*它可用于解决以下方面的问题：
a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的iframe消息传递
d.） 上面三个场景的跨域数据传递

用法：postMessage(data,origin)方法接受两个参数
data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化
origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

```html
a.html：(http://www.domain1.com/a.html)
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };

    // 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>

b.html：(http://www.domain2.com/b.html)
<script>
    // 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data),'http://www.domain1.com');
        }
    }, false);
</script>
```

**跨域资源共享(CORS)**

普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置

需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考：nginx反向代理中设置proxy_cookie_domain 和 NodeJs中间件代理中cookieDomainRewrite参数的设置

目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案

```js
//前端设置
原生Ajax
var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open('post', 'http://www.domain2.com:8080/login', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('user=admin');

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        alert(xhr.responseText);
    }
};

jQuery Ajax
$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});

Vue axios
axios.defaults.withCredentials = true  //跨域需携带cookie时的设置
```

Nodejs后台：

```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var postData = '';

    // 数据块接收中
    req.addListener('data', function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener('end', function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie
            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen('8080');
console.log('Server is running at port 8080...');
```



**nginx反向代理接口**

原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，不存在跨域问题

实现思路：通过nginx配置一个代理服务器(域名和domain相同，端口不同)作为跳板，反向代理访问domain2接口，并且可以顺便修改cookie中的domain信息，方便当前域cookie写入，实现跨域登录

nginx具体配置：

```js
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```
前端部分：
```js
var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();
```
Nodejs后台：
```js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');

server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');
```

**NodeJS中间件代理**

原理：通过代理服务器实现数据转发,后台和nginx相同配置方法

1. node+express+http-proxy-middleware搭建proxy服务器

   ```js
   //------前端代码--------
   var xhr = new XMLHttpRequest();
   
   // 前端开关：浏览器是否读写cookie
   xhr.withCredentials = true;
   
   // 访问http-proxy-middleware代理服务器
   xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
   xhr.send();
   
   var express = require('express');
   var proxy = require('http-proxy-middleware');
   var app = express();
   
   app.use('/', proxy({
       // 代理跨域目标接口
       target: 'http://www.domain2.com:8080',
       changeOrigin: true,
   
       // 修改响应头信息，实现跨域并允许带cookie
       onProxyRes: function(proxyRes, req, res) {
           res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
           res.header('Access-Control-Allow-Credentials', 'true');
       },
   
       // 修改响应信息中的cookie域名
       cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
   }));
   
   app.listen(3000);
   console.log('Proxy server is listen at port 3000...');
   ```

   

2. node+webpack+webpack-dev-serve(vue框架下)

   ```js
   //webpack.config.js配置
   module.exports = {
       entry: {},
       module: {},
       ...
       devServer: {
           historyApiFallback: true,
           proxy: [{
               context: '/login',
               target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
               changeOrigin: true,
               secure: false,  // 当代理某些https服务报错时用
               cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
           }],
           noInfo: true
       }
   }
   ```

**WebSocket协议**

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容

前端部分：

```html
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
```

Nodejs socket后台:

```js
var http = require('http');
var socket = require('socket.io');

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});

server.listen('8080');
console.log('Server is running at port 8080...');

// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });

    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```

# **前端加密**

**MD5**

```html
<script src="../pidcrypt.js"></script>
<script src="../md5.js"></script>
```

使用方式：pidCrypt.MD5（value）

*vue使用MD5：

```js
npm i js-md5

//main.js
import md5 from 'js-md5'
Vue.prototype.$md5 = md5

//使用
this.$md5(value)  //value是加密内容
```

**base64**

```js
npm i js-base64 -s

//main.js
import {Base64} from 'js-base64'
Vue.prototype.Base64 = require('js-base64').Base64

//使用
this.$Base64.encode(value)
```

**RSA**

```html
<script src="../pidcrypt.js"></script>
<script src="../pidcrypt_util.js"></script>
<script src="../asn1.js"></script>
<script src="../jsbn.js"></script>
<script src="../rng.js"></script>
<script src="../prng4.js></script>
<script src="../rsa.js"></script>
```

初始化RSA：

```js
var pubKey = '{$pubKey}';
var keyParams = certParser(pubKey);
var key = pidCryptUtil.decodeBase64(keyParams.b64);
var rsa = new pidCrypt.RSA();
var asn = pidCrypt.ASN1.decode(pidCryptUtil.toByteArray(key));
var tree = asn.toHexTree();

rsa.setPublicKeyFromASN(tree);
```

使用方式：encryptBase64（value，rsa）    value是要加密的值，rsa是初始化好的RSA变量

*vue使用jsencrypt:

```js
npm i jsencrypt

//main.js
import JsEncrypt from 'jsencrypt'
Vue.prototype.$jsEncrypt = JsEncrypt

//使用
methods: {
    //  加密
    encryptedData(publicKey, data) {
      // 新建JSEncrypt对象
      let encryptor = new JSEncrypt();
      // 设置公钥
      encryptor.setPublicKey(publicKey);
      // 加密数据
      return encryptor.encrypt(data);
    },
    // 解密
    decryptData(privateKey,data){
      // 新建JSEncrypt对象
      let decrypt= new JSEncrypt();
      // 设置私钥
      decrypt.setPrivateKey(privateKey);
      // 解密数据
      decrypt.decrypt(secretWord);
    }
  }
```

**OTP**

**SHA256**

```html
<script src="../pidcrypt.js"></script>
<script src="../sha256.js"></script>
```

使用方式：pidCrypt.SHA256（value）

# 数据库

1. 分类：
   - 文件型：足够的简单，存储少量数据---access、sqlite
   - 关系型：适用于各种场景，数据之间有关联---MySQL、Oracle
   - 分布式：部署在多个服务器中---mongoDB
   - NoSQL：性能高，不支持复杂的查询---redis、memcache
2. 安全性
   - 注入
3. 操作
   - 管理性
   - 增删改查

## MongoDB

安装完MongoDB后在磁盘根目录(C:\或者D:\)创建一个data文件，在data文件中再创建一个db文件【安装mongodb时不要勾选安装compass】

顺带给mongodb设置一个环境变量

启动服务器：在cmd中打开mongodb安装目录下的bin文件运行该指令

```c
D:\mongodb\bin\mongod --dbpath D:\data\db
//第一次这样设置，后续都可以直接mongod
```

连接操作服务器：新打开一个cmd在其中输入该指令

```c
D:\mongodb\bin\mongo
```

创建新的数据库

```
1.创建
use 新数据库名
2.写入
db.rene.insert({"name":"rene"})
WriteResult({ "nInserted" : 1 })
```

键入`show dbs`，可得到数据库数据，至此完成创建

### MongoDB指令

| 指令名                | 用途                     |
| --------------------- | ------------------------ |
| mongodb/bin/mongod    | 命令行启动数据库         |
| mongodb/bin/mongo.exe | 命令行操作数据库         |
| show dbs              | 命令行显示所有数据库     |
| use 数据库名          | 命令行切换数据库         |
| show collections      | 命令行展示数据库文件集合 |
| db.集合名.find        | 命令行数据库文件内容显示 |

**MongoDB服务启动**

打开CMD，找到mongoDB安装路径下的bin目录  => 输入启动命令  mongod --dbpath db数据库目录

### Robo 3T 可视化工具

用connect中的create创建一个和数据库名一致的connect项目，使用mongodb默认的27017端口即可

### Mongoose.js

直接使用mongoDB的函数操作数据库比较麻烦，而Mongoose就是一套用来操作mongoDB数据库的接口/

安装：npm i mongoose

根目录下创建一个db.js文件

配置db.js文件：

```js
//引入mongoose工具
const mongoose = require('mongoose')
// 连接数据库
mongoose.connect('mongodb://localhost/rene', { useNewUrlParser: true, useUnifiedTopology: true })
//connect()返回一个状态待定的连接，然后设置成功和失败的提醒
var db = mongoose.connection
db.on('error', console.error.bind(console, 'connection error:'))
db.once('open', function () {
  console.log('数据库ok')
})
```

#### schema 对象

*mongoose是通过schema对象来操作数据库

```js
// schema 对象
// 创建一个和集合相关的schema 对象
var Schema = mongoose.Schema
// 获取schema对象
var userSchema = new Schema({
  us: { type: String, required: true },
  ps: { type: String, required: true },
  age: Number,
  sex: { type: Number, default: 0 }
})
// 将schema对象 转化为 数据模型
var user = mongoose.model('users', userSchema)
    // 该数据对象和集合相关联('集合名'，schema对象)
	//mongodb会自动将集合名转化为复数单词【比如user=>users】,所以直接使用复数单词给集合命名
// 操作数据库
//增
user.insertMany({ us: 'rene', ps: '123', age: 16 })
  .then((data) => {
    console.log(data)
    console.log('添加成功')
  })
  .catch((err) => {
    console.log('添加失败')
  })
//查
user.find() //无条件则默认全局查询
user.find({ us: 'rene' })//条件查询
//删除
user.remove()//全局删除
//改

```

### MongoDB项目目录

```
>项目根目录
  >db
	>model        ==>存储schema对象
	connect.js    ==>mongoose设置
  >router         ==>存放router文件
  >utils          ==>工具文件，存放封装过的工具demo
  server.js       ==>入口文件
```

```js
//schema对象格式
const mongoose = require('mongoose')
var userSchema = new mongoose.Schema({
  us: { type: String, require: true },
  ps: { type: String, require: true },
  age: Number,
  sex: { type: Number, default: 0 }
})

var User = mongoose.model('users', userSchema)

module.exports = User
```

```js
//入口文件设置
const express = require('express')
//引入服务器启动文件
const db = require('./db/connect')
//引入路由
const userRouter = require('./router/userRouter')
const app = express()
//router中间件调用
app.use('/user', userRouter)
//使用post请求则需要引入body-parser插件
const bodyParser = require('body-parser')
app.use(bodyParser.urlencoded({ extended: false }))
app.use(bodyParser.json())

app.listen(3000, () => {
  console.log('***【服务器连接成功】***')
})
```

*由于Schema中的模型已经通过exports暴露，所以可以在router文件中通过const调用Schema方法

```js
const User = require('../db/model/userModel')
User.insertMany({ us: us, ps: ps })
	//例如us和ps，前面的是model中的参数，后面的是客户端res的us和ps
	.then().catch()
```

```js
//独立router文件的编写
const express = require('express')
const router = express.Router()

router.post('/reg', (req, res) => {})

module.exports = router
```

### Atlas

atlas是一个mongodb的官方云数据库

1. 根目录新建一个config文件夹中新建keys.js
2. 在keys.js中配置：

```js
module.exports = {
  mongoURI:"mongodb+srv://test:wsawsdws95@cluster0-otbo9.gcp.mongodb.net/test?retryWrites=true&w=majority"
} 
//此处是atlas提供的api接口
//注意: <password> 整个替换为密码不要留<>
```

3. 在服务器接口文件中配置：

```js
const mongoose = require('mongoose')
const db = require("./config/keys").mongoURI
mongoose.connect(db, {useNewUrlParser:true,useUnifiedTopology:true})
  .then(() => {
    console.log("connected")
  })
  .catch((err) =>{
    console.log("connected failed")
    console.log(err)
  })
```



# 前后端交互

## apiDOC

安装：npm i apidoc -g

配置：在项目文件夹中新建apidoc.json

```
{
  "name": "example",
  "description": "apiDoc basic example",
  "title": "Custom apiDoc browser title",
  "url" : "https://api.github.com/v1"
}
```

*在主要包含接口的JS文件(例如router文件)中写入注释代码

```js
/**
 * @api {get} /user/:id Request User information
    //api后面写请求方式，接口地址，以及接口注释
 * @apiVersion 0.1.0
 * @apiName GetUser
 * @apiGroup User
 *  //接口的名字和分组
 * @apiParam {Number} id Users unique ID.
 *	//接口需要传递的参数，比如用户名和密码这些，以及规定格式
 * @apiSuccess {String} firstname Firstname of the User.
 * @apiSuccess {String} lastname  Lastname of the User.
 * 
 * @apiSuccessExample Success-Response:
 *     HTTP/1.1 200 OK
 *     {
 *       "firstname": "John",
 *       "lastname": "Doe"
 *     }
 *
 * @apiError UserNotFound The id of the User was not found.
 *
 * @apiErrorExample Error-Response:
 *     HTTP/1.1 404 Not Found
 *     {
 *       "error": "UserNotFound"
 *     }
 */
```

运行：apidoc -i 需要注释的文件目录 -o apidpc/ -t 生成api的文档目录 【使用apidoc -h检测是否安装成功】       **直接运行**apidoc也可以直接默认生成doc文件





# 软件系统体系结构

## C/S

- C/S结构即客户端/服务器，例如qq
- 需要编写服务端程序，以及客户端程序 ，例如我们安装的就是qq的客户端程序
- 缺点：软件更新时需要同时更新 客户端和服务器端端，比较麻烦
- 优点：安全性高

## B/S

- B/S结构即浏览器/服务器
- 优点：只需要编写服务器端程序，维护升级简单
- 缺点：安全性较差

# SPA

单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序

**SPA特点：**

- 速度更快：更好的用户体验，让用户在web app感受native app的速度和流畅
- MVVM：经典的MVVM开发模式，前后端分离
- Ajax：重心在前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交
- 前端路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载

**SPA缺点：**

- 首屏渲染时间过长：为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载
- SEO不友好：由于所有的内容都在一个页面中动态替换显示，爬虫只能获取到一个div

**SPA优点：**

- 良好的交互体验：用户不需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示流畅
- 前后端分离开发模式：单页Web应用可以和RESTful规约一起使用，通过REST API提供接口数据，并使用Ajax异步获取，这样有助于分离客户端和服务器端工作
- 减轻服务器压力：服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍
- 共用后端：不用修改后端程序代码就可以同时用于Web界面、手机、平板等多种客户端

## 优化SPA应用首屏加载时间

1. 缩小webpack生成的包的大小：使用webpack-bundle-analyzer分析工具，第三方UI组件按需引入
2. 使用服务端渲染方案：使用基于vue的nuxt.js脚手架搭配vue ssr开发项目，同时解决了SPA对SEO不友好的问题
3. 预渲染：预渲染的方式简单来说就是在正常打包时，会预先运行一次js代码，将一部分静态的页面直接渲染成html写在生成的index.html中，这种方式在加载完index.html后，就会有界面展示出来，无需等待加载js代码后再去渲染，所以这种方式也可以显著的减少首屏加载时间，也可以提高被搜索引擎检索的机会【预渲染工具有prerender-spa-plugin / react-snap / snapshotify / presite】
4. 使用gzip减小网络传输的流量：HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，目前主流的浏览器，Chrome,firefox,IE等都支持该协议。常见的服务器如Apache，Nginx，IIS同样支持gzip。使用gzip可以将原静态文件压缩到30%
5. 懒加载：将每个组件的js代码独立出来，在使用到这个组件时，才向服务器请求文件，并且请求过一次后就会缓存下来，再次使用到这个组件时，就会使用缓存，不再发送请求

# Vue.js

## Vue介绍：

​		简介：Vue是一种构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合（兼容）

​		Vue主要作用于MVC(Model View Controller)中的View，即视图层 ，主打制作前端页面和用户交互。MVVM是把前端视图层分为三个部分：Model，View，ViewModel

​		前端提高开发效率的过程：原生JS >jQuery类库>前端模板引擎>Angular.js>Vue.js(核心概念节省操作DOM元素的时间，加大对业务逻辑的关注)

​		框架和库的区别：是一套完整的解决方案，对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。

## MVC、MVP、MVVM开发模式
### MVC
![](C:\Users\Administrator\Pictures\Saved Pictures\2376645-920ecb14e5f74278.webp)
Model：应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据
View：应用程序中处理数据显示的部分，通常视图是依据模型数据创建的
Controller：应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据
**优点：**

- 耦合性低：视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可
- 重用性高：MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型
- 生命周期成本低：MVC使开发和维护用户接口的技术含量降低
- 部署快：使用MVC模式使开发时间缩短，分离视图和业务逻辑的开发
- 可维护性高：分离视图层和业务逻辑层也使得WEB应用更易于维护和修改

**缺点：**
- 没有明确的定义：MVC内部原理较复杂，模型和视图的分离造成调试困难
- 增加系统结构和实现的复杂性：对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率
- 视图层和控制器连接过于紧密：视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用
- 视图对模型数据的低效率访问：依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。不必要的频繁访问，也会损害操作性能

### MVP
![](C:\Users\Administrator\Pictures\Saved Pictures\2376645-90c6f08ee4ea536a.webp)
Presenter：业务逻辑处理层
**优点：**
- 耦合性低
- 高效：所有的交互都发生在Presenter内部
- 重用性高：我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑

**缺点：**
由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁，Presenter的复杂程度更甚与MVC中的C层

**MVC和MVP的区别：**
作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller
在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 在MVC模型里，更关注的Model的改变，而同时有多个对Model的不同显示，即View。所以，在MVC模型里，Model不依赖于View，但是View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的
虽然 MVC 中的 View 的确可以访问 Model，但是我们不建议在 View 中依赖 Model，而是要求尽可能把所有业务逻辑都放在 Controller 中处理，而 View 只和 Controller 交互

### MVVM
![](C:\Users\Administrator\Pictures\Saved Pictures\2376645-66197c4cd472faf2.webp)
VM：视图模型【与V和M分别双向绑定】
概念：本质上使MVC的改进，MVVM将其中的View的状态和行为抽象化，让视图UI和业务逻辑分开，VM可以取出Model的数据同时帮助处理View中由于需要展示内容而涉及的业务逻辑
**优点：**

- 耦合性低：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变
- 重用性高：可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑
- 独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计
- 可测试：测试可以针对ViewModel来写

**MVVM和MVP的区别：**
mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding): View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作，框架已经帮你做好了

## Vue数据驱动
简单理解：vue数据驱动监视数据的变化，将变化及时反应到视图层(DOM)
注意：Vue在数组操作能 触发视图更新 的仅 push、pop(删除数组最后一个元素并返回该元素)、shift(删除数组第一个元素并返回)、unshift(向数组开头添加元素并返回新数组)、splice、sort(数组元素排序)、reverse(颠倒数组中元素的顺序)这些方法
原理：通过递归的方式将data的属性转化为getter/setter(defineProperty方法)，从而实现数据驱动【对象必须是纯粹的对象(含有key/value的键值对)，浏览器原生API和JS原型都会被忽略】 

## 编程范式 

注：MVVM框架将我们从**命令式编程**转移到**声明式编程**

- 命令式编程：原生操作DOM
- 声明式编程：Vue/React/Angular

## 现代开发模式

- vue/react  对比传统开发模式只花20%的时间在表现层上

- MVC  数据(后端)、表现(class、css)、行为(js)分离

- 模块化开发，组件复用，提高开发效率

- 开发的重心是数据

### 前端渲染、后端渲染概念

前端：是通过ajax请求数据，然后通过js语法将数据展示到页面中 

- 优点：网络传输数据量小。不占用服务端运算资源（解析模板），模板在前端（很有可能仅部分在前端），改结构变交互都前端自己来了，改完自己调就行
- 缺点：前端耗时较多，对前端业务水平要求相对较高。前端代码较多，因为部分以前在后台处理的交互逻辑交给了前端处理。占用少部分客户端运算资源用于解析模板

后端：后端用后台模板引擎直接生成html，前端接受到数据之后，直接插入页面

- 优点：前端耗时少，即减少了首屏时间，模板统一在后端。前端（相对）省事，不占用客户端运算资源（解析模板）
- 缺点：占用服务器资源，后端开发难度增加

### 前端渲染vs后端渲染

- 前端渲染优势：

  页面呈现速度：主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点

  流量消耗：多一点点（一个前端框架大概50KB）当然，有的用后端渲染的项目前端部分也有在用框架

  可维护性：好，前后端分离，各施其职，代码一目明了
  SEO友好度：差，大量使用ajax，多数浏览器不能抓取ajax数据
  编码效率：高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低

- 后端渲染优势：

  页面呈现速度：快，受限于用户的带宽
  流量消耗：少一点点（可以省去前端框架部分的代码）
  可维护性：差（前后端东西放一起）
  seo友好度：好
  编码效率：低（这个跟不同的团队不同，可能不对）

  

*现阶段流行的是前端渲染，前后端同时进行项目开发时，如果前端需要调用的接口是后端没有完成的，则需要使用模拟假数据处理，这种情况叫前后端架构分离

## Vue创建

*在目标文件下引入vue.js(该文件在dist目录)

- 简单的同步数据引入

```html
<body>
    <script src="vue.js"></script>
     <div id="div1">
       姓名:{{name}} <br>   //{{}}在vue作为表达式
       年龄:{{age}} <br>
	   出生:{{new Date().getFullYear()-age}}    //可以做一些简单的表达式计算
     </div>
</body>
<script>
      let vm=new Vue({
          el:'#div1' , //有效根组件范围，出了组件vue代码无效
          data:{		
              name:'blue',
              age:18
              }
          });    
</script>
```

*可以把年龄计算表达式放入vm下的methods中作为一个实例对象然后调用

```html
<div>出生:{{Birth()}}</div>

methods:{
	Birth(){
		return new Date().getFullYear()-this.age
	}
}
```

 *methods可以添加各种复杂的代码

## 指令(directive)

*补充了html的属性

- v-cloak：当网速较慢时，造成数据传输慢于vue渲染速度，防止源码暴露和画面闪烁问题，用于{{}}【Mustache标签】会等待实例准备完毕再渲染

  ```vue
  <div id="app" v-cloak>
      {{context}}
  </div>
  ```

  *然后在CSS中设置样式

  ```css
  [v-cloak]{
      display: none;
  }
  ```

- v-bind(M到V单向绑定)：用来提供绑定属性的指令(将它绑定的属性作为表达式输出)，支持合法且单一的JS表达式 

  ```vue
  <span v-bind:class="classProperty"></span>
  //简写<span :class="classProperty"></span>  以:加属性来表示
  ```

  ```html
  <body>       
          <div id="div1">
              <strong :style="style_str" :class="class_arr">{{name}}</strong>
          </div>      //同时添加了class和style
  </body>
  <script>
          let vm=new Vue({
              el:'#div1',
              data:{
                  name:'blue',
                  age:18,
                  style_str:'width:200px;backgroundColor:pink',
                  class_arr:['aaa','bbb','ccc']
              }
          });
  </script>
  ```


*或者style_json:{width:'200px',backgroundColor:'green'}也可以

- v-model(和数据有关，做数据双向绑定)

  *数据(data)和input之间双向绑定，随便一个改变另一个都会跟着改变

  *MVVM流程是v层操作以后vm(c)层会让m层去读取相应数据，v-model则可以跳过vm(c)层直接让v层和m层进行交互，即让数据和显示部分形成联动

```html
 <body>
     
       <div id="div1">
              <input type="text" v-model='name'>
              <p>{{name}}</p>
       </div>
  </body>
    <script>
        let vm=new Vue({
            el:'#div1',
            data:{
                name:'blue',
                age:18
            }
        })
    </script>
```

*v-model只能和表单数据绑定，例如input(radio、text、address、email)、select、checkbox、textarea，通过v-model进来的数据都是字符串，例如做加减法的化需要转化类型

- v-text  直接输出data中自定义对象的内容且会覆盖html元素本身的内容
- v-html   相当于innerHTML，它可以输出html中的元素，而不是纯字符串例如<h1>xxx</h1>，和v-text一样也会覆盖原本html元素内容

### 自定义指令

自定义指令可以扩展某些场景下对DOM元素的操作，分为全局和局部创建

```vue
//---------全局-----------
<div id="app" class="demo">
    <!-- 全局注册 -->
    <!-- 自定义·指令也需要使用v-xx的格式调用 -->
    <input type="text" placeholder="我是全局自定义指令" v-focus>
</div>
<script>
    // 注册一个全局自定义指令 `v-focus`
    Vue.directive('focus', {
      // 当被绑定的元素插入到 DOM 中时……
      inserted: function (el) {
        // 聚焦元素    el对应的就是DOM中绑定自定义指令的元素
        el.focus()
      }
    })
   
    new Vue({
        el: "#app"
    })
</script>

//---------局部-----------
<div id="app" class="demo">
    <!-- 局部注册 -->
    <input type="text" placeholder="我是局部自定义指令" v-focus2>
</div>
<script>
    new Vue({
        el: "#app",
        directives: {
            focus2: {
                inserted: function(el){
                    el.focus();
                }
            }
        }
    })
</script>
```



## Vue事件

- v-on(事件绑定机制，简称是@)：

  ```html
  <body>
      <script src="vue.js"></script>
      <div id="div1">
          {{a}}
          <input type="button" value="+1" v-on:click="fn()"> //添加v-on：click事件
      </div>
  </body>
  <script>
      let vm=new Vue({
          el:'#div1',
          data:{
              a:12
          },
          methods:{
             fn(){
                 this.a++;    //事件具体函数在这里补充，在vue中methods要想拿到data中的数据u需要通过this方法
              }
          }
      });
  </script>
  //methods属性中定义了当前vue实例中所有可用的方法
  ```

- v-show (true,false控制)：

  ```html
  <style>
      #div2{
            width: 100px;
            height: 100px;
            display: block;
            position: absolute;
            background-color: gray;
          }
  </style>
      <body>
          <div id="div1">               
              <input type="button" value="显示/隐藏" id="btn" @click='fn'>
              <div id="div2" v-show='b'></div>
          </div>
          <script>
              let vm=new Vue({
                  el:'#div1',
                  data:{
                      b:true
                  },
                  methods:{
                      fn(){
                         this.b=!this.b;
                      }
                  }
              })
          </script>
      </body>
  </html>
  ```

  *用v-if和v-show都可以，v-show控制的是display/v-if会删除该元素

- v-for(循环)：

  *v-for(val,key,index)

  ```html
  //循环数组
  <body>
         <div id="div1">
             <ul>
                <li v-for='user in users'>   
                      用户名：{{user.name}},密码：{{user.password}}
                </li>
             </ul>
         </div>
         <script>
              let vm=new Vue({
                  el:'#div1',
                  data:{
                      users:[       //循环的数组
                          {name:'xxx',password:'ww'},
                          {name:'xxx',password:'ss'}
                      ]
                  }
              });
          
          </script>
  </body>
  ```

  1. 数组   v-for=“item、index in array”

  2. json  v-for="val、key in json" 

     ```html
     <body>
           <div id="div1">
                 <ul>
                     <li v-for="val,name in style">  // 值在前，名在后
                         {{name}}:{{val}}
                     </li>
                 </ul>
             </div>
      </body>
      <script>            
                 let vm=new Vue({
                     el:'#div1',
                     data:{
                         style:{width:"100px",height:"200px"}             
                     }
                 });
     
      </script>
     ```
     
  3. 字符串  v-for="char、index in str"
  
  4. 数字  v-for="i in num"
  

注：不推荐v-for和v-if同时使用，因为v-for的优先级更高，会导致v-if在每次循环时重复运行，推荐使用v-show或者计算属性处理

- v-pre:  预编译(提高性能)

  *可以防止意外的解析(不会解析元素内的表达式)

  ```html
  <p v-pre>{{aaa}}</p>===>{{aaa}}
  ```


## 事件修饰符

*为vue事件添加特殊的限定

- .stop 阻止冒泡
- .prevent 阻止默认事件，比如说a标签和表单提交 
- .capture 添加事件侦听器时使用事件捕获模式
- .self 只当事件在该元素本身(比如不是子元素)触发时触发回调
- .once 事件只触发一次
- .passive 滚动行为发生时立即触发，而不是等待滚动行为结束

注：使用方法 【v-on:click.prevent】

## 按键修饰符
**鼠标修饰符**：.left / .right / .middle

**键盘修饰符**

在监听键盘事件时，我们经常需要检查详细的按键。Vue允许为 v-on 在监听键盘事件时添加按键修饰符，这些按键类事件只有在特定按键按下时【$event.key=特定按键】才会触发

```html
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```
可以直接将KeyboardEvent.key暴露的任意有效按键名转换为kebab-case来作为修饰符
```html
<input v-on:keyup.page-down="onPageDown">
```

**系统修饰键：**.ctrl / .alt / .shift / .meta【meta对应windows系统上的菜单键，Mac系统上的command键】

**.exact修饰符**

`.exact` 修饰符允许你控制由精确的系统修饰符组合触发的事件

```html
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button @click.ctrl="onClick">A</button>

<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- 没有任何系统修饰符被按下的时候才触发 -->
<button @click.exact="onClick">A</button>
```

**全局自定义键名**

```html
<input type="text" @keyup.media-play-pause="method">
<script>
    Vue.config.keyCodes = {
      v: 86,
      f1: 112,
      // camelCase 不可用
      mediaPlayPause: 179,
      // 取而代之的是 kebab-case 且用双引号括起来
      "media-play-pause": 179,
      up: [38, 87]
    }
</script>
```



## Virtual DOM

**模板转换成视图的过程：**
1. Vue通过编译将template模板转换成渲染函数(render)，并执行渲染函数得到一个虚拟节点树(VNode tree)
2. 对Model中数据进行操作后,触发对应Dep中的watcher对象，watcher对象会调用对应的update来修改视图【使用patch比对】

*patch：虚拟DOM最核心部分，它将VNode渲染成真实的DOM，这个过程会比对新旧虚拟节点有哪些不同，根据对比结果找出需要更新的节点进行更新。【patch的核心是diff算法】

**虚拟DOM定义：**一个以JS对象(VNode节点)作为基础的树形结构，用对象属性来描述节点，实际上是对真实DOM的抽象
**虚拟DOM渲染过程：**

1. 模板

```html
<template>
	<ul id="myUl">
        <li v-for="item in list">{{item}}</li>
    </ul>
</template>
```
2. 模板 => compile => 渲染函数

```js
createElement(
	'ul',
	{
		attr:{
			id:"myUl"
		}
	},
	[
		createElement('li',1),
		createElement('li',2),
		createElement('li',3)
	]
)
```
3. 渲染函数 => render => 虚拟DOM树

```js
VNode
	child:undefined
	children:Array[3]
		0:VNode
		1:VNode
		2:Vnode
		length:3
		__proto__:Array[0]
		context:Vue$3
		data:Object
		elm:ul
```
4. 虚拟DOM树 => 真实DOM

```html
<ul>
	<li>1</li>
	<li>2</li>
	<li>3</li>
</ul>
```
**虚拟DOM的作用：**虚拟DOM的最终目标是将虚拟节点渲染到视图上，直接使用虚拟节点覆盖旧的DOM节点会导致很多不必要的DOM操作，为了避免这一点，虚拟DOM在虚拟节点映射到视图的过程中，会将虚拟节点和上一次渲染视图所使用的旧虚拟节点进行比对，以此找出需要更新的节点，仅做更新这部分节点的DOM操作
总结VDOM做的两件事：

- 提供与真实DOM节点所对应的虚拟节点VNode
- 将新虚拟节点和旧虚拟节点对比，然后更新视图

### Virtual DOM的优势
- 具备跨平台优势：由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等
- JS运行效率高，将DOM对比操作放在JS层大大提高了渲染效率
- 提升渲染性能：在大量和频繁的数据更新下，可以对视图进行合理高效的更新

## :key属性

*vue默认会给v-for产生的每一个循环元素创建一个key,key是变量所以需要用v-bind指令，即可简写为  :key

*key的属性只能使用number或者string

1. key不会重复
2. key的值不会变

```vue
<li v-for="user in users" :key="user.id">  //系统默认会产生key，也可以自定义key
```

## 过滤器

vue允许自定义过滤器，可以用作一些常见的文本格式化。过滤器可以用在两个地方，双花括号插值和v-bind表达式，过滤器应该被添加在js表达式的尾部

**过滤器引用格式**

```html
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**全局过滤器**

```js
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({
  // ...
})
```

**本地过滤器**

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

## 钩子函数

*可以理解为拆开 自定义事件运行 的 各个步骤，分开定义

**directive自定义全局指令(补充)**

*在全局环境中使用directive()指令 / 也可以定义为私有指令

```js
//全局环境下，1.第一个指令的名称，名称不需要加v-前缀,调用时则需要使用v-前缀
//2.第二个定义一个对象，是该自定义指令的相关函数
Vue.directive('x',{})
```

**指令定义函数提供的钩子函数**

| 函数             | 作用                                                   |
| ---------------- | ------------------------------------------------------ |
| bind             | 只调用一次，指令第一次被绑定到元素时调用，触发在内存中 |
| inserted         | 被绑定元素插入父节点时调用，触发在html页面中           |
| update           | 所在组件的VNode更新时调用                              |
| componentUpdated | 所在组件的VNode及其子VNode全部更新时调用               |
| unbind           | 指令与元素解绑时调用                                   |

```vue
<script>
Vue.directive('focus',
	bind:function(el){//绑定时立即执行bind且只一次
	//在每个函数中，第一个参数永远是el，表示被绑定的那个元素，就是一个DOM对象	
	//在元素刚绑定指令的时候，还没有插入到DOM中，这时候调用focus方法没有作用，因为一个元素只有当插入到DOM中是才能获取焦点	
  },
	inserted:function(el){//元素插入到DOM中执行，触发一次
	el.focus()
  },
	update:function(){//当VNode更新时执行，可能会触发多次
  }
    
})
</script>
//举例：修改颜色
<div id="app">
	<h1 v-color>我要变色了？</h1> //2.自定义属性在调用时必须加上v-
</div>
<script>
		Vue.directive('color',{//1.这里color是自定义属性
			bind:function(el){
				el.style.color='red'
			}
		})
</script>
```

### 钩子函数参数

- el：指令所绑定的元素，可以用来直接操作 DOM 
- binding : 一个对象，包含以下属性：
  - `name`：指令名，不包括 `v-` 前缀
  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`
- `vnode`：Vue 编译生成的虚拟节-+点
- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用

### 开发Vue插件

**Vue插件的作用:**

- 添加全局的方法或者属性
- 添加全局资源【如directives、filters、transitions】
- 通过全局混入来添加一些组件选项
- 添加Vue实例方法，通过把它们添加到Vue.prototype实现
- 创建一个库，提供自己的API

**Vue插件开发方法**

1. 创建一个空对象，这个对象就是日后要使用到的插件的名字。此外，这个对象中要有一个install的函数
2. 使用vue的extend方法创建一个插件的构造函数（可以看做创建了一个vue的子类），实例化该子类，之后的所有操作都可以通过这个子类完成
3. 之后再Vue的原型上添加一个共用的方法

```html
toast.vue
<template>
    <transition name="fade">
        <div class="toast" v-show="show">
            {{message}}
        </div>
    </transition>
</template>

<script>
export default {
  data() {
    return {
      show: false,
      message: ""
    };
  }
};
</script>

<style lang="scss" scoped>
.toast {
  position: fixed;
  top: 40%;
  left: 50%;
  margin-left: -15vw;
  padding: 2vw;
  width: 30vw;
  font-size: 4vw;
  color: #fff;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.8);
  border-radius: 5vw;
  z-index: 999;
}

.fade-enter-active,
.fade-leave-active {
  transition: 0.3s ease-out;
}
.fade-enter {
  opacity: 0;
  transform: scale(1.2);
}
.fade-leave-to {
  opacity: 0;
  transform: scale(0.8);
}
</style>
```

插件配置文件

```js
index.js
import ToastComponent from './toast.vue'

const Toast = {};

// 注册Toast
Toast.install = function (Vue) {
    // 生成一个Vue的子类
    // 同时这个子类也就是组件
    const ToastConstructor = Vue.extend(ToastComponent)
    // 生成一个该子类的实例
    const instance = new ToastConstructor();

    // 将这个实例挂载在创建的div上
    // 并将此div加入全局挂载点内部
    instance.$mount(document.createElement('div'))
    document.body.appendChild(instance.$el)
    
    // 通过Vue的原型注册一个方法
    // 让所有实例共享这个方法 
    Vue.prototype.$toast = (msg, duration = 2000) => {
        instance.message = msg;
        instance.show = true; 

        setTimeout(() => {           
            instance.show = false;
        }, duration);
    }
}

export default Toast
```

将插件在main.js中引入并使用

```js
import Vue from 'vue'
import App from './App'

import Toast from './components/toast'
Vue.use(Toast)

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  render: h => h(App)
}).$mount('#app')
```

在其他文件中引用应用

```html
// app.vue
<template>
  <div id="app">
    <loading duration='2s' :isshow='show'></loading>
    <!-- <button @click="show = !show">显示/隐藏loading</button> -->
    <button @click="toast">显示toast弹出框</button>
  </div>
</template>

<script>
export default {
  name: "app",
  data() {
    return {
      show: false
    };
  },
  methods: {
    toast() {
      this.$toast("你好");
    }
  }
};
</script>

<style>
#app {
  font-family: "Avenir", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```



## Vue响应式原理分析

响应式：当数据改变后，Vue会通知到使用该数据的代码
- vue2.0核心:通过Object.defineProperty中的setter/getter方法进行数据劫持
- vue3.0核心:通过Proxy进行数据劫持

```js
//-----引用proxy劫持处理数据------
export function reactive(obj) {
  const proxied = new Proxy(obj, handlers);

  return proxied;
}
//------声明一个handles函数处理逻辑-------
const handlers = {
    get: function(target, key, receiver) {
        ...
    },
    set: function(target, key, value, receiver) {
        ...
    },
    deleteProperty(target, key) {
        ...
    }
    // ...以及其他 trap
  }
```

### Vue2.0实现

![](C:\Users\Administrator\Pictures\Saved Pictures\5791681-f06c886b45bf2e02.webp)

*ast：抽象语法树

**1. 通过Observe函数遍历data中的数据**

```js
function observer(value){
	if(!value || (typeof value !== 'object')){
		return;
	}
	Object.keys(value).forEach((key) => {
		defineReactive(value,key,value[key]0);
	})
}
```
**2. defineProperty做订阅-发布处理**

```js
function defineReactive(obj,key,val){
	//引用一个Dep类对象
	const dep = new Dep();
	Object.defineProperty(obj,key,{
		enumerable:true,
		configurable:true,
		get:function reactiveGetter(){
			//将Dep.target(即当前的Watcher对象存入dep的subs中)
			dep.addSub(Dep.target);
			return val;
            
		},
		set:function reactiveSetter(newVal){
			if(newVal === val) return;
			//在set的时候触发dep的notify来通知所有的watcher对象更新视图
			dep.notify();
		}
	})
}
```
所谓的响应式处理，则是拦截属性的get、set方法做订阅-发布处理。订阅-发布处理，就是在属性被调用的使用，触发get代理函数，订阅调用该属性的组件(将组件存放到一个订阅者数组中进行保存，这里的Dep.target暂时可以理解为一个全局变量，代表着的是当前正在渲染的Vue组件)。 而在属性被修改时，触发set代理函数，在set代理函数里，通知订阅者数组里面的每一个订阅者（组件）进行视图更新
**3. Dep订阅者设置**
Dep是一个依赖类，将它理解成一个订阅者。当对一个属性进行响应式处理的时候，就会实例化一个Dep实例，并将用到这个属性的组件全部存放在subs数组里。当属性被修改时，则通知subs数组里的所有组件进行更新

```js
class Dep{
	constructor(){
		//用来存放watcher对象的数组
		this.subs = [];
	}
	//在subs中添加一个watcher对象
	addSub(sub){
		this.subs.push(sub);
	}
	//通知所有watcher对象更新视图
	notify(){
		this.subs.forEach((sub) => {
			sub.update(); 
		})
	}
}
```
**4. Watcher实例**
dep.subs里面存的是用到该属性的组件，这个说法实际上不完全对。准确来说，dep.subs里面存的是用到该属性的组件所对应的一个Watcher实例。什么是Watcher？每一个组件在渲染之前，会对其自身的template模板进行解析编译，生成一个render函数（用于创建虚拟dom）。然后，会实例化一个Watcher对象，在实例化的过程中，会将之前生成的render函数作为参数传入进去执行。而在执行render的过程中，势必会触发相应属性的get函数，将这个watcher实例添加到相应属性的订阅者数组subs当中。等这些属性进行被修改时，就会通知这个watcher，再次调用这个watcher里面的render函数，进行虚拟dom的diff和更新

2.0响应式的不足

1. 动态添加响应式属性必须使用Vue.set
2. 直接操作数组索引无法触发视图更新
3. 数据的响应式处理和视图未完全解耦

### Vue3.0实现

![](C:\Users\Administrator\Pictures\Saved Pictures\5791681-fd465dd6fc288136.webp)

Vue3.0响应式框架在设计上，将视图渲染和数据响应式完全分离开来。将响应式核心方法effect从原有的Watcher中抽离。这样，当我们只需要监听数据响应某种逻辑回调(例如监听某个text属性的变化，对他进行正则校验等。)，而不需要更新视图的时候，完全可以只从effect触发，屏蔽左边的视图渲染

**1. reactive**

```js
export function reactive(target){
	//通过该方法创建响应式对象数据
	return createReactiveObject(
		target,  //原始数据
	)
}
```
**2. Proxy**

```js
function createReactiveObject(target){
	//声明一个代理对象，也即是响应式数据
	let observed = new Proxy(target, {
		get(target,key,receiver){
			let result = Reflect.get(target,key,receiver)
			track(target)  //订阅者、收集依赖
			return isObject(result) ? reactive(result) : result
		},
		set(target,key,value,receiver){
			Reflect.set(target,key,value,receiver)
			trigger(target,key)  //发布者、发送属性更新通知
		}
	})
	...
	return observed
}
```
Vue3.0响应式相对于Vue2.0的最大区别在于用到了es6中的方法Proxy。这个方法不需要循环遍历data的每个属性，对每个属性都做一遍响应式处理。而是直接代理了整个data对象，拦截这个对象所包含的所有属性的get、set方法。这么做的好处:
1.就是在我们动态为data添加一个属性时，不用做任何处理，这个属性就已经是响应式的了
2.数组的任何操作也都可以触发响应

**3. effect**

```js
let obj = reactive({name:'rene'})

effect(() => {
	return `<div>${obj.name}</div>`  //render函数
})

obj.name = 'rene-name'
```
当调用effect执行某个函数时，首先会执行一次这个函数，之后每次obj.name修改时，执行一次该函数。下面是实现这种功能的方法

```js
let cbArr = []
function effect(cb){
	cbArr.push(cb)
	cb()
	cbArr.pop()
}
```

effect会先将传入的回调函数保存起来，然后第一次执行cb(),在执行的过程中，触发了obj.name属性的get代理函数，在代理函数里面做订阅track(target), 而track函数则会将存在全局数组中的cb函数取出来，保存在map中,类似于map.set('name',cb)。之后，在name属性被修改的时候，会触发name属性的set代理函数，在代理函数里面执行trigger。最后，trigger会将之前存在map里的订阅着取出来执行，map.get('name')

*Vue2.x版本使用的Object.defineProperty无法监听对象属性的增删、数组元素和长度的变化，所以在3.x版本使用 ES2015中的**Proxy** 代替 Object.defineProperty，解决了监听对象属性增删、数组元素和长度变化的监听，同时增加了监听Map、Set、WeakSet、WeakMap，还实现了惰性监听【Object.defineProperty兼容ie9以上，Proxy不兼容ie，对于ie仍使用Object.defineProperty】



## Vue生命周期(事件)

- 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期

- 生命周期钩子：就是生命周期事件

- 主要生命周期函数(钩子函数)分类：

  - 创建期间的生命周期函数 

    ```
    1.beforeCreate:实例刚在内存中被创建出来，此时还没有初始化好data和methods属性
    2.created:实例已经在内存中被创建，data和methods也创建完毕，但是没有开始编译模板
    3.beforeMount:此时已经完成了模板编译，还没有挂载到页面中
    4.mounted:此时已经将编译好的模板挂载到页面中显示
    ```

  - 运行期间的生命周期函数

    ```
    1.beforeUpdate:状态更新前运行函数，此时data中的状态时最新的，但是页面中的数据是陈旧的，此时还没有重新渲染DOM节点
    2.updated:实例更新完毕后调用该函数，此时页面已经完成更新，DOM节点渲染完成
    ```

  - 销毁期间的生命周期函数

    ```
    1.beforeDestroy:实例销毁之前调用，在这一步，实例仍然完全可用
    2.destroyed:Vue实例销毁后调用，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁
    ```

*钩子函数写在vue实例内，和data/el同级格式是：`created:function(){}`

## Vue动画

*动画能够提高用户的体验，帮助用户更好的理解页面中的功能【基于transform和transition实现】

1. 先使用transition元素包裹需要被动画控制的元素
```vue
<transition>
   <h3 v-if="flag">这是一个h3</h3>
</transition>
   //transition可以设置name属性，不设置CSS默认 .v- ，设置以后CSS改为  .newName-
   //transition必须配合事件使用单独使用不会显示效果
```

2. 自定义两组样式控制transition内部的元素实现动画

   ```css
   <style>
      //将样式分成两组，一组为动画结束后效果，一组为动画执行效果
       .v-enter,
       .v-leave-to{
           opacity:0;
           transform: translateX(200px)
       }
       .v-enter-active,
       .v-leave-active{
           transition: all 1s ease;
       }
   </style>
   ```

*在实现列表过渡的时候，如果需要过渡元素，是通过v-for循环渲染出来的则不能使用transition包裹，需要使用transitionGroup

*transition加上appear属性可以实现入场动画效果，Vue会默认将transition渲染为span，这个行为不符合W3C规范，借用tag属性改变

*transition有个属性mode，可以改变入场出场切换的方式

```vue
<transition mode="out-in">
```

```vue
<transition-group appear tag='ul'>
          <li v-for="item in list" :key="item.id">
                {{item.id}} ---- {{item.name}}
          </li>
</transition-group>
//此时浏览器会将transition直接渲染为ul，符合W3C规范
```

*如果要为v-for循环创建元素设置动画，必须为每一个元素设置 :key 属性

```vue
<style>
	.v-enter,
    .v-leave-to{
        opacity: 0;
        transform:translateX(80px); 
    }
    .v-enter-active,
    .v-leave-active{
        transition: all 0.6s ease;
    }
    .v-move{
        transition: all 0.6s ease;
    }
    //设置move样式作为元素移动的过渡样式
    .v-leave-active{
        position: absolute;/
    }
    //move必须配合position:absolute使用
</style>
<transition-group>
          <li v-for="item in list" :key="item.id">
                {{item.id}} ---- {{item.name}}
          </li>
</transition-group>
```

*样式部分可以使用animate.css文件引入预设样式

【$ npm install animate.css --save】

```vue
//main.js
<script>
    import animated from 'animate.css'
    Vue.use(animated)
</script>
//组件app
<html>   
    <transition enter-active-class="animated bounceIn" leave-active-class="animated bounceOut" :duration="{enter:200,leave:200}">
        <h3 v-if="flag">这是一个h3</h3>
    </transition>
</html>
```

*animated是class前缀 / :duration是样式过渡时间

3. 半程动画(JavaScript钩子)

   ```vue
   //动画的生命周期函数
   <transition
               //入场钩子函数
     v-on:before-enter="beforeEnter"
     v-on:enter="enter"
     v-on:after-enter="afterEnter"
     v-on:enter-cancelled="enterCancelled" 
   			//离场钩子函数
     v-on:before-leave="beforeLeave"
     v-on:leave="leave"
     v-on:after-leave="afterLeave"
     v-on:leave-cancelled="leaveCancelled"
   >
   </transition>
   ```

*半程动画就是只定义入场钩子函数事件

```VUE
<transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter">
            <div class="ball" v-show="flag"></div>
</transition>
<script>
     methods: {
         //动画钩子函数的第一个参数el：表示要执行动画的那个DOM元素，是个原生的JS对象
         //类似于document.getElementById('')
         //beforeEnter表示动画尚未开始，可以设置动画的其实样式
        beforeEnter(el){
            el.style.transform='translate(0,0)'
        },
           //表示动画开始之后的样式，这里设置动画过渡动画及完成动画的结束状态
        enter(el,done){
             el.offsetWidth//过渡动画必须写入这句指令，虽然没有实际效果，但是是必须的，它可以保证动画强制刷新
            
            el.style.transform='translate(150px,450px)'
            el.style.transition='all 1s ease' 
            
             done()//这里的done函数其实就是afterEnter这个函数，done()就是函数的引用，作用是在动画结束后立马执行afterEnter不会出现延迟的情况
             },
                 //动画完成时调用
        afterEnter(el){
            this.flag=!this,flag
         }
        }
 </script>
```


## vue使用样式

*如果样式里包含  -  则必须使用引号

### 使用class样式(用v-bind绑定，且需要先在CSS中创建样式)

```vue
1.数组
<h1 :class="['red','thin']">xxxxxx</h1>
2.数组中使用三元表达式
<h1 :class="['red','thin',isactive?'active':'']">xxxxxx</h1>
3.数组中嵌套对象
<h1 :class="['red','thin',{'active':true}]">xxxxx</h1>
4.直接使用对象
<h1 :class="{res:true,italic:true,active:true,thin:true}">xxxxxx</h1>
```

### 使用内联样式

```vue
1.直接在元素上通过:style的形式，书写样式对象
<h1 :style="{color:'red','font-size':'40px'}">xxx</h1>
2.将样式对象，定义到data中，并直接引用到:style中
data:{
	a:{color:'red','font-size':'40px'}
}
<h1 :style="a">xxx</h1>
3.在:style中通过数组，引用多个data上的样式对象
data:{
	a:{color:'red','font-size':'40px'}，
	b:{font-style:'italic'}
}
<h1 :style="[a,b]">xxx</h1>
```



## Vue组件

- 什么是组件：组件的出现，就是为了拆分Vue实例的代码量，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件

- 组件和模块化的不同：
  - 模块化是从代码逻辑的角度进行划分的；方便代码分层的开发，保证每个功能模块的职能单一
  - 组件化是从UI界面的角度进行划分的；方便UI组件的重复使用

1. 第一种创建组件的方法

```vue
<div id="app">
        <!-- 3.如果要使用组件，直接把组件的名称，以HTML的形式引入到页面中即可  不可以使用驼峰命名法-->
        <my-com1></my-com1>  
</div>
    <script>
        //1.使用Vue.extend来创建全局的Vue组件
        var com1=Vue.extend({
            template: '<h3>这是一个组件引用h3</h3>'//通过template属性，预定了组件要展示的HTML结构
        })
        //2.使用Vue.component('组件名')创建组件模板对象
        Vue.component('myCom1',com1)
    	        
       //或者直接合并为一个方法,component第一个参数是组件的名称,在DOM中用标签形式引入 
        //第二个参数是extend创建的组件，其中template中的是HTML中将要展示的内容
        Vue.component('myCom1',Vue.extend({
            template: '<h3>这是一个组件引用h3</h3>'
        }))
</script>
```

2. 第二种创建组件的方法

   *不借助Vue.extend，直接使用component

   *组件的template属性指向的模板内容，必须有且只有一个根元素

   ```vue
   Vue.component('myCom1',{
               template: '<h3>这是一个组件引用h3</h3>'
           })
   ```

3. 第三种创建组件的方法

   *直接使用id在Vue外部定义

   ```vue
   <template id="id"></template>
   <script>
   Vue.component('myCom1',{
               template: '#id'
           })
   ```

### Vue组件引入图片

Vue中的js引入图片需要使用require js

```js
//------引入图片需要借助require作为模块导入-----
userlist: [
        {
          username: '小明',
          //将图片地址用require包裹
          headerimg: require('./assets/img/头像1.jpg')
        }
     ]
```



### extends、Vue.extend和Vue.component

1.extends

```js
//---继承----
var CompA = {...}
var CompB = {
	extends:CompA,
	...
}
```

注：extends在不使用Vue.extend的情况下，继承  另一个对象的属性和方法

2.Vue.extend

使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象

```html
<div id="mount-point"></div>
<script>
	// 创建构造器
    var Profile = Vue.extend({
      template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
      data: function () {
        return {
          firstName: 'Walter',
          lastName: 'White',
          alias: 'Heisenberg'
        }
      }
    })
    // 创建 Profile 实例，并挂载到一个元素上。
    new Profile().$mount('#mount-point')
</script>

//-----结果如下------
<p>Walter White aka Heisenberg</p>
```

3.Vue.component

注册或获取全局组件，注册过程中还会自动使用给定的id设置组件的name

```js
//注册组件，传入一个扩展过的构造器
Vue.component('my-component',Vue.extend({ }))

//注册组件，传入一个选项对象(自动调用Vue.extend)
Vue.component('my-conponent',{ })

//获取注册的组件(始终返回构造器)
var MyComponent = Vue.component('my-conponent')
```

`Vue.component()`会注册一个全局的组件，其会自动判断第二个传进来的是Vue对象（`Vue.extend`）还是普通对象(`{...}`)，如果传进来的是普通对象的话会自动调用`Vue.extend`

**总结**

理解`Vue.extend()`和`Vue.component()`是很重要的。由于Vue本身是一个构造函数(`constructor`)，`Vue.extend()`是一个继承于方法的类（`class`），参数是一个包含组件选项的对象。它的目的是创建一个Vue的子类并且返回相应的构造函数。而`Vue.component()`实际上是一个类似于`Vue.directive()`和`Vue.filter()`的注册方法，它的目的是给指定的一个构造函数与一个字符串`ID`关联起来。之后Vue可以把它用作模板，实际上当你直接传递选项给`Vue.component()`的时候，它会在背后调用`Vue.extend()`

### 组件中的data

*组件也可以创建自己的data，但是必须作为function形式

```vue
<script>
Vue.component('myCom1',{
            template: '',
            data:function(){}
        })
    //实例中的data是一个对象，组件中的data必须是方法，方法内部必须返回一个对象
```

### 使用Vue自带组件

```vue
<!-- Vue提供了component来展示对应名称的组件 -->
        <!-- component是一个占位符  :is属性用来绑定要展示的组件名称 -->
        <component :is="login"></component>
```

*在Vue实例中设置comName属性，改变is的指向

```vue
<component :is="comName"></component>
<script>
let vm = new Vue({
	data:{
       comName:':is中绑定的组件名'
	}
})
//这样元素可以直接设置 comName="组件名" 
```

### 父子组件通信

子组件不可以直接访问父组件和vm实例内的数据，但是开发中一些数据需要从上层传递到下层

- 比如在一个页面中，我们从服务器请求到了很多的数据
- 其中一部分数据，并非是我们整个页面的大组件来展示，而是需要子组件进行展示
- 这个时候不会让子组件再发送一次网络请求，而是直接让父组件将数据传递给子组件
- vm实例是根组件，相当于父组件的父组件

父子常规通讯方式：

1. 父传子 --> 子组件创建props属性并调用，在标签里用v-bind向子组件props属性赋予父组件属性的值
2. 子传父 --> 在自定义事件中，子组件用$emit()触发事件，父组件用v-on监听子组件事件

 父传子：

```vue
  <div id="father">
    <child v-bind:msg= "message" class="child"> 
    <!-- 通过 v-bind 动态赋值子组件以父组件的属性 -->
    </child>
  </div>
   
  <script>
    let child = {
      template: `<div>
      <p>下面是来自爸爸的信息:</p>
      <p>{{ msg }}</p>
    </div>`,
      props: ['msg']
    }
    let father = new Vue({
      el:'#father',
      components: { child }, // 注册子组件
      data: {
        message: 'message from father'
      }
    })
  </script>
```

*注意v-bind不支持驼峰命名，如果子组件变量用驼峰命名的话，在v-bind上需要改为 `-` 号连接的格式

子传父：

```vue
  <div id="app">
      // 2.监听emit派发的事件，绑定到父组件创建的事件中
    <my-button @child="sayHi"></my-button>
  </div>

<script>
  let MyButton = Vue.extend({
    template:`<button @click="handleClick">点击传值</button>`,
    data(){
      return{
          //子组件的属性值
        childSend: 'this is child'
      }
    },
    methods: {
      handleClick(){
         //1.emit派发 点击事件 触发后发送子组件属性
        this.$emit('child',this.childSend)
      }
    },
  })
  let vm = new Vue({
    el:'#app',
    data(){
      return{}
    },
    components:{
      MyButton
    },
    methods:{
       //3. 父组件获取回调值并使用 
      sayHi(val){
        alert(`Hi,`+ val) //Hi,this is child
      }
    }
  })
```

*在子组件中，通过$emit()来触发事件

*在父组件中，通过v-on来监听子组件触发的事件



### 父子组件的访问方式

*有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件

- 父组件访问子组件：使用$children或ref(reference引用)
- 子组件访问父组件：使用$parent

父访问子：

1. $children

   ```js
   //在父组件中使用$children方法可以获取一个VueComponent数组，数组中包含很多属性
   let vm = new Vue({
               el:'#app',
               data:{},
               methods:{
                 clk(){
                     //注意：因为返回的是数组，所以必须使用数组下标的形式拿到元素
                   console.log(this.$children[0])
                   }
               },
            components:{
                   tmp1
                 }
          })
   ```

2. $refs(默认为空对象)

   ```vue
   //使用方法：通过在任意子组件上加入ref属性来获取该子组件
   <div id="app">
     //通过给子组件定义一个ref属性来获取组件内的值，相当于加上一个id
       <tmp1 ref='aaa'></tmp1>
       <button @click="clk"></button>
   </div>
   <script>
   let vm = new Vue({
               el:'#app',
               data:{},
               methods:{
                   clk(){
   				//获取组件内值时需要$refs加上自定义组件名
                       console.log(this.$refs.aaa.name)
                   }
               },
               components:{
                   tmp1
               }
           })
   ```

**注意：**`ref` 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 `$refs` 对象上，ref在mounted时才能调用，$refs不是响应式对象

子访问父：

3. $parent

```vue
<template id="tmp1">
        <div>
            我是子组件
            <button @click="childClick">子组件按钮</button>
        </div>
    </template>
    <script>
        const tmp1 = {
            template: '#tmp1',
            data() {
                return {}
            },
            methods: {
                childClick() {
                    //$parent打印出的是父组件的属性
                    // 通过$parent访问父组件
                    console.log(this.$parent.name)
                }
            }

        }
        let vm = new Vue({
            el: '#app',
            data: {
                name: '我是父组件'
            }
```

4. $root：直接获取vue实例所有属性


### ref和$refs 

- ref：用来给元素或子组件注册引用信息，引用信息将会注册在父组件的$refs对象上。【如果在普通的DOM元素上使用，引用指向的就是DOM元素】
注：this.$refs绑定的是原生DOM对象，ref的属性值命名不可以重复

```vue
//元素绑定ref属性
<input ref="moblie">
//通过$refs获取绑定ref属性的元素的集合
this.$refs.moblie
```

### .sync修饰符

在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。

这也是为什么推荐以 `update:myPropName` 的模式触发事件取而代之。举个例子，在一个包含 `title` prop 的假设的组件中，可以用以下方法表达对其赋新值的意图

```js
this.$emit('update:title', newTitle)
//vue推荐发送的事件名用update:name这种方式
```

然后父组件可以监听那个事件并根据需要更新一个本地的数据属性

```html
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```

为了方便起见，vue为这种模式提供一个缩写，即 `.sync` 修饰符

```html
<text-document v-bind:title.sync="doc.title"></text-document>
//当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用
<text-document v-bind.sync="doc"></text-document>
//把 doc 对象中的每一个属性 (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器

.sync其实就是一个语法糖，它在编译的时候会转化为正常语法，以下是转变的思路
<child @update:isShow="changeIsShow" v-show="isShow"/>  //changeIsShow是父组件获取回调值的函数
<child @update:isShow="function(bol){isShow=bol}" v-show="isShow"/>  //将回调函数内联化
<child @update:isShow="bol=>isShow=bol" v-show="isShow"/>  //简写匿名函数
<child :isShow.sync="isShow" v-show="isShow"/>  //用.sync语法糖代替内联函数，两者解析后相同
```

**注意：**带有 `.sync` 修饰符的 `v-bind` **不能**和表达式一起使用 (例如 `v-bind:title.sync=”doc.title + ‘!’”` 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 `v-model`

### v-slot                                                                                                                                                                                                                                                                                                      

*组件的插槽为了让我们封装的组件更加具有扩展性(比如说多界面公用一个导航，每个页面导航栏都具有一定的共性：总体框架相同内容不同，所以采用预留多个插槽的方式来存放不同样式的组件)

*组件化开发，安排插槽就是为了抽取共性，保留不同，不同的地方全部预留成插槽，规避重复开发

```vue
1.匿名插槽(默认插槽default)
父组件页面：
<template v-slot:default>
   <p>我是匿名插槽 </p>
</template>
子组件页面：
<slot>我是默认值</slot>

2.具名插槽(name)
父组件页面：
<template v-slot:name1>
    <p>我是匿名插槽 </p>
</template>
子组件页面：
<slot name:'name1'>我是默认值</slot>

3.作用域插槽(slotProps可以接受子组件的data数据)
父组件页面：
 <template v-slot:todo="slotProps" >
   {{slotProps.user.firstName}}
 </template> 
 子组件页面：
 <slot name="todo" :user="user" :test="test">
    {{ user.lastName }}
 </slot> 
data() {
    return {
      user:{
        lastName:"Zhang",
        firstName:"yue"
      }
  },
```

### Mixin

当需要两个非常相似却存在一定差异化的组件，不需要单独定制两个组件或者通过props传值的方式区分它们。此时使用mixin，它允许封装一个可以应用在其他组件中的函数

假设有两个都是显示和不显示功能的组件

```js
 // 模态框
      const Modal = {
        template: '#modal',
        data() {
          return {
            isShowing: false
          }
        },
        methods: {
          toggleShow() {
            this.isShowing = !this.isShowing;
          }
        },
        components: {
          appChild: Child
        }
      }

      // 提示框
      const Tooltip = {
        template: '#tooltip',
        data() {
          return {
            isShowing: false
          }
        },
        methods: {
          toggleShow() {
            this.isShowing = !this.isShowing;
          }
        },
        components: {
          appChild: Child
        }
      }
```

提取逻辑单独封装

```js
//toggle.js
	const toggle = {
         data() {
           return {
             isShowing: false
           }
         },
         methods: {
           toggleShow() {
             this.isShowing = !this.isShowing;
           }
         }
       }
```

引入这个mixin对象

```js
import {toggle} from './mixins/toggle' 

const Modal = {
         template: '#modal',
         mixins: [toggle],
         components: {
           appChild: Child
         }
       };

       const Tooltip = {
         template: '#tooltip',
         mixins: [toggle],
         components: {
           appChild: Child
         }
       };
```

#### mixin理解

组件在引用之后相当于**在父组件里开辟了一块单独的空间**，需要通过父子组件之间通信来进行操作，所以本质上仍有隔阂。 mixins则是在引入组件之后，将 组件内部的 **所有属性和方法**(如data、methods) 与父组件相应内容进行合并。【相当于在引入子组件后，父组件的各种属性方法都被扩充了】

#### mixin合并规则

- 数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先
- 同名钩子函数将合并为一个数组，因此都将被调用。此外，混入对象的钩子将在组件自身钩子之前被调用
- 值为对象的选项，例如methods、components和directives，将被合并为同一对象，两个对象键名冲突时，取组件对象的键值对

1. 局部mixins

   ```vue
   //toggle.js
   <script>
   export const toggle = {
     data() {
       return {
         "show": false
       }
     },
     methods: {
       changeState() {
         this.show = !this.show;
       }
     }
   };
   </script>
   //----父组件----
   <template>
     <div>
       <div v-show="show">
         <p>提示框</p>
       </div>
         <!--使用继承来的changeState方法-->
       <button @click="changeState">click</button>
     </div>
   </template>
   
   <script>
   import {toggle} from './mixins/toggle'
   
   export default {
       //此时父组件继承了子组件的methods方法
     mixins: [toggle]
   }
   </script>
   ```

2. 全局mixins

   ```vue
   <script>
   import vue from 'vue'
   
   vue.mixin({
     created() {
       //自定义选项
       const myOption = this.$options.myOption;
       if (myOption) {
         //如果myOption有值则打印
         console.log(myOption);
       }
     }
   })
   
   export default {
     myOption: "hello world!"
   }
   </script>
   ```

   **注意：**请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入

## Vue Router(路由)

### 后端路由&前端路由

- 后端路由：对于普通网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源
- 前端路由：对于单页面应用程序来说，主要通过URL中的hash(网址#后的内容)来实现不同页面之间的切换，同时，hash有一个特点:http请求中不会包含hash相关的内容，所以，单页面跳转主要用hash实现
- 在单页面应用中，这种通过hash改变来切换页面的方式称之为前端路由

```vue
<div id="app">
    	// #/表示的是hash链接
        <a href="#/login">登录</a>
        <a href="#/register">注册</a>
       <!-- 3.放置router容器 这是vue-router提供的元素，专门用来作为占位符的 -->
       <!-- 路由规则匹配到的的组件，就会展示到该组件中 -->
        <router-view></router-view>
</div>
    <script>
        //组件的模板对象
        var login = {
            template: '<h1>登录组件</h1>'
        }
        var register = {
            template: '<h1>注册组件</h1>'
        }
        //1.创建一个路由对象，当导入vue-router包之后，在window全局对象中，就有了一个路由的构造函数，叫做vueRouter
        //在new路由对象的时候，可以为构造函数，传递一个配置对象
        var routerObj = new VueRouter({
            //这个配置对象中的route表示 路由匹配规则 的意思
            routes: [//设置多个路由匹配规则
                //每个路由队则，都是一个对象，这个规则对象，身上，有两个必须的属性
               
                { path: '/', redirect: '/login' },
                //重定向，自动把根目录定义在login页面
                
                //属性1：path，表示监听 特定的路由链接地址
                //属性2：component，表示，如果路由是前面匹配到的path则展示component对应的组件
                { path: '/login', component: login },//component里需要放的是对象，不能是字符串
                { path: '/register', component: register }
            ]
        })
        //创建Vue实例，得到ViewModel
        let vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            //2.将路由规则对象，注册到vm实例上，用来监听URL地址的变化，展示对应的组件
            router:routerObj

        });
```

*使用hash，a链接必须要加#才可以正常显示，为此vue中可以使用<router-link>标签

```vue
<router-link to="/login">登录</router-link>
//在页面中默认渲染为a标签
//router-link to相当于在vm实例中methods中添加this.$router.push()或者replace()方法
```

*设置router-link打开新页面也是可以的

```vue
<router-link tag="a" target="_blank" to="/login">登录</router-link>
//通过tag属性将routerlink渲染为a标签，用target打开新页面，再用to改变hash
```

### hash&history

前端路由实现两个功能：

1. 记录当前页面的状态(保存当前页的URL，再次打开依然是保存时的状态)
2. 可以使用浏览器的前进后退功能

通过开发实现前端路由：

1. 改变URL且不让浏览器向服务器发送请求
2. 检测URL的变化
3. 截获URL地址，并解析出需要的信息来匹配路由

*前端路由通过hash和history模式来实现以上功能

**hash：**指URL地址里#以后的部分，hash值的改变不会使浏览器向服务器发送请求，但是hash值改变会触发hashchange事件，可以监听hashchange事件实现对应的触发事件

```js
window.location.hash='qq'//设置 url 的 hash，会在当前url后加上'#qq'

var hash = window.location.hash //'#qq'

window.addEventListener('hashchange',function(){
  //监听hash变化，点击浏览器的前进后退会触发
})
```

**history：**history模式不仅可以在URL里放入参数还可以将数据存放在一个特定对象中，history利用HTML5 History Interface 中新增的pushState()和和replaceState()方法

```js
window.history.pushState(state,title,url)
//state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取
//title：标题，基本没用，一般传null
//url：设定新的历史纪录的url。新的url与当前url的origin必须是一样的，否则会抛出错误。url可以时绝对路径，也可以是相对路径。
//如 当前url是 https://www.baidu.com/a/,执行history.pushState(null, null, './qq/')，则变成 https://www.baidu.com/a/qq/，
//执行history.pushState(null, null, '/qq/')，则变成 https://www.baidu.com/qq/

window.history.replaceState(state,title,url)
//与pushState 基本相同，但她是修改当前历史纪录，而 pushState 是创建新的历史纪录

window.addEventListener("pospstatse",function(){
 //监听浏览器前进后退事件，pushState与replaceState方法不会触发
})
window.history.back()//后退
window.history.forward()//前进
window.history.go(1)//前进一部，-2回退两不，window.history.lengthk可以查看当前历史堆栈中页面的数量
```
**两种模式总结**

- hash模式可以保存的数据量很小

- history模式前端URL和后端发起请求的URL必须一致，否则返回404错误

- history模式刷新页面也会导致发起服务器请求

### 路由选中效果

```vue
<style>
    .myActive{}
</style>   
<div id="app">
       //1. 在vm中，每次点击路由链接以后，会为标签添加两个class
       //class="router-link-exact-active router-link-active"
        <router-link to="/login">登录</router-link>
        <router-link to="/register">注册</router-link>
        <router-view></router-view>
    </div>
    <script>
        var login = {
            template: '<h1>登录组件</h1>'
        }

        var register = {
            template: '<h1>注册组件</h1>'
        }
        var routerObj = newVueRouter({
            routes: [
                { path: '/login', component: login },
                { path: '/register', component: register }
            ],
            //2. 自定义路由激活类名，在css中设置样式
            linkActiveClass:'myActive'
        })
        let vm = new Vue({
            el: "#app",
            data: {},
            methods: {},
            router: routerObj //注意此处是router
        });
    </script>
```

### 路由传参
Vue实现在路由切换的同时传递参数
```vue
---------router-link定义参数范式-----------
 //query传参
<router-link :to="{path:'/register',query:{id:5,name:'lili'}}">注册</router-link>
 //parmas
<router-link :to="{name:'register',params:{id:10,name:'lili'}}">注册</router-link>
```
- parmas(只能使用name，不能使用path)
```js
-------传参-------
this.$router.push({
	name:'routerName',
	parmas:{
		id:id
	}
})
--------接收参数--------
this.$route.parmas.id
```
- query()
```js
-------传参-------
this.$router.push({
	path:'/routerPath',
	query:{
		id:id
	}
})
--------接收参数--------
this.$route.query.id
```
**总结**

1. parmas只能用name,query可以同时使用name和path
2. parmas类似post请求，query类似get请求，parmas在浏览器地址栏不显示参数，所以理论上更加安全
3. 取值方法不同
4. parmas传值在页面刷新后失效，query则不会
5. query方式生成的url为/xx?id=id，params方式生成的url为xx/id

### 路由嵌套

```vue
    <div id="app">

        <router-link to="/account">account</router-link>
        <router-view></router-view>

    </div>
    <template id="tmp1">
        <div>
            <h1>这是account组件</h1>

            <router-link to="/account/login">登录</router-link>
            <router-link to="/account/register">注册</router-link>
            <router-view></router-view>
        </div>
    </template>
    <script>
        //组件的模板对象
        var account = {
            template: '#tmp1'
        }
        var login={
            template:'<h1>登录组件</h1>'
        }
        var register={
            template:'<h1>注册组件</h1>'
        }
        var router = new VueRouter({
            routes: [
                {
                    path: '/account', component: account, children: [
                        { path: 'login', component: login },
                        { path: 'register', component: register }
                        //子路由path不可以加‘/’，不会影响父路由的状态 
                    ]
                }
            ]
        })
        let vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            router
        });
    </script>
```

### 动态路由匹配

假设有一个User组件，对应不同ID的用户都需要这个组件来渲染页面，这时采用vue-router的路由路径中使用**动态路径参数**来实现效果

```js
const User = {
  template: '<div>User</div>'
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})
```

### $router和$route的区别

- $router指向VueRouter实例，里面包含所有的路由对象，它可以通过$router.push({path:' '})实现路由跳转
- $route指的是当前活跃状态的路由，可以通过它获取当前路由的name、path、query、parmars、meta

### 路由懒加载

- 当打包构建应用时，JS包会变得非常的大，从而影响页面加载
- 如果把路由按照不同组件分割成不同的代码块，然后路由被访问时才加载对应组件，这样更加高效

```js
import home from './components/home.vue'
//未使用懒加载的方式
routes: [
    {path:'/home',component:home}
  ]
//1.vue异步组件实现懒加载
routes: [
    {
        path:'/home',
        component:home,
        component: resolve=>(require(["/home"],resolve))
    }
  ]
//2.import实现懒加载(常用)
const HelloWorld = () =>import("/home")
export default new Router({
  routes: [
    {
      path: '/home',
      name: 'home',
      component:home
    }
  ]
})
```

### 子路由

```js
routes: [
    //路由懒加载内部方式
    {path:'/home',component:()=>import('./components/home.vue'),
  children:[
     //注意：子路由的 path路径 一定 不能加 /
    {path:'about',component:()=>import('./components/about.vue')},
    {...}
  ]}
]

//在主页的router-link to上也必须加上子路由完整路径比如：
<router-link to="/home/about">
```

### 响应路由参数变化

例如路由参数从 /a/1 导航到 /a/2 ，原来的组件实例会采取复用方式，也就是不会响应路由地址变化而重新渲染组件【组件的生命周期钩子也不会被调用】

当需要复用路由参数变化作用响应时，需要使用watch监听`$route`对象

```js
--------监听方法---------
watch:{
    '$route'(to,from){
    //to和from对应跳转前后的两个路由对象    
    }
}
```

### meta(元信息)

【可以理解为权限控制】

在路由配置时，给每个路由添加一个自定义的meta对象，在对象中设置一些状态，进行对应的操作【主要用来做登录校验】

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      children: [
        {
          path: 'bar',
          component: Bar,
          meta: { requiresAuth: true }
        }
      ]
    }
  ]
})
--------路由验证-------------
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
```

### 过渡模式

路由切换设置过渡效果时，组件切换出现占位的问题【路由切换的过渡效果是使同一个位置的组件发生变化，此时该销毁的组件没有销毁前，后一个组件已经加载，导致另一个组件的位置排在该销毁组件后面的排版错误问题】

原因：<transition>的默认行为是  进入和离开动画是同时发生的

vue提供了过渡模式【代替translate或者绝对定位】解决这种问题

- in-out：新元素先过渡，完成后旧元素过渡离开
- out-in(常用)：旧元素先过渡，完成后新元素过渡进入

*用法：<transition mode='out-in'></transition>

### 导航守卫

*负责监听路由的切换的钩子函数

#### 全局守卫

1. beforeEach前置钩子(前置守卫)

```js
//路由导航
const routes = [
  {
    path:'/home',
    component:home,
    //路由中的meta属性(元数据：描述数据的数据)可以设置一些状态，用来进行后续操作
    meta:{
      title:'首页'
    }
  },
  {
    path:'/user',
    component:user,
    meta:{
      title:'用户'
    }
  }
]
const router = new VueRouter({
  routes
})
//beforeEach是一个前置钩子函数，即路由跳转时触发的钩子函数
router.beforeEach((to,from,next)=>{
  //从from跳转到to，这里直接通过meta获取路由的title
  document.title = to.meta.title
  //每个导航中必须包含next返回函数，不然无法执行
    next()
})
//注意：导航钩子的三个参数==>
//to：即将要进入的目标的路由对象
//from：当前导航即将要离开的路由对象
//next：调用该方法后，才能进入下一个钩子
```

2. afterEach后置钩子

```js
//后置钩子不需要主动调用next()函数，因为这时已经跳转完的路由，所以不需要next
router.afterEach((to,from)=>{})
```

#### 路由独享守卫

```js
//直接在路由内部定义的钩子函数
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
        //进入路由之前回调的函数,也必须调用next()
      beforeEnter: (to, from, next) => {
        next()
      }
    }
  ]
})
```

#### 组件内的守卫

```js
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

### keep-alive

路由的跳转就是**不同组件的创建和销毁的过程**，频繁的跳转使组件也频繁创建和销毁，为了避免这一过程频繁执行，使用keep-alive缓存组件

*keep-alive是Vue提供的一个内置抽象组件，用来对组件进行缓存，可以使被包含的组件保留状态，或避免被重新渲染,同时提高性能，它不参与DOM中渲染

*router-view也是一个组件，如果被直接包在keep-alive中，所有路径匹配到的视图组件都会被缓存

*正常情况下路由的切换就是vue生命周期中的created和destroyed的过程，创建keep-alive标签避免频繁的创建和销毁，同时还可以保留路由中的缓存

*要想保存Vue的滚动行为，必须用HTML5的history模式

```vue
<keep-alive include="ComponentName1" exclude="ComponentName2">
//keep-alive包含两个属性，include和exclude，包含和不包含。在例子里表示name属性为ComponentName1的组件会被缓存，ComponentName2不会被缓存
```
**keep-alive生命周期**

- 初次进入：created => mounted => activated,退出后触发deactivated
- 再次进入：触发activated，里面保存了每次进入都需要执行的方法

```vue
<keep-alive>
	<router-view/>
</keep-alive>

//当组件被keep-alive包裹后可以调用两个钩子函数
activated(){},  //当组件激活时
deactivated(){}	//当组件未激活时
```

**多个缓存页面跳转**

*结合meta和keep-alive

```js
 routes: [
    {
      path: '/',
      name: 'Hello',
      component: Hello,
      meta: {
          //将keepAlive放在meta里，后续使用路由守卫
        keepAlive: true
      }
    }
```

用路由守卫判断和设置meta信息

```js
export default {
    data() {
        return {};
    },
    methods: {},
    beforeRouteLeave(to, from, next) {
         // 设置下一个路由的 meta
        to.meta.keepAlive = true;  
        next();
    }
};
```



### 命名视图实现经典布局(多视图)

*一个head一个侧边导航栏一个内容页

```vue
<style>
    *{
        margin: 0;
        padding: 0;     
    }
    
    .header {
        background: orange;
        height: 80px;
    }
    h1{
        margin: 0;
    }
    .container{
        //使用弹性布局
        display: flex;
        height: 400px;
    }
    .left{
        background: lightgreen;
        //整个页面默认为10
        flex:2;    
    }
    .main{
        background: lightpink;
        flex:8;
    }
</style>

<body>
    <div id="app">
        <router-view></router-view>
        <div class='container'>
            //此处即是命名视图，方便为多个视图设置样式
            <router-view name="left"></router-view>
            <router-view name="main"></router-view>
        </div>
    </div>
    <script>
        var header = {
            template: '<h1 class="header">Header头部区域</h1>'
        }
        var leftbox = {
            template: '<h1 class="left">left侧边栏区域</h1>'
        }
        var mainbox = {
            template: '<h1 class="main">mainbox主体区域</h1>'
        }
        //创建路由对象
        var router = new VueRouter({
            routes: [
                {
                    //多路由设置方式
                    path: '/', components: {
                        default: header,
                        left: leftbox,
                        main: mainbox
                    }
                }
            ]
        });
        let vm = new Vue({
            el: '#app',
            data: {},
            methods: {},
            router
        });
    </script>
```



## watch(监听)

*watch的作用可以监控一个值的变换，并调用因为变化需要执行的方法，watch不需要return

```vue
<script>
data:{
     a:1,
     b:{
         c:1
     }
 },
 watch:{
     a(val, oldVal){//普通的watch监听
         console.log("a: "+val, oldVal);
     },
     b:{//深度监听，可监听到对象、数组的变化
         handler(val, oldVal){
             console.log("b.c: "+val.c, oldVal.c);//但是这两个值打印出来却都是一样的
         },
             //开启深度监听
         deep:true
     }
 }
```

*watch的优势在于不需要对应的事件触发即可以随意监听任意对象的改变

## computed(计算属性)

*计算属性一般就是用来通过其他的数据算出一个新数据，而且它有一个好处就是它把新的数据缓存下来了，当其他的数据没有发生改变，它调用的是缓存的数据，这就极大的提高了我们程序的性能 

```vue
//基本应用场景:计算书本价格总值
 <div id="app">
     	<!-- 通过自定义名字方法调用计算属性 -->
        <h2>总价格：{{totalPrice}}</h2>
    </div>
    <script src="./vuepack/vue.js"></script>
    <script>
        let vm = new Vue({
            el:'#app',
            data:{
                books:[
                    {id:1,name:'a',price:20},
                    {id:2,name:'b',price:21},
                    {id:3,name:'c',price:22},
                    {id:4,name:'d',price:23},
                    {id:5,name:'e',price:24}
                ]
            },
            methods:{},
            computed:{
                //在计算属性中定义计算方法的自定义函数
                totalPrice:function(){
                    let result = 0;
                    for(let i=0;i<this.books.length;i++){
                        result += this.books[i].price
                    }
                    return result
                }
            }
        })
```

**计算属性中的setter和getter**

```js
//计算属性的完整写法
computed:{
	set:function(newValue){
	//set方法有一个newValue参数，set用来改变值，发生改变的时候，同时让数据的内容也发生改变
	},
	get:function(){
	//计算属性默认只有get属性，只读属性，即计算属性本身的用法，通过获值计算然后返回计算值
	}
}
```

**watch/computed对比**

1. computed属性的结果会被缓存，支持缓存除非依赖的响应式属性变化才会重新计算，重新访问会直接返回值，性能非常高，但是不支持异步【多对一】
3. watch是监听属性发生改变的动作，不支持缓存，支持异步【一对多】

## 事件总线(Event Bus)

*处理两个页面毫无关系的组件提供通讯，在不需要Vuex的情况下使用的代替方案

*EventBus又称为事件总线，在Vue中可以使用EventBus来作为沟通桥梁的概念，就像是所有的组件共用相同的事件中心，可以向该中心注册发送事件或接受事件，所以组件都可以上下平行的通知其他组件，但是很可能会造成维护困难

**使用EventBus**

1. 初始化
创建事件总线并导出，以便其他模块可以使用或者监听
```js
//-----两种创建EventBus的方式-----
// 1. 创建event-bus.js文件
import Vue from 'vue'
export const EventBus = new Vue()
//2. 在main.js中初始化EventBus
Vue.prototype.$EventBus = new Vue()
*这种方式创建的是一个全局的事件总线
```
2. 发送事件
模板：EventBus.$emit(channel:string, callback(payload1, ...))
假设两个Vue页面(A,B)需要通信，A页面在按钮上绑定了点击事件，发送一则消息，通知B页面
```vue
<!-- A.vue -->
<template>
    <button @click="sendMsg()">-</button>
</template>

<script> 
import { EventBus } from "../event-bus.js";
export default {
  methods: {
    sendMsg() {
      EventBus.$emit("aMsg", '来自A页面的消息');
    }
  }
}; 
</script>
```
3. 接收事件
B组件接受A组件发送的消息
模板：EventBus.$on(channel:string, callback(payload1, ...))
```vue
<!-- B.vue -->
<template>
  <p>{{msg}}</p>
</template>

<script> 
import { EventBus } from "../event-bus.js";
export default {
  data(){
    return {
      msg: ''
    }
  },
  mounted() {
    EventBus.$on("aMsg", (msg) => {
      // A发送来的消息
      this.msg = msg;
    });
  }
};
</script>
```
4. 移除事件监听
注意使用EventBus，在有业务反复操作的页面，EventBus在监听的时候就会触发很多次，容易产生问题 / 页面刷新以后，与之相关的EventBus也会被移除，可能导致业务无法进行下去
*所以在vue页面销毁的同时，需要同时移除EventBus事件监听
模板：EventBus.$off()
```js
//移除A组件的EventBus监听
import { EventBus } from '../event-bus.js'
EventBus.$off('aMsg', {})
//----移除所有事件频道-----
EventBus.$off()  //不添加参数等于全局移除
```
5. 全局EventBus
*工作原理是发布 / 订阅 方法，通常称为 Pub / Sub
```js
<!--创建全局EventBus-->
var EventBus = new Vue()

Object.defineProperties(Vue.prototype, {
	$bus: {
		get: function () {
			return EventBus
		}
	}
})
```
*在这个特定的总线中使用两个方法$on和$emit，$emit用于创建用于发布的事件；$on用于订阅事件
```js
//使用发布订阅的模板
var EventBus = new Vue()

this.$bus.$emit('nameOfEvent', { ...pass some event data ... })

this.$bus.$on('nameOfEvent', ($event) => {
	//...
})

//------------实际情况----------------
<!--在一个页面发布-->
this.$bus.$emit('sendMsg', '发布消息')
<!--在一个页面订阅-->
this.$bus.$on('getMsg', function(value){
	console.log(value) //发布消息
})
```


## Vuex

安装：npm i vuex --save

*一个专为Vue.js应用程序开发的**状态管理模式**

*什么是状态管理：需要多个组件共享的变量(存储状态)全部储存在一个对象中，这个公共对象就相当于一个管家，储存着所有组件需要共享的变量，方便组件随时调用，而且，这也是响应式的(内部集成监听)

```js
//----单向数据流----
new Vue({
	//state
	data(){
		return{
			count: 0
		}
	},
	//view
	template:`
		<div>{{count}}</div>
	`,
	//actions
	methods:{
		increment(){
			this.count++
		}
	}
})
//--------------------
- state:驱动应用的数据源
- view:以声明方式将state映射到视图
- actions:响应在view上的用户输入导致的状态变化
//------单向数据流------
view > actions > state > (回到)view
*数据触发视图的更改 到 用户看到视图 到 事件触发修改数据 到 数据再触发回视图更改
*但是当应用遇到多个组件共享状态时，单向数据流的简洁性会被破坏
//以下情况
1.多个视图依赖于同一状态
2.来自不同视图的行为需要变更同一状态
*此时需要使用vuex处理复杂的全局变量
```

*什么情况下需要管理状态：

- 比如用户登录状态、用户名称、头像、地理位置信息
- 比如商品、购物车中的物品等等
- 比如商品的收藏、购物车中的物品等等

### Vuex核心概念

- State 保存共享状态(变量)
- Getters 类似于计算属性
- Mutation 改变属性
- Action 异步操作
- Module 划分模块，不同模块的数据保存

1. state 变量仓库属性

```js
//在vuex里state中定义的共享变量，在别的组件中若想使用
//例如在state中定义counter：100
//在组件中需要使用$store.state.counter语法可以调用counter的值
```

*state单一状态树：也称之为单一数据源，所有数据都存储在一个store中，方便管理和调用

```vue
//实际组件中 需要调用多个state中的属性，此时$store.state.X的方式需要逐条添加，此时采用computed计算属性更加直观
//---常规添加方式----
<template>
 	<div>
    //较为不美观
    	名字：{{$store.state.name}}
		年纪：{{$store.state.age}}
		身高：{{$store.state.high}}
    </div>
</template>

//----计算属性添加方式-----
<template>
 	<div>
    //简化这部分代码
    	名字：{{name}}
		年纪：{{age}}
		身高：{{high}}
    </div>
</template>
<script>
export defalut {
    computed: {
        //使用计算属性获取state中的数据
        name:function(){
            return this.$store.state.name
        },
         age:function(){
            return this.$store.state.age
        },
         high:function(){
            return this.$store.state.high
        }
    }
}
</script>
```

**mapState 辅助函数**

当一个组件需要获取多个state状态的时候，将这些状态都声明为计算属性会重复且冗余，mapState可以辅助生成计算属性

```vue
// 1.组件内导入mapState
import { mapState } from 'vuex'

// 2.设置mapState的两种方式
//---不使用mapState的方法----
<template>
	<div>
    	<h1>{{num}}</h1>
		//v-model对应get和set方法
		<input type='text' v-model='num'>
    </div>
</template>
<script>
computed:{
    num:{
        get:function(){
            return this.$store.state.num
        },
        set:function(val){
            //通过mutation中的setNum方法修改state.num的值
            this.$store.commit('setNum',val)
        }
    }
}
</script>
//---第一种使用mapState的方法---
<template>
	<div>
    	<h1>{{num}}</h1>
		<input type='text' :value='num' @input='changeValue'>
    </div>
</template>
<script>
computed:{ ...mapState(['num'], ...) },
methods:{
    //因为没有set方法，所以需要添加修改事件
    changeValue:function(e){
        this.$store.commit('setNum',e.target.value)
    }
}
//---第二种使用mapState的方法---
computed:mapState({
   num:(state)=>state.num  // function(state){return this.$state.num}    
})
```

2. Mutations 改变属性

*注意：store中的state中的数据最好通过提交mutations修改，mutations中的方法相当于事件，组件内通过this.$store.commit方法来提交

```vue
<script>
//mutations负责改变state中的变量的参数
//1.在mutations中添加方法
mutations: {
    //方法默认传入state参数
    increment(state){
      state.counter++
    },
    decrement(state){
      state.counter--
    }
</script>
 //2.在组件template中添加方法
  <button @click="add">+</button>
  <button @click="sub">-</button>
<script>
 //3.组件内方法提交给store
  methods: {
    add(){
        //通过commit触发mutations里的方法
      this.$store.commit('increment')
    },
    sub(){
      this.$store.commit('decrement')
    }
  }
    
//通过mutation更新数据时，我们会携带一些额外的参数，放在state参数后面，这种参数被称之为mutation的载荷(Payload)
   addCount(count){
       //这里的count就是载荷
       this.$store.commit('incrementCount',count)
   }
    //如果不止一个参数，那可以以对象的形式传递，此时payload是一个对象
```

Mutations主要包括两个部分：

- 字符串的事件类型(type)
- 一个回调函数(handler)，该回调函数的第一个参数就是state

```js
mutations:{
	increment(state){
		state.counter++
	}
}
//其中increment就是表示事件类型的字符串
//除去字符串的剩下的部分都是回调函数
```

Mutations提交风格

- 通过commit的普通提交方式
- 通过包含type属性的对象方式提交

```js
//普通提交风格
this.$store.commit('')
//对象方式提交，这种情况返回的是一个对象
this.$store.commit({
	type:'increment',
	//别的参数
    count:count
})
//对象提交的提取方法
mutations:{
increment(state,payload){
    //这里定义为payload【载荷】比较便于理解，载荷就是这个方法中需要使用的具体数值【比如说点一次自增10，则载荷就是10】
    state.count += payload
 }
}
```

Mutation常量类型

*当mutation中定义了过多的事件类型，意味着mutation中的方法越来越多，需要花费大量时间记忆，容易出现写错的情况

Mutation同步函数

*通常情况下，Vuex要求我们Mutation中的方法必须是同步的，这是为了devtools可以跟踪vuex

3. Getters【派生属性】(类似于计算属性)

```js
//基本使用：比如想输出counter的平方
getters: {
    powerCounter(state){
      return state.counter*state.counter
    },
    powerCounterLength(state,getters){
        return getters.powerCounter.length
        //这里getters属性就是整个getters属性，传入getters属性，就可以直接访问这个gettes属性中的方法，这里以获取powerCounter的长度为例
    }
  }
//外部直接使用$store.getters.powerCounter使用

//注意：getters中只能包含state和getters两个形参，其他参数需要在getters中返回函数
//这里可以直接传实参，因为此时getters返回的是一个函数
{{$store.getters.moreAgeStu(8)}}
moreAgeStu(state){
    //这里getters返回的是一个函数，所以可以返回带参函数
    return function(age){
        return state.students.filter(s => s.age > age)
    }
}
```

4. action

Action类似于mutation，它是通过提交mutation间接更新state，vue推荐使用action触发mutation而不是直接操作mutation

- 由于Mutations中使用异步操作会导致devtools无法正常追踪工作
  - 但是某些情况，我们希望Vuex中进行一些异步操作，比如网络请求
  - Action类似于Mutations，但是是用来代替Mutations进行异步操作的

```js
actions:{
	//context是actions的默认属性，翻译为上下文,通过context可以提交mutations
	aUpdateInfo(context){
		setTimeout(()=>{
            // 1.因为context相当于mutations，所以可以拿到commit
			context.commit('mutation中的方法')
            //这样就可以同步或者异步操作mutations中的方法
		},1000)
	}
    
    // 2.或者【按需传入】直接传commit和state 则不需要传入context
    derement({commit,state}){
        commit('derement') //commit 触发 mutations中的方法
    }
}
//  在组件中触发 action 的方法
updateInfo(){
    this.$store.dispatch('aUpdateInfo',payload) //actions也可以定义【载荷】，即具体数值
    //引入的名字得是actions中的名字
}
//actions中也可以传递payload
```

5. modules【拆分模块】

*创建一个新的store模块，减少了单一状态树state中的臃肿问题，也更模块化

```js
modules:{
	//假设定义a，b模块
	a:{
		state:{},
		mutations:{},
		actions:{},
		getters:{}
	},
	b:{}
}
//或者写在store外
const moduleA={},
const store = new Vuex.store({
    modules:{
        a:moduleA
    }
})

//项目中调用模块的方法
$store.state.a.a中的属性
//模块中mutation或者getters定义的方法名不要和store中的属性名重复，因为Vuex会先在store中寻找，找不到的时候才会进入module中找对应的方法
```

*模块中如果想调用store中的state内容需要传入rootState这个参数

*module中也可以设置active属性，在active中设置方法需要传入context参数，以  context.commit  的方式

### Vuex项目结构

*当我们的Vuex帮助我们管理过多的内容时，好的项目结构可以让我们的代码更加清晰

Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：

1. 应用层级的状态应该集中到**单个 store** 对象中。
2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。
3. 异步逻辑都应该封装到 **action** 里面。

只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 、module和 getter 分割到单独的文件

==>通过export default/import from的方式将单独的vuex.module文件导入到index.js中

```
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    
    //或者使用module的方式拆分模块
    └── modules  #将模块单独建立一个文件夹，所有模块存在这个文件夹里
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```

**Vuex独立模块JS文件结构**

```js
// 假设模块名字叫module.js
const state = {}
const mutations = {}
const actions = {}
const getters = {}

//以抽取变量的方式导出
//或者定义一个对象直接导出对象
export default {
	state,
	mutations,
	actions,
	getters
}

// 在store中index.js引入
import module from ''
export default new Vuex.Store({
    modules:{
        module //增强写法,导出模块
    }
})
```

### Vuex响应式原理

*Dep ->[Watcher] 

每个响应式数据对象对应一个Dep(观察者模式)，它包含一个数组，数组中存放多个Watcher，每个Watcher对应一个需要更新 该响应数据 的点

**响应式规则**

- Vuex中的store中的state是响应式的，当state中的数据发生改变时，Vue组件会自动更新
- 这就要求我们必须遵守一些Vuex对应的规则：
  - 提前在store中初始化好所需的属性
  - 当给state中的对象添加新属性时，使用两种方式：
    - 使用Vue.set(obj,'newProp',123)
    - 用新对象给旧对象重新赋值

**Vuex对比localStorage及sessionStorage**

- sessionStorage对一个session进行数据存储，当用户关闭浏览器窗口后，数据会被删除
- localStorage存储数据永久可用
-  Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 

总结： vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；sessionstorage( 会话存储 ) ,临时保存。 localstorage是本地存储，是将数据存到浏览器的方法，一般是在跨页面传递数据时使用 

Vuex优势：如果不同组件需要公用一个数据源，为了避免频繁的设置组件之间传值，而且业务需求该数据源在一个组件中修改时，其他组件也可以响应式改变，此时只能使用Vuex

## 自动化测试

单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证【一个单元可能是**单个程序、类、对象、方法**等】

**单元测试的意义：**减少bug、提高代码质量、快速定位bug、减少调试时间、放心重构

**使用Karma+Mocha做单元测试**

- Karma是测试运行器，可以通过浏览器加载测试脚本
- Mocha是单元测试框架/库，可以用来写测试用例
- Sinon是spy / stub / mock 库，用来辅助测试

安装依赖：

```js
npm i -D karma karma-chrome-launcher karma-mocha karma-sinon-chai mocha chai sinon sinon-chai karma-chai karma-chai-spies
```

**使用jest测试整合框架**

```js
1.添加jest组件
npm i --save-dev vue-jest
2.配置babel
npm i --save-dev babel-jest
3.安装vue test utils和jest
npm i --save jest @vue/test-utils
npm install --save-dev jest-serializer-vue
```

添加webpack运行脚本

```js
"test":"jest -clearCache --coverage"
```



# Webpack

## webpack原理
webpack分为五大核心
- Entry： 入口，webpack构建第一步从entry开始 
- module： 模块，在webpack中一个模块对应一个文件。webpack会从entry开始，递归找出所有依赖的模块 
- Chunk： 代码块，一个chunk由多个模块组合而成，用于代码合并与分割 
- Loader： 模块转换器，用于将模块的原内容按照需求转换成新内容 
- Plugin： 拓展插件，在webpack构建流程中的特定时机会广播对应的事件，插件可以监听这些事件的发生，在特定的时机做对应的事情 

各个阶段执行的操作如下：

1. 初始化参数：从配置文件(默认webpack.config.js)和shell语句中读取与合并参数，得出最终的参数
2. 开始编译(compile)：用上一步得到的参数初始化Comiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译
3. 确定入口：根据配置中的entry找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译,再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过处理
5. 完成编译模块：经过第四步之后，得到了每个模块被翻译之后的最终内容以及他们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将每个chunk转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置(webpack.config.js && shell)确定输出的路径和文件名，将文件的内容写入文件系统中(fs)

**webpack打包模块的源码  执行顺序**

1. 把所有模块的代码放入函数中，用一个数组保存起来
2. 根据require时传入的数组索引所需要的代码
3. 从数组中，根据索引去除包含我们代码的函数
4. 执行该函数，传入一个对象module.exports
5. 我们的代码，按照规定，正好用module.exports=‘xxxx’进行赋值
6. 调用函数结束后，module.exports从空对象，变为有值对象
7. 最终reutrn module.exports，作为require函数的返回值

**nrm镜像地址**

*(npm registry manager)是npm的镜像管理工具使用nrm可以实现快速在npm源间切换

```c#
//cmd
npm i nrm -g
```

切换源的方法：nrm use + 源名称

```c
//切换完成后，如果要使用该源需要
npm i + 源名称 -g
```

**网页中常见的静态资源**

- JS
  - .js  .jsx   .coffee  .ts(TypeScript)
- CSS
  - .css   .less   .scss(.sass更新后)
- 图片文件
  - .jpg  .png  .gif  .bmp  .svg
- 字体文件
  -  .svg  .ttf   .eot  .woff   .woff2
- 模板文件
  -  .ejs  .jade   .vue[webpack中定义组件的方式]

*网页中静态资源过多会导致网页加载速度变慢，这是由于我们需要发起很多二次请求，要处理错综复杂的包和包之间的依赖关系

*解决静态资源多的问题：

1. 图片上优化 ：合并 / 压缩 / 精灵图 / 图片Base64编码
2. 使用webpack解决各个包之间复杂的依赖关系

**什么是webpack？**

webpack是前端的一个项目构建工具，它是基于Node.js开发出来的前端工具

 *借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆，处理依赖关系等诸多功能

**webpack功能**

1. webpack能够处理JS文件的互相依赖关系，不同框架下的不同语法最后都可以编译打包进入bundle.js
2. webpack可以处理JS的兼容问题，把高级的语法转化为浏览器支持的语法

## 模块化构建流程

1. 创建一个workspace

2. 在workspace中创建dist(存放可以用于生产环境的成品)和src(源代码)两个文件

3. 对workspace使用npm init -y创建包管理工具，再用npm安装所需包[-D用于开发环境/-S用于生产环境/-g全局安装]

4. 在src文件中创建index.html/main.js，所有的安装包都在main.js中引入，使用`import ** from '****'`这是ES6中导入模块的方式

   ```js
   //例如
   import $ from 'jquery'
   ```

5. 完成html和js的编写以后，运行该命令(否则浏览器无法识别)

   ```js
   //npm
   webpack .\src\main.js -o .\dist\bundle.js
   //第一个路径是需要打包的js文件  第二个文件是输出的地址和名字
   ```

6. 注意：为了简化一次次繁琐定义路径的打包这里设置一个默认路径文件在项目根目录

   ```js
   //创建webpack.config.js ---这个配置文件，起始就是一个JS文件，通过Node中的模块操作，向外暴露了一个配置对象
   const path=require('path') //引入path工具
   //向外暴露配置对象,配置webpack打包入口和出口
   module.exports={
       mode:'development', //输出的模式
       //__dirname是node的一个全局变量，即获得当前文件所在目录的完整目录名
       entry: path.join(__dirname,'./src/main.js'), //需要打包编译的JS文件
       output:{  //输出文件相关配置
           path:path.join(__dirname,'./dist'),
           filename:'bundle.js'  //指定输出的文件名称
       }
   }
   ```

**热部署**

*由于webpack每次都需要重复打包，可以使用`webpack-dev-server`工具实现自动打包

(npm i webpack-dev-server -D)本地安装

- 由于webpack-dev-server是在本地安装，所以无法把它当作脚本命令，在powershell终端中直接运行；(只有安装全局-g的工具才可以在终端中正常运行)
- 所以设置在全局环境中，打开根目录package.json,在script目录下添加一个`"dev": "webpack-dev-server"`
- 在终端中使用npm run dev命令(注意：需要同时安装webpack和cli到本地)
- 运行以后，dev会提供一个localhost链接，在链接中打开src(但是如果在全局package.json中将dev改为webpack-dev-server--open则不需要手动打开)
- **注意**：webpack-dev-server帮我们生成的bundle.js并没有放到dist文件中，而是托管到了电脑内存中，所以此时根目录上有个不可视的虚拟的bundle.js，此时它和dist/src/node_modules平级，如果要实时显示编译内容，需要将index.html中的script调整为`script:src="/bundle.js"`

```
"dev": "webpack-dev-server --open --hot --port +端口号" //hot可以实现少量更新，不必重新加载整个页面  //port 端口号则可以实现自定义端口号
```

或者换一种方式：

*配置devServer属性，在webpack.config.fs中更改

```js
const path=require('path')
//启动热更新的第二步，引入webpack组件
const webpack=require('webpack')
module.exports={
    mode:'development',
    entry:path.join(__dirname,'./src/main.js'),
    output:{
        path:path.join(__dirname,'./dist'),
        filename:'bundle.js'  //指定输出的文件名称
    },
    devServer:{//第二种配置dev-server命令参数的形式
        open:true, //自动打开浏览器
        port:3000, //设置启动时候运行的端口
        contentBase:'src',//指定托管的根目录
        hot:true //启用热更新的第一步
    },
    plugins:[ //配置插件的节点
        new webpack.HotModuleReplacementPlugin() //new一个热更新的模块对象，启用热跟新的第三步
    ]
}
```

### loader(第三方调用)

*webpack无法直接处理一些文件格式，需要调用第三方支持

**处理CSS样式表的第三方**

*由于使用link标签相当于是二次请求，所以采用第三方

*npm i css-loader style-loader -D

```js
//在main.js文件中引入css文件
import './css/index.css'
// 非js模块直接导入不需要from，webpack默认只能处理JS文件，无法处理非JS类型文件
//如果要处理非JS类型文件，需要手动安装合适的第三方loader加载器
//1.如果想要打包处理CSS文件，需要安装两个模块
//npm i style-loader css-loader -D
//2.打开webpack.config.js这个配置文件，在里面新增一个配置节点，叫做module，它是一个对象，
//在这个module对象上，有一个rules属性是一个数组，数组中存放了所有第三方文件的匹配和处理规则

//在webpack.config.js文件中加载对应模块
plugins:[ //配置插件的节点
        new webpack.HotModuleReplacementPlugin() //new一个热更新的模块对象，启用热跟新的第三步
    ],
    //放在plugins后面
module:{ //这个节点用于配置所有第三方模块 加载器
      rules:[  //所有第三方模块的匹配规则
         {test:/\.css$/,use:['style-loader','css-loader']},
            //使用test正则匹配对应文件格式，在用use加载相应的匹配规则模块
          //注意：loader的调用规则是从右到左
        ]
    }
```

*注意：webpack对于所有import的无法识别的文件格式，都会进入module文件中寻找对应的匹配的第三方规则

*注意：webpack处理第三方文件类型的过程：

1. 发现这个 要处理的文件不是JS文件，然后去 配置文件中查找对应的第三方loader规则
2. 如果能找到对应的规则，就会调用 对应的loader 处理 这种文件
3. 在调用loader的时候，就是从后往前调用的
4. 当最后的一个loader调用完毕，会把处理的结果 直接交给 webpack 进行打包合并，最终输出到bundle.js这个文件中去

**处理less的第三方**

*npm i less-loader less -D

```js
module: { //这个节点用于配置所有第三方模块 加载器
        rules: [  //所有第三方模块的匹配规则
            { test: /\.css$/, use: ['style-loader', 'css-loader'] },
            //使用test正则匹配对应文件格式，在用use加载相应的匹配规则模块
            { test: /\.less$/, use: ['style-loader', 'css-loader','less-loader'] },
        ]
    //less文件需要同时加载style和css模块才能使用
```

**处理图片文件**

```js
npm i url-loader file-loader -D
//在webpack.config.js中配置匹配规则
{test:/\.(jpg|png|gif|bmp|jpeg)$/,use:'url-loader'}
//use:'url-loader?limit=规定上传图片大小字节(单位是byte)',这样传参当规定字节大于图片字节时，上传路径就是hash值(本地路径)，当规定字节小于图片字节时，则会以Base64编码形式上传
//use:'url-loader?limit=xxx&name=[name].[ext]则是可以显示图片的本地的路径
//use:'url-loader?limit=xxx&name=[hash:8]-[name].[ext]则可以给名字前面加上随机hash值，目的是防止图片重名hash最多可以定义32位
```

*会将路径转化为Base64编码，防止使用二次请求

**处理文字文件**

```js
{test:/\.(ttf|eot|svg|woff|woff2)$/,use:'url-loader'}
```

**html-webpack-plugin**

*plugin的作用和loader基本相同，扩展webpack自身的功能

**HtmlWebpackPlugin具有两个作用**

1. 为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题
2. 可以生成创建html入口文件

```js
//----HtmlWebpackPlugin配置项------
const HtmlWebpackPlugin = require('html-webpack-plugin')
plugins:[
    new HtmlWebpackPlugin({
    title:'',
    minify:{
        //是否对大小写敏感，默认false
        caseSensitive: true,
        //是否简写boolean格式的属性如：disabled="disabled" 简写为disabled 默认false
        collapseBooleanAttributes: true,
        //是否去除空格，默认false
        collapseWhitespace: true,
        //是否压缩html里的css（使用clean-css进行的压缩） 默认值false；
        minifyCSS: true,
        //是否压缩html里的js（使用uglify-js进行的压缩）
        minifyJS: true,
        //Prevents the escaping of the values of attributes
        preventAttributesEscaping: true,
        //是否移除属性的引号 默认false
        removeAttributeQuotes: true,
        //是否移除注释 默认false
        removeComments: true,
        //从脚本和样式删除的注释 默认false
        removeCommentsFromCDATA: true,
        //是否删除空属性，默认false
        removeEmptyAttributes: true,
        // 若开启此项，生成的html中没有 body 和 head，html也未闭合
        removeOptionalTags: false,
        //删除多余的属性
        removeRedundantAttributes: true,
        //删除script的类型属性，在h5下面script的type默认值：text/javascript 默认值false
        removeScriptTypeAttributes: true,
        //删除style的类型属性， type="text/css" 同上
        removeStyleLinkTypeAttributes: true,
        //使用短的文档类型，默认false
        useShortDoctype: true,
    },
    //输出html文件名
    filename:'',
    //html的模板文件
    template:``,
    //给生成html文件添加网页图标，添加图标路径
    favicon:'',
    //给js文件生成一个独特的hash值，默认false
    hash:true 
    })
]
```

**SplitChunksPlugin**

*原CommonsChunksPlugin，4.0以后更改为SplitChunksPlugin

*此插件的作用是抽取module中的公共模块chunk，避免相同文件重复打包

```js
//----------默认配置------------
splitChunks: {
    //可选async(异步),initial(初始),all(所有)针对不同chunk
    chunks: "async",
    //分割完的chunk最小尺寸
    minSize: 30000,
    //共享该module的最小chunk数
    minChunks: 1,
    //最多有5个异步加载请求
    maxAsyncRequests: 5,
    //初始化的时候最多3个请求
    maxInitialRequests: 3,
    //名字中间的分隔符
    automaticNameDelimiter: '~',
    //true：chunk的名字自动生成
    name: true,
    //每切割一个新chunk就是一个cacheGroup 	   
    cacheGroups: {
        vendors: {
            test: /[\\/]node_modules[\\/]/,
            //chunk的优先级
            priority: -10
        },
        default: {
            minChunks: 2,
            priority: -20,
            //当module未改变时，使用之前打包的chunk
            reuseExistingChunk: true
        }
    }
}
```



### Webpack中babel配置

*babel是一个javascript编译器

```js
//class关键字，是ES6中提供的新语法，用来  实现 ES6 中面向对象编程的方式
//Person.info 所谓的静态属性，就是 可以直接通过  类名， 直接访问的属性
//var p1=new Person() ==> p1.name 实例属性：只能通过类的实例来访问的属性，叫做实例属性
class Person {
    static info = {name: 'zs', age: 20}
}
```

***注意**：在webpack中，默认只能处理一部分 ES6 新语法，一些更高级的语法无法处理，这时需要借助 第三方loader 来帮助webpack 处理这些高级的语法， 在将高级语法转化为低级语法后，再把结果交给webpack去打包进 bundle.js中

*通过babel，可以帮我们将高级语法转化为低级语法  // 在webpack中可以运行loader来完成babel相关功能

1. 安装babel loader

```js
//负责转换语法部分
npm i --save-dev babel-loader @babel/core
npm i @babel/plugin-transform-runtime -D
//语法插件，负责判断语法的版本 
npm i @babel/preset-env --save-dev
npm i @babel/plugin-proposal-class-properties -D
npm i @babel/runtime -D
```

2. 打开webpack的配置文件，在 module节点 下的 rules数组 中，添加一个新的 匹配规则：

```js
{ test:/\.js$/ , exclude:/node_modules/ , loader:'babel-loader' }
//注意  转化需要排除node_modules中的三方包，防止误转化
```

3. 在项目的 根目录当中，新建一个叫  .babelrc 的babel配置文件，这个配置文件，属于JSON格式 ， 所以 在写  .babelrc 配置时 必须符合JSON语法：不能写注释 // 字符串必须用双引号

```js
//babel配置：
{
	"presets":["@babel/preset-env"],   //预设语法
	"plugins": [
        "@babel/plugin-transform-runtime"
        "@babel/plugin-proposal-class-properties"
     ]
}
```



## Webpack自动化开发搭建

**node相关知识：**

`__dirname`：获取当前文件所在路径，等同于path.dirname(__filename)

```js
console.log(__dirname);
// Prints: /Users/mjr
console.log(path.dirname(__filename));
// Prints: /Users/mjr
```

path.resolve([..paths]):把一个路径或者路径片段的序列解析为一个绝对路径

- 给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径
- 如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上
- 生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录
- 长度为零的 path 片段会被忽略
- 如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径

```js
path.resolve('/foo/bar', './baz');
// 返回: '/foo/bar/baz'

path.resolve('/foo/bar', '/tmp/file/');
// 返回: '/tmp/file'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');
// 如果当前工作目录为 /home/myself/node，
// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif'
```

### **构建类Vue自动化项目**

项目目录生成如下文件：

```
.
├── build
│   ├── build.js
│   ├── index.html
│   ├── utils.js    (★入口配置，生成文件配置，vm生成都靠这个文件)
├── dist (用来存放经过 Webpack 处理过的 src文件夹数据)	
├── src
│   ├── App.vue
│   └── main.js
│   └── index.html  (只有最基础的 html 代码，它唯一的目的就是加载打包后的 js 文件 bundle.js)
├── webpack.config.js 
├── postcss.config.js
├── package.json
├── package-lock.json
├── README.md
└── .gitignore
```

**1.全局安装必要包**

```js
npm init -y
npm i webpack webpack-cli -D
```

**2.创建打包配置文件**

在 项目根目录 下新建一个名为 webpack.config.js 的文件，并在其中进行最简单的配置，包含入口文件路径和存放打包后文件的地方路径

```js
// webpack.config.js
const path = require('path')

module.exports = {
    entry: __dirname + './src/main.js', // 入口文件路径
    output: {
        path: __dirname + './dist', // 存放打包后文件的路径
        filename: 'bundle.js'   // 打包后文件名
    }
};
//注：__dirname 是 node.js 中的一个全局变量，它指向当前 js 文件所在的目录.
```
**3.安装必要loader**

```js
//图片打包
npm i url-loader file-loader -S
//安装file-loader ：
//生成的文件的文件名就是文件内容的
//MD5哈希值并会保留所引用资源的原始扩展名

//babel转换JS
npm i babel-loader@8.0.0-beta.0 @babel/core @babel/preset -env webpack
//转换ES6为ES5
npm i @babel/plugin-transform-runtime -D
npm i @babel/runtime -D
```

- babel-loader @babel/core 可以支持es6语法
- @babel/preset-env 是根据浏览器或者运行环境来将es6转化成es5，比如根据browserslist
- 补充说明1：@babel/polyfill 是对es6降级es5的一个垫片，是对babel-loader的补充，但是会污染全局，不能按需引入，不建议这种方式
- 补充说明2：@babel/runtime @babel/plugin-transform-runtime也是对es6降级es5的一个垫片，可以按需引入，模块化加载，不污染全局，推荐使用
- file-loader 或者 url-loader可以支持引入文件
- file-loader不支持小文件转化为base64格式，但是可以为文件名添加hash值，url-loader可以支持小文件转化为base64格式，这两个可以搭配使用

```js
//打包CSS样式和安装预处理器loader
npm i style-loader css-loader -D
//sass
npm i sass-loader node-sass -D
//less
npm i less-loader less -D
```

**在webpack.config.js中配置loader依赖关系**

```json
const path = require('path')

module.exports = {
    entry: __dirname + './src/main.js', // 入口文件路径
    output: {
        path: __dirname + './dist', // 存放打包后文件的路径
        filename: 'bundle.js'   // 打包后文件名
    },
    module:{
        rules:[
           	//style-loader将JS字符串生成style节点
            //css-loader将CSS转化为CommonJS模块
           {
            test: /\.(png|jpeg|jpg|gif|svg)$/,
            use:[{
                loader:'url-loader',
                options:{
                    limit:11024,
                    fallback:{
                        loader:'file-loader',
                        options:{
                            name:'[name].[hash:6].[ext]'
                        }
                    }
                }
            }],
            exclude:/node_modules/
        },
        {
            test:/\.js$/,
            exclude:/(node_modules|bower_components)/,
            use:{
                loader:'babel-loader',
                options:{
                    presets:['@babel/preset.env'],
                    plugins:[
                        '@babel/plugin-transform-runtime'
                    ]
                }
            }
        },
        {
            test:/\.css$/,
            use:['style-loader','css-loader'],
            exclude:/node_modules/
        },
        {
           test:/\.scss$/,
           use:['style-loader','css-loader','sass-loader'],
           exclude:/node_modules/
        },
        {
            test:/\.less$/,
            use:['style-loader','css-loader','less-loader'],
            exclude:/node_modules/
        },
        {	//字体打包
            test:/\.(woff|woff2|eot|ttf|otf)$/,
            use:[
                'file-loader'
            ]
        }    
        ]
    }
};
```

*可使用MiniCssExtractPlugin插件分开打包CSS和JS

```js
npm i mini-css-extract-plugin -D
//1.在webpack.config.js顶部引入插件
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

//2.添加到plugins和rules中
module.exports = {
    entry: __dirname + './src/main.js', // 入口文件路径
    output: {
        path: __dirname + './dist', // 存放打包后文件的路径
        filename: 'bundle.js'   // 打包后文件名
    },
    plugins:[
        new MiniCssExtractPlugin({
            filename:'[name].[hash:6].css'
        })
    ],
    module:{
        rules:[
            {
                test:/\.css$/,
                use:[MiniCssExtractPlugin.loader,'css-loader'],
                exclude:/node_modules/
            }
        ]
    }
```

*CSS兼容浏览器处理:postcss

```js
//使用postcss插件
npm i postcss-loader autoprefixer(兼容低版本) postcss -D

//1.在webpack.config.js同目录下新建文件postcss.config.js，并在其中配置
module.exports = {
    plugins: [
        require('autoprefixer')({
            /* ...options */ })
    ]
}
//2.在webpack.config.js中创建依赖关系,以less为例
{
            test:/\.less$/,
            use:['style-loader','css-loader','less-loader','postcss-loader'], //postcss-loader必须放在最后使用
            exclude:/node_modules/
        }
```

**4.创建NPM脚本快捷指令**
在 package.json 添加一个 npm 脚本(npm script)
```js
{
	"script":{
		"test":"echo \...",
		"build":"webpack"
	}
}

//即可使用npm run build命令打包
```
**5.配置自动引入打包好的JS插件:html-webpack-plugin**
```js
npm i html-webpack-plugin -D
```
在webpack.config.js中配置
```js
const HtmlWebpackPlugin = require('html-webpack-plugin'); //自动引入打包生成得js

plugins: [ //plugins 插件用于执行范围包括，从打包优化和压缩，一直到重新定义环境中的变量
        new HtmlWebpackPlugin({
            minify: {
                collapseWhitespace: true, //清除空格
                removeAttributeQuotes: true, //清除多余引号
                removeComments: true //删除注释

            },
            title: 'Output Management', //替代原title，需要在src文件夹下的index.html中配置
            template: path.resolve(__dirname, './src/index.html'), //要打包的html文件路径
            filename: 'index.html' //打包后输出的html文件名
        })
    ],
```
然后在index.html文件中设置title
```html
<title><%= htmlWebpackPlugin.options.title %></title>
//把 Document 设置为 <%= htmlWebpackPlugin.options.title %>,这样打包完成后title会自动变成src引入JS和CSS文件
```
**6.清理dist中不必要的垃圾文件**
```js
//安装清理插件
npm i clean-webpack-plugin -D
```
在webpack.config.js中配置
```js
const { CleanWebpackPlugin } = require("clean-webpack-plugin");

plugins: [  //plugins 插件用于执行范围包括，从打包优化和压缩，一直到重新定义环境中的变量
        new CleanWebpackPlugin() 
]
```
**7.压缩单独的CSS文件**
```js
npm i optimize-css-assets-webpack-plugin -D
```
在webpack.config.js中配置
```js
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin'); //压缩单独的css文件

plugins: [ //plugins 插件用于执行范围包括，从打包优化和压缩，一直到重新定义环境中的变量
        new OptimizeCssAssetsWebpackPlugin(),
]
```
**8.去除无用CSS样式**
```js
npm install purifycss-webpack purify-css -D
```
在webpack.config.js中配置
```js
const PurifyCSSPlugin = require('purifycss-webpack'); //css优化去重复无效代码
const glob = require('glob'); //css优化
plugins: [ //plugins 插件用于执行范围包括，从打包优化和压缩，一直到重新定义环境中的变量
        new PurifyCSSPlugin({
            paths: glob.sync(path.join(__dirname, './src/*.html')),
        })
]
```
**使用DefinePlugin设定创建全局变量**
利用全局变量这一点来设置全局变量来区分开发环境和正式环境
在webpack.config.js中配置
```js
const webpack = require('webpack');

new webpack.DefinePlugin({
'SERVICE_URL': JSON.stringify('https://dev.example.com'),
  PROCESS.VERSION:  JSON.stringify('2.0.1'),
  PROCESS.ENVIRONMENT:  '"dev"'
  'process.env': {
        NODE_ENV: JSON.stringify(process.env.NODE_ENV)
    }               
});
```
注意：该plugin直接做文本替换，指定的值必须包括引号。
一般来讲，需要使用单引号"production"或使用JSON.stringify('production')
DefinePlugin中的每个键，是一个标识符或者通过.作为多个标识符。

如果value是一个字符串，它将会被当做code片段
如果value不是字符串，它将会被stringify(包括函数)
如果value是一个对象，则所有key的定义方式相同。
如果key有typeof前缀，它只是对typeof 调用定义的。
process.env.NODE_ENV ：大概说说这个变量的问题，在node中，有全局变量process表示的是当前的node进程。process.env 属性返回的是一个包含用户环境信息的对象，process.env中并不存在NODE_ENV这个东西。NODE_ENV是用户一个自定义的变量，在webpack中它的用途是判断生产环境或开发环境的依据的。
我们可以直接在cmd环境配置即可，查看环境变量，添加环境变量，删除环境变量等操作。
```js
#node中常用的到的环境变量是NODE\_ENV，首先查看是否存在 
set NODE\_ENV 

#如果不存在则添加环境变量 
set NODE\_ENV\=production 

#环境变量追加值 set 变量名\=%变量名%;变量内容 
set path\=%path%;C:\\web;C:\\Tools 

#某些时候需要删除环境变量 
set NODE\_ENV\=
```
因此利用这一点，我们可以在我们package.json文件中进行修改，
package.json 文件代码如下
```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "NODE_ENV=production webpack",
    "dev": "NODE_ENV=development"
  },
```
当设置完以后 npm run build 打包，这个时候process.env.NODE_ENV 才会真正打印出 production，可以尝试在src文件下的index.js进行打印测试console.log(process.env.NODE_ENV)

**cross-env跨平台设置和使用环境变量的脚本**
当我们使用 NODE_ENV = production 来设置环境变量的时候，大多数windows命令会提示将会阻塞或者异常，或者，windows不支持NODE_ENV=development的这样的设置方式，会报错。此时使用cross-env
```js
npm install cross-env -D
```
在package.json中修改：
```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "cross-env NODE_ENV=production webpack",
    "dev": "cross-env NODE_ENV=development"
  },
```
**9.设置全局变量来区分开发环境和正式环境**
在根目录下创建config文件夹并新建api.js
```js
//api.js
const NODE_ENV = process.env.NODE_ENV;

const config = {
     production: {
        FOO_API: 'production.foo.com',
        BAR_API: 'production.bar.com',
        BAZ_API: 'production.baz.com',
     },
     development: {
        FOO_API: 'development.foo.com',
        BAR_API: 'development.bar.com',
        BAZ_API: 'development.baz.com',
     },
     test: {
        FOO_API: 'test.foo.com',
        BAR_API: 'test.bar.com',
        BAZ_API: 'test.baz.com',
     }
}

module.exports = config[NODE_ENV];
```
并设置package.json的scripts
```js
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build:qa": "cross-env NODE_ENV=test webpack",
    "build:dev": "cross-env NODE_ENV=development",
    "build:prod": "cross-env NODE_ENV=production webpack"
  },
```
配置webpack.config.js
```js
const apiConfig = require('./config/api'); //引入config/api.js 文件
new webpack.DefinePlugin({
    'SERVICE_URL': JSON.stringify('https://dev.example.com'),
    'process.env': {
        NODE_ENV: JSON.stringify(process.env.NODE_ENV)
    },
    API_CONFIG: JSON.stringify(apiConfig)
}),
```
**10.使用source-map调试代码**
devtool可选值:
- source-map 【用于生产环境】
- eval-source-map
- eval-cheap-module-source-map
- eval-cheap-source-map
- eval 【建议开发环境用这个】

就可以把打包后的代码变成和开发的时候一样，直接在文件webpack.config.js进行引入
```js
devtool :'source-map', //更容易地追踪错误和警告,方便在浏览器看见编译之前的代码，而非编译之后的
// 1、source-map：产生文件，产生行列
// 2、eval-source-map：不产生文件，产生行类
// 3、cheap-source-map：产生文件，不产生列
// 4、cheap-module-eval-source-map：不产生文件，不产生列
```
**11.搭建本地运行环境:webpack-dev-serve**
```js
npm install webpack-dev-server -D
```
在webpack.config.js中配置
```js
devServer: {
        contentBase: path.join(__dirname, "./dist"), // 开服务器的根路径,和output同目录
        historyApiFallback: true, //这个配置属性是用来应对返回404页面时定向到特定页面用的，任意的 404 响应都可能需要被替代为 index.html
        host: '0.0.0.0', //设置服务器的主机号，默认是localhost
        port: 7000, //输出端口号
        inline: true, //实时刷新 package.json文件scripts dev中添加--inline后可以不需要添加
        hot: true, //热替换功能 即不刷新页面，只对于修改的部分进行调整。默认是不设置就是会刷新页面
        compress: true, //这是一个布尔型的值，当它被设置为true的时候对所有的服务器资源采用gzip压缩
        overlay: true, //用于在浏览器输出编译错误的，默认是关闭的，需要手动打开
        stats: "errors-only", //这个配置属性用来控制编译的时候shell上的输出内容，因为我们并不需要所有的内容，而只是需要部分的如errors等
        open: true, // 自动打开浏览器
        proxy: {
             "/api": {
                 target: "http://localhost:3000",
                 pathRewrite: { "^/api": "" }
             }
         } //重定向是解决跨域的好办法，当后端的接口拥有独立的API，而前端想在同一个domain下访问接口的时候，可以通过设置proxy实现。
        //一个 “/api/users”地址的请求将被重定向到”http://10.10.10.10:3000/api/users“,如果不希望”api”在传递中被传递过去，可以使用rewrite的方式实现。
    },
```
在package.json中设置：
```js
"scripts": {
    "dev": "cross-env NODE_ENV=development webpack-dev-server --inline"
  }
```
**12.模块热更新**
模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新，一般用于开发环境
配置devServer
```js
devServer: { 
    contentBase: \[path.join(\_\_dirname, "dist")\], 
    compress: true, port: 9000, // 启动端口号 
    hot: true, // 启用 webpack 的模块热替换特性 
    inline: true, 
    publicPath: "/", // 和上文 output 的“publicPath”值保持一致 
}
```
配置webpack.config.js
```js
plugins: [ // 开启全局的模块热替换(HMR)  
    new webpack.HotModuleReplacementPlugin(), 
    // 当模块热替换(HMR)时在浏览器控制台输出对用户更友好的模块名字信息  
    new webpack.NamedModulesPlugin()
]
```

**13.搭建Vue项目**
```js
npm install vue-loader vue-template-compiler vue-style-loader -D
npm install vue -S

//vue-loader 作用解析.vue文件
//vue-style-loader 作用解析.vue的css
//vue-template\-compiler 作用编译模板
//vue 一个用于构建用户界面渐进式的MVVM框架
```
进行webpack.config.js配置
```js
const VueLoaderPlugin = require('vue-loader/lib/plugin');

plugins: [
    new VueLoaderPlugin()
]

module:{
	rules:[
		{
                test: /\.vue$/,
                use: [
                    'vue-loader'
                ],
                exclude: /node_modules/
            }
	]
}
```
*修改index.html文件

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title><%= htmlWebpackPlugin.options.title %></title>
</head>
<body>
     <div id="app"></div>
     <script src="./dist/bundle.js"></script>
</body>
</html>
```

**总结**

webpack-dev-server可以开启本地服务器，或者设置proxy代理

source-map 可以生成.map文件，方便调试

mode取值development或者production，production模式下js会自动压缩

loader与plugin

- html-webpack-plugin 可以将打包后的资源自动引入到html中
- style-loader css-loader可以支持css模块
- sass-loader node-sass 可以支持sass
- less-loader 可以支持less
- postcss-loader autoprefixer 可以支持自动加css前缀
- mini-css-extract-plugin 或者 extract-text-webpack-plugin可以支持css从js中抽离
- optimize-css-assets-webpack-plugin 可以压缩css
- purify-css purifycss-webpack 可以去除无用的css
- babel-loader @babel/core 可以支持es6语法
- @babel/preset-env 是根据浏览器或者运行环境来将es6转化成es5，比如根据browserslist
- 补充说明1：@babel/polyfill 是对es6降级es5的一个垫片，是对babel-loader的补充，但是会污染全局，不能按需引入，不建议这种方式
- 补充说明2：@babel/runtime @babel/plugin-transform-runtime也是对es6降级es5的一个垫片，可以按需引入，模块化加载，不污染全局，推荐使用
- file-loader 或者 url-loader可以支持引入文件
- file-loader不支持小文件转化为base64格式，但是可以为文件名添加hash值，url-loader可以支持小文件转化为base64格式，这两个可以搭配使用
- vue-loader vue-template-compiler 可以支持编译.vue文件
- clean-webpack-plugin 可以清除打包后的文件夹
- webpack.HotModuleReplacementPlugin webpack自带的热替换plugin与devServer的hot:true结合使用，使页面可以不刷新

## Vue-CLI(重点)

- 如果只是写几个简单的demo则不需要用到vue/cli
- 如果你在开发大型项目，那必然需要使用vue/cli
  - 使用Vue开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情
  - 如果每个项目都要手动完成这些工作，那无疑效率底下，所以通常会使用脚手架工具来帮助完成
- CLI是什么
  - CLI全称时Command-Line Interface，翻译为命令行界面，但是俗称脚手架
  - Vue CLI是一个官方发布的vue.js项目脚手架
  - 使用vue-cli可以快速搭建Vue开发环境以及对应的webpack配置
- CLI  2.x和3.x的区别
  - cli3是基于webpack4打造，cli2是基于webpack3
  - cli3的设计原则是"0配置"，移除配置文件根目录下的，build和config等目录
  - cli3提供了vue ui命令，提供了可视化配置，更加人性化
  - 移除了static文件夹，新增了public文件夹，并且index.html移动到了public中

*安装全局 CLI 3.x：npm i -g @vue/cli       安装后通过 vue - -version  查看版本

*注意：如果需要 拉取CLI 2.x版本 则需要使用以下指令：

```
npm i @vue/cli-init -g
```

2.x  创建项目：vue init webpack my-project(项目名) 

3.x  创建项目：vue create my-project(创建一个官方提供的空的项目模板)

*CLI 3.x可以通过 vue ui 指令进行图形化管理

- 选择手动安装模式(manually),用空格选择需要安装的组件
- 在创建好的demo1根目录下运行npm run serve 
- 得到模板，删除一些不相关文件，只留下框架部分
- 在根目录下创建一个 vue.config.js文件 -----  实际开发中很多配置需要自己修改

**Runtime only和Runtime + Compiler**

CLI生成时会提示选择两个版本，这两个版本有何区别呢？

- Runtime Only：

   在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量 

- Runtime + Compiler：

   如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板 

  Vue.js 最终渲染都是通过 render 函数。 template 属性最终也会被编译器编译成 render 函数。使用 template 属性的时候就需要引入带编译器的 vue.js，因为带编译器的版本会在浏览器中将 template 转换为 render 函数。在客户的浏览器中进行编译会花费一些时间

- runtime+compiler流程:template -> ast -> render -> v-dom -> UI
- runtime-only流程:render -> v-dom -> UI

**CLI创造组件中引入assets中的CSS样式**

*通过@import+'CSS文件位置'，在JS文件中用import，在组件中则是@import

*components和views文件

1. components用来存放不同路由不同页面中共用的组件
2. views中存放一个路由页面下的子组件和样式

### render函数渲染组件

 *`render 函数` 跟 `template` 一样都是创建 html 模板的，但是有些场景中用 `template` 实现起来代码冗长繁琐而且有大量重复，这时候就可以用 `render 函数`

render函数的参数-----createElement(也是个函数)

```js
render:function(createElements){
	return createElement('自定义标签名',{标签属性},['标签内容'])
}
//在webpack中，如果想要通过vue，把一个组件放到页面中去展示，vm 实例中的render函数 可以实现
//以上代码可以用ES6简写：
render: c => c(自定义组件名)
```



## Vue SSR

*Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序

服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在**服务器**和**客户端**上运行

**为什么使用SSR**

- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面

  请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题

- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要

使用服务器端渲染 (SSR) 时还需要有一些权衡之处：

- 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行
- 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境
- 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略

# Axios

*Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中

*网络请求模块选择：

1. 传统的Ajax是基于XMLHttpRequest(XHR)----配置和调用过程混乱，封装过程复杂，容易出现BUG
2. jQuery-Ajax----相对于传统Ajax非常好用，但是需要引用jQuery框架，不合理
3. vue-resource----vue官方推出，但是vue2.0以后已经不再更新
4. axios----使用方便，官方推荐，支持在node中使用，发送http请求，支持promise API

- 安装axios：npm i axios vue-axios -S
- 导入：(在main.js文件中)import axios from 'axios'

- 使用：在new Vue({ })后创建axios({ })

axios中的具体配置过程

```js
//以对象配置的方式进行指定请求方式
axios({
    //整个网页的根目录
    baseURL:'http://'
	//建立在根目录上的地址
    url:'/xxx',
	//设置请求方式
	method:'get'
    //使用params定义url后面跟的具体数据，
    //params专门针对get请求的参数拼接
    params:{ 
    	//需要传递type和page，这里相当于是url:'http://xxx?type=pop&page=1'
   		type:'pop',
    	page:1
}
//axios支持promise所以可以使用 .then方法
}).then(res=>{
	console.log(res);
}).catch(err...)
```

*注意：get请求对应params，post请求对应data不然会出错

**特别注意：**在Vue中使用axios.get(API).then((res)=>{}) 必须使用箭头函数 或者 var that = this。因为then不能使用Vue实例化的this，内部的this没有被绑定。

### axios全局配置

```js
axios.defaults.baseURL="http://..." //在aixos中就不需要在设置baseURL
axios.defaults.timeout = 5000 //请求最大响应时间，单位是毫秒
```

### axios.all( )执行多个并发请求

```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // 两个请求现在都执行完成
  }));
```

### axios.interceptors 拦截器

*在请求和响应被 .then 或 .catch 处理前拦截

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

### 响应结构

*请求的响应包含哪些信息

```js
axios.get('/user/12345')
  .then(function(response) {
    console.log(response.data); //由服务器提供的响应
    console.log(response.status); //来自服务器响应的HTPP状态码
    console.log(response.statusText); //来自服务器响应的HTTP状态信息
    console.log(response.headers); //服务器响应的头
    console.log(response.config); //为请求提供的配置信息
  });
```

### axios API

**并发处理**

| 方法                   |      |
| ---------------------- | ---- |
| axios.all(iterable)    |      |
| axios.spread(callback) |      |

**自定义创建实例**

| 方法                   |      |
| ---------------------- | ---- |
| axios.create([config]) |      |

**实例方法**

| 方法                               |      |
| ---------------------------------- | ---- |
| axios.request(config)              |      |
| axios.get(url[, config])           |      |
| axios.delete(url[, config])        |      |
| axios.head(url[, config])          |      |
| axios.post(url[, data[, config]])  |      |
| axios.put(url[, data[, config]])   |      |
| axios.patch(url[, data[, config]]) |      |



### axios实例和模块封装

*由于服务器端可能是多服务器，每个服务器的接口地址不同，采用创建多个axios接口对应实例的方式解决

```js
const instance = axios.create({
    baseURL:'http://..',
    timeout:5000
})
//实例中的参数也是context
instance({
	url:'/..',
	params:{
		type:'xx',
		page:1
	}
}).then(res=>{
	console.log(res)
})
```

*真实开发情况下，不要将axios写在main入口文件中，最好对框架进行一个封装，如果需要修改框架，就只要在封装文件中修改，节省时间

- cli中有个单独的store文件，在store文件夹下创建一个network子文件夹，可以将网络层的封装偶读放入其中，在network文件中创建一个request.js

```js
//第一种回调函数的方式
//模块使用了axios，所以必须调用axios模块
import axios from 'axios'

export function request(config,success,failure){
    //1.创建axios实例，必须创建实例而不是全局属性
    const instance = axios.create({
        baseURL:'http://123.207.32.32:8000',
        timeout:5000
    })
    //发送真正的网络请求,通过success和failure回调出去
    instance(config,baseConfig)
    .then(res=>{
        config.success(res)
    })
    .catch(err=>{
        config.failure(err)
    })
}

//调用request的方法
import { request } from './network/request'

request({
    url:'/'
},res=>{ //通过success和failure拿到回调
    console.log(res);
},err=>{
    console.log(err);
})
```

```js
//另一种promise方式的写法
export function request(config){
	return new Promise((resolve,reject)=>{
		const instance = axios.create({
        baseURL:'http://123.207.32.32:8000',
        timeout:5000
    })
    instance(config)
        .then(res=>{
            resolve(res)
        })
        .catch(err=>{
            reject(err)
    	})
	})
}

//调用
request({
	url:'/'
}).then(res=>{
	console.log(res)
}).catch(err=>{
	console.log(err)
})
```

```js
//promise简写
export function request(config){
    const instance = axios.create({
        baseURL:'http://123.207.32.32:8000',
        timeout:5000
    })//实际上instance方法在这里就变成了一个promise
    return instance(config)
 }
```

### axios拦截器

*对网络请求的过程进行拦截，进行对应的处理，比如修改请求数据和增加请求动画等等，使前端开发过程中可以脱离后端

```js
//axios实例的拦截器，request和response都需要两个函数
instance.interceptors.request.use(config=>{
	return config//拦截完一定要返回config
},err=>{
    //返回带有拒绝信息的promise对象
  return Promise.reject(err)
})
//会拦截下整个config，里面包含所有请求数据
instance.interceptors.response.use(res=>{
    //data是真正需要的res中的数据
    res.data
    return res.data //data也是必须要返回的数据
},err=>{
    return Promise.reject(err)
})
```

# WebSocket&Socket.io

WebSocket是HTML5新增的一种全双工通讯协议，客户端和服务端基于TCP握手连接成功后，两者之间就可以建立持久性的连接，实现双向数据传输

Socket.io是一个WebSocket库，包括了客户端js和服务器端的nodejs，用于浏览器和服务器间的实时，双向和基于事件的通信。它是WebSocket和Engine.IO共同实现的

## Socket.io特性

易用性：封装了服务器端和客户端，使用便捷

跨平台：支持跨平台，可在不同平台下开发

自适应：自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等各种方式中选择最佳的方式来实现网络实时应用

兼容性：支持低版本浏览器

可靠性：依赖与Engine.IO，即便有防火墙和杀毒软件或者代理也可以正常连接，支持自动重新连接，通过心跳机制实现断线检测

多路传输支持：允许创建多个Namespaces，充当单独的通信通道，它们也共享相同的基础连接

客房支援：每个Namespaces中，可以定义套接字可以加入或离开的任意通道，称为Rooms，用于向一组用户或连接多个设备的给定用户发送通知

【套接字(socket)是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合】

## Socket.io搭建

**使用Node http服务器搭建**

```js
//----安装-----
$npm i socket.io

//---服务器端-----
var app = require('http').createServer(handler)
var io = require('socket.io')(app);
var fs = require('fs');

app.listen(80);

function handler (req, res) {
  fs.readFile(__dirname + '/index.html',
  function (err, data) {
    if (err) {
      res.writeHead(500);
      return res.end('Error loading index.html');
    }

    res.writeHead(200);
    res.end(data);
  });
}

io.on('connection', function (socket) {
  socket.emit('news', { hello: 'world' });
  socket.on('my other event', function (data) {
    console.log(data);
  });
});

//---客户端---
<script src="/socket.io/socket.io.js"></script>
<script>
  var socket = io('http://localhost');
  socket.on('news', function (data) {
    console.log(data);
    socket.emit('my other event', { my: 'data' });
  });
</script>
```



# React



# Hybrid App

*Hybrid是半Native半Web开发模式，充分利用H5的跨平台、快速迭代能力以及Native的流畅性、系统API调用能力，具有可复用性高、开发成本低、跨平台开发的特点

- Native App：原生App
  - 优点：交互效果好体验佳，能够调用移动硬件功能(GPS,相机等)
  - 缺点：需要开发安卓和iOS两套应用，需要用户下载更新，发版审核时间长
- Web App：移动web
  - 优点：入门简单，成本低，可实现跨平台和快速更新
  - 缺点：不可以访问设备硬件和离线储存，音视频体验不佳
- Hybrid App：混合App
  - 优点：开发效率高，跨平台，快速更新，成本低
  - 缺点：不能直接操控硬件(低性能)

*混合开发任务分配原则：

- 业务关联性强的用H5
- 都能做的用H5
- H5受限时换原生
- 交互性强的用原生

**Hybrid中Native能力设计和调试**

1. 账号体系建设：
   - 登录打通：
     1. (推荐)直连方式使用Ajax请求接口，token由客户端存入cookie中，如果没有登录就在底层唤起原生登录框
     2. 前端获取token后放入header里调用接口
2. 头部Header设计：(标题、背景图片 / 分享【图文，图片，小程序】/ 返回、关闭 / 导航)
3. 常见H5与app功能性交互：
   - 相册，扫码，GPS
   - 唤醒app或下载app
   - 唤醒原生页面
   - 打开新webview中的H5【保留原页面的基础上打开新页面，性能优于vue的keep-alive】
   - 分享【图文，图片，小程序】
4. 协议联调和文档维护：
   - app端提供测试后门
   - 前端准备测试demo
   - 及时更新文档和demo

**多场景判断和统一收口**

1. 跳转地址方法
2. 设备环境判断
3. App判断
4. 内嵌环境判断

**版本和手机兼容**

1. 全局在body上添加手机环境判断【通过媒体巡查判断手机种类添加特定class类】
2. 安卓手机按钮不居中【按钮高1-2px】
3. IPX底部有弧度【先判断是否是iOS然后根据屏幕高度判断具体型号】

cordova框架

# 微信小程序 

小程序是微信生态的一部分，它提供了更加 **方便和高效** 的用户交互方式 

## 小程序简介

**微信小程序的优势**

1. 用户使用的便携性
   - 普通的APP我们需要的使用过程：了解APP - 下载 - 打开 - 注册 - 使用
   - 小程序版本的APP使用过程：了解APP - 打开(扫码/搜索) - 使用

2. 用户体验远高于公众号和H5页面的体验
3. 依托于微信，没有内存空间要求
   - 对于手机空间要求很低
   - 小程序不需要安装，而且有规定的大小(不能超过8M，包括使用分包的情况)

4. 让手机桌面更加简洁
   - 不需要下载APP，不需要花时间管理APP

5. 底层可以调用原生接口，真正做到一端(H5)开发多端(iOS、Android)运行

**WebView的发展**

- 随着公众号的出现，WebView的使用频率越来越高，H5的需求也越来越大
- H5页面的劣势明显：**体验太差**，且无法调用很多底层APP拥有的功能
- 微信团队提供的JS-SDK扩充功能给开发者使用仍然无法改善体验

**Nativa的优势和劣势**

- 很长一段时间人们都认为解决H5体验差的问题，都需要使用**原生**去解决【类似于Weex、React Native的开发方式去接近原生应用】
- 但是Native有很多弊端：开发门槛高、多端开发、版本迭代慢、更新需要审核

**综合优势的开发方案**

| -        | Native         | Web              | 期望(小程序) |
| -------- | -------------- | ---------------- | ------------ |
| 开发门槛 | 高             | 低               | 低           |
| 体验     | 好             | 白屏、交互反馈差 | 接近原生体验 |
| 版本更新 | 需审核、迭代慢 | 在线更新         | 在线更新     |
| 管控性   | 平台可管控     | 难管控           | 可管控       |

**小程序特点**

- 类似于Web开发模式，入门的门槛低：类似于HTML+CSS+JS
- 可直接云端更新：微信审核，无需经过App Store等平台
- 提升用户体验：通过提供基础能力、原生组合结合等方式，提升用户体验
- 平台管控能力：小程序提供云端更新，通过代码上传、审核等方式，增强对开发者的管控能力
- 双线程模型：逻辑层和渲染层分开加载，提供了管控性和安全性【沙盒环境运行JS代码，不允许执行任何浏览器相关接口，比如跳转页面、操作DOM等】

**小程序开发分为三个部分**

- 页面布局：WXML，类似HTML
- 页面样式：WXSS，CSS的增强版本
- 页面脚本：JavaScript+WXS【WeixinScript类似于JS】

**应用程序目录结构**

```
├── 文件结构
	└── APP
        ├── app.js  #创建app实例的代码以及一些全局相关的内容
        ├── app.json  #全局的配置，比如window/tabbar等
        ├── app.wxss  #全局的一些样式配置
	└── Page 
        ├── page.js  #创建Page实例的代码，以及页面相关的内容 
        ├── page.json  #业务单独的配置，比如页面对应的window配置，usingComponent
        ├── page.wxml #页面的wxml布局代码
        ├── page.wxss  #页面的样式配置
	└── Component
        ├── component.js  #创建Component实例的代码，以及组件内部的内容
        ├── component.json  #组件内部的配置，比如当前组件使用了别的组件
        ├── component.wxml  #组件的wxml布局代码
        ├── component.wxss  #组件的样式配置 
```

**常见配置文件**

- project.config.json：项目配置文件：项目名称/Appid
- sitemap.json：配置微信内搜索
- app.json：全局配置
- page.json：页面搜索

## wxss

- 尺寸单位
  - rpx：可以更具屏幕宽度自适应【规定屏幕宽为750rpx】
  - 如在iphone6上，屏幕宽度为375px，共有750个物理像素，则750rpx=375px=750个物理像素，1rpx=0.5px=1物理像素【rpx换算px的比值和屏幕尺寸有关，一般按两倍计算】

- 拆分不同组件wxss文件
  - 在主wxss中使用@import导入
  - @import后跟随相对或绝对路径，以 ；号结尾

- 公共样式在app.wxss中设置

- 官方样式库：WeUI.wxss基本样式库【用微信开发者工具打开 .\weui-master\dist 文件夹，然后直接从打开的 官方样式项目 中选取相关样式找到代码 截取 到自己项目即可】
  -  组件的wxml结构请看`dist/example/`下的组件 
  -  样式文件可直接引用`dist/style/weui.wxss`，或者单独引用`dist/style/widget`下的组件的`wxss` 

## wxs

WeiXin Script - 小程序脚本语言【仅支持ES5语法】

- 由于WXML不可以直接调用Page/Component中定义的函数，所以需要使用WXS来处理WXML中的数据【类似于Vue过滤器】

**格式写法**

```html
// wxs写在wxml中作为一个标签使用
<wxs module="m1">
var msg = "hello world";

module.exports.message = msg;
</wxs>

<view> {{m1.message}} </view>

//数据处理
// page.js
Page({
  data: {
    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]
  }
})

<!--wxml-->
<!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 -->
<wxs module="m1">
var getMax = function(array) {
  var max = undefined;
  for (var i = 0; i < array.length; ++i) {
    max = max === undefined ?
      array[i] :
      (max >= array[i] ? max : array[i]);
  }
  return max;
}

module.exports.getMax = getMax;
</wxs>

<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
<view> {{m1.getMax(array)}} </view>
```

注：当wxs代码量太大时，可以通过拆分的方式编写进wxs文件夹【wxs组件引入的形式】中统一管理，再通过`<wxs src="../../wxs/xxx.wxs" module="xxx" />`【wxs必须使用相对路径，不可以使用绝对路径】，在wxs文件中直接写入function最后module.exports即可

## 全局配置

- 全局配置较多，在文档上有详细描述，列举几个重要的

| 属性   | 类型   | 必填 | 描述               |
| ------ | ------ | ---- | ------------------ |
| pages  | string | 是   | 页面路径列表       |
| window | Object | 否   | 全局的默认窗口表现 |
| tabBar | Object | 否   | 底部tab栏的表现    |

- pages：页面路径列表【相当于路由path】
  - 用于指定小程序由哪些页面组成，每一项都对应一个页面的**路径信息**
  - 小程序中所有页面都是必须在pages中进行注册的
- window：全局的默认窗口展示
  - 用户指定窗口如何展示，其中还包含了很多其他属性
- tabBar：底部tab栏的展示

## wx属性

标签内属性，类似于vue的v-bind

| 属性[wx:属性名="{{变量名}}"] | 用法                                               |
| ---------------------------- | -------------------------------------------------- |
| wx:for="{{number}}"          | 遍历，渲染数组中的每一项数据，遍历尽量使用block标签       |
| wx:if="{{true/false}}"       | 条件判断是否渲染该组件，false【元素在DOM中不存在】 |
| wx:elif=""                   | wx:if的配合属性，elif是else if的简写               |
| wx:else=""                   | wx:if的配合属性                                    |
| wx:hidden="{{true/false}}"   | 隐藏元素，true【元素在DOM中依然存在】              |
|                              |                                                    |

## 小程序双线程模型

- **微信客户端**是小程序的宿主环境
  - **宿主环境**为了执行小程序的各种文件：wxml文件、wxss文件、js文件
  - 提供了小程序的**双线程模型**【渲染层-WebView线程、逻辑层-JsCore线程，最后通过微信客户端-Native进行交互】

## 界面渲染过程
**wxml和DOM树**
注：wxml等价于一个DOM树，也可以使用一个JS对象来模拟【虚拟DOM】

**初始化渲染**
wxml先转化为JS对象，然后通过WebView渲染进真正的DOM树

**数据变化**
- 产生的JS对象对应的节点发生变化
- 此时可以  【diff算法】对比前后两个JS对象  得到变化的部分
- 然后把这个**差异**应用到原来的DOM树上
- 从而达到更新UI的目的，这就是**数据驱动**原理

**界面渲染整体流程**
- 在渲染层，宿主环境会把**wxml**转化成对应的JS对象
- 将JS对象再次转成真实DOM树，交由渲染成线程渲染
- 数据变化时，逻辑层提供最新的变化数据，JS对象发生变化比较进行**diff算法**
- 将最新的变化的内容反映到真实的DOM树中，更新UI

## 生命周期
**页面page实例的生命周期**

 ![img](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png) 

**App生命周期及参数**

| 属性           | 类型     | 说明                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| onLaunch       | function | 生命周期回调：监听小程序初始化                               |
| onShow         | function | 生命周期回调：监听小程序启动或切前台                         |
| onHide         | function | 生命周期回调：监听小程序切后台                               |
| onError        | function | 错误监听函数                                                 |
| onPageNotFound | function | 页面不存在的监听函数                                         |
| 其他           | any      | 开发者可以添加任意的函数或者数据变量到Object参数中，用this可以访问 |

**Page页面生命周期及参数**

| 属性              | 类型     | 说明                                                         |
| ----------------- | -------- | ------------------------------------------------------------ |
| onLoad            | function | 生命周期回调—监听页面加载                                    |
| onShow            | function | 生命周期回调—监听页面显示                                    |
| onReady           | function | 生命周期回调—监听页面【初次】渲染完成                        |
| onHide            | function | 生命周期回调—监听页面隐藏                                    |
| onUnload          | function | 生命周期回调—监听页面卸载                                    |
| onPullDownRefresh | function | 监听用户下拉动作                                             |
| onReachBottom     | function | 页面上拉触底事件的处理函数                                   |
| onShareAppMessage | function | 用户点击右上角转发                                           |
| onPageScroll      | function | 页面滚动触发事件的处理函数                                   |
| onResize          | function | 页面尺寸改变时触发                                           |
| onTabItemTap      | function | 当前是 tab 页时，点击 tab 时触发                             |
| 其他              | any      | 开发者可以添加任意的函数或者数据变量到Object参数中，用this可以访问 |

## 常见内置组件

## 常见事件类型
- tap事件

| 事件名             | 触发条件 |
| ------------------ | -------- |
| bindtap/bind:tap   |          |
| catchtap/catch:tap |          |
|                    |          |

- input事件

| 事件名    | 触发条件         |
| --------- | ---------------- |
| bindfocus | 输入框被点击时   |
| bindinput | 输入框输入时     |
| bindblur  | 输入框失去焦点时 |

- scroll-view事件

| 事件名            | 触发条件 |
| ----------------- | -------- |
| bindscrolltowpper |          |
| bindscrolltolower |          |
|                   |          |

- touch事件

| 事件名      | 触发条件                                                     |
| ----------- | ------------------------------------------------------------ |
| touchstart  | 触摸动作开始                                                 |
| touchmove   | 触摸后移动                                                   |
| touchcancel | 触摸动作被打断，如来电或者弹窗                               |
| touchend    | 触摸动作结束                                                 |
| tap         | 触摸后马上离开                                               |
| longpress   | 手指触摸超过350ms再离开，如果指定了事件回调函数，则不会再触发tap事件 |
| longtap     | 手指触摸超过350ms再离开，不如longpress                       |
|             |                                                              |

**事件回调函数event参数解析**

| 属性           | 类型    | 说明 |
| -------------- | ------- | ---- |
| type           | String  | 事件类型 |
| timeStamp      | integer | 页面打开到触发事件所经历的时间ms |
| target         | Object  | 触发事件的组件的一些属性值集合 |
| currentTarget  | Object  | 当前组件的一些属性值集合 |
| detail         | Object        | 额外的信息 |
| touches        | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | Array | 触摸事件，当前变化的触摸点信息的数组 |

**target和currentTarget的区别**

target和currentTarget都是记录当前事件的触发对象，但是当有冒泡情况存在时，currentTarget体现出它只记录触发事件的对象，target则是记录的是产生事件的对象

**touches和changedTouches的区别**

touches用来记录当前有几个手指在程序中触摸且每个触摸点的位置信息
changedTouches用来记录触摸手指数量的变化【比如说从一根手指变为两根手指触摸后，changeTouches则为1，表示增加了一根手指】
注：在touchend事件中，touches的值为0，changeTouches则有手指数量变化值

## 事件参数的传递

注：data-  是暴露事件参数的方法，暴露的参数 在 事件的 event 里

```html
<view class="container">
  <block wx:for="{{titles}}" wx:key="{{index}}">
    <view class="item"
         bindtap='handleItemClick'
    >
      {{item}}
    </view>
  </block>
</view>
//这种遍历的情况下，在hanleIItemClick中的event中不包含item-index中的数据
-----------------------------
//此时可以使用一个特殊属性
<view class="item"
     bindtap='handleItemClick'
      //绑定完成后在 事件event 中的currentTarget中的dataset中即包含了item和index数据
     data-index="{{index}}"
     data-item="{{item}}"
    >
      {{item}}
    </view>
```

##  组件化开发

类似于页面，自定义左键拥有自己的wxml模板和wxss样式
**自定义组件模板**

```html
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点</view>
  <slot></slot>
</view>
------------------
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```
**模板数据绑定**

```html
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

注：以上情况仅一个slot使用的情况下，如果需要使用多个slot则需要额外声明
```javaScript
Component({
  options: {
    multipleSlots: true // 在组件定义时的选项中启用多slot支持
  },
  properties: { /* ... */ },
  methods: { /* ... */ }
})
```

 此时，可以在这个组件的wxml中使用多个slot，以不同的 `name` 来区分 

```html
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>
```

### 页面组件化
小程序中，可以使用Component构造器将单独的页面转变为自定义组件，但是要求引用组件的页面对应的json文件中，必须包含usingComponents定义
```json
{
	"component":true,    // 如果该页面是组件则 必须设置 这个定义
	// 如果该组件内还包含子组件则可以加上usingComponents
	//反之引用组件的主页必须设置usingComponents属性
	"usingComponents":{ //引用组件的页面有这个属性即可
		"设定的自定义组件标签名":"自定义组件的路径"
	}
}
```

注：主页对应App({}),分页对应Page({}),自定义组件对应Component({})

注：在主页中直接使用标签即可
**内外组件样式关系**

- 组件内的class样式只对组件内节点生效，组件内不可以使用id选择器、属性选择器、标签选择器
- 外部组件使用id选择器、属性选择器不会对组件内产生影响，但是标签选择器会
- 如果希望class相互影响，则可以在Component中传入options属性，options属性中有一个styleIsolation(样式隔离)属性它对应有三个值
```js
Component({
	options:{
		styleIsolation:"isolated"
	}
})
```

	isolated：表示启用样式隔离，在自定义组件内外，使用class定义的样式相互无影响
	apply-shared：表示页面wxss样式将影响到自定义组件，但是自定义组件样式不影响页面
	shared：表示页面和自定义组件的样式互相影响

### 组件和页面通信
注：很多情况下，组件内展示的内容【数据、样式、标签】，并不是在组件内写死的，而是根据使用者改变的
**向组件内传递数据-properties**
在组件的js文件中，包含properties属性

```js
//在子组件的js文件中设置父组件传值方式和类型
Component({
	properties:{
		// 1.基本写法
		属性名：属性值类型【String/Number/...】
		// 2.带有默认值和判断的写法
		属性名:{
			type:属性值类型,
			value:属性默认值,  //当没获取到父组件传值时显示
			observer:function(newVal,oldVal){ //还可以使用observer观察传值的变化
				console.log(newVal,oldVal)
			}
		}
	}
})
-------------------------------
//在父组件中，给自定义组件传递数据
<my-prop 属性名="赋予的正确类型的值">
-------------------------------
//在子组件的wxml文件中引入子组件js从父组件接受的值
<view>{{子组件js的属性名}}</view>
```
**父子组件传递样式的方法**
```html
// 在子组件的wxml文件中
<view class="class changeClass">{{子组件属性名}}</view>
--------------------------
//在子组件的js文件中，加入特定属性【和properties同级】
externalClasses:['changeClass']
---------------------------
// 在父组件中传值使用
<my-prop changeClass="red"/>
//在父组件的wxss的创建red类
.red{
	color:red;
}
```

**父子组件传递事件的方法**
使用this.triggerEvent方法发送事件
```js
//在子组件的js文件中使用trigger方法
Component({
	子组件事件名(){
		this.triggerEvent('发送出去的自定义事件名',{需要传递的参数})
	}
})
----------------------------
// 在父组件的wsml中引入子组件事件
<my-event bind:发送出去的自定义事件名='父组件自定义定义的事件' />
--------------------------
// 在父组件js文件中设置父组件自定义事件
Page({
data{},
父组件自定义定义的事件(event){
	console.log(event) //event包含子组件传递的参数
	}
})
```
注：子组件中的事件必须写在methods中

**获取组件对象的方式**
this.selectComponent方法

```html
// 设置一个父组件点击按钮增加子组件counter数值的功能
// 子组件中设置
<view>组件内的计数:{{counter}}</view> //同时在子组件data中注册counter
--------------------
//在父组件中引入子组件
{
  "component": true,
  "usingComponents": {
    "my-sel": "/components/my-sel/my-sel"
  }
}
//父组件wxml中
<my-sel class="sel-class" id="sel-id" />
<button bind:tap="handleIncrementCpn">点击增加counter</button>
---------------------------
//父组件js文件中通过selectComponent获取子组件，再通过setData修改组件中的counter
Page({
  data: {
  },
  handleIncrementCpn() {
    // 修改counter数据,通过使用selectComponent方法
    const my_sel = this.selectComponent('.sel-class')
    my_sel.setData({
      counter:my_sel.data.counter+1
    })
  }
})

```

**还可以通过子组件暴露方法的方式【更合理】**

```js
// 子组件js中
methods:{
	incrementCounter(num){
		this.setData({
			counter:this.data.counter + num
		})
	} 
}
---------------
//父组件js中
const my_sel = this.selectComponent('.sel-class')
my_sel.incrementCounter(10)//假设传入的num是10
```

**getCurrentPages**

该方法可以直接获取当前所有活跃页面的对象，并保存到数组中返回，常用于页面传值

```js
let pages = getCurrentPages();  // 获取当前页面栈
    let prevPage = pages[pages.length - 2]; // -2 就是你上一页的数据 你上上页的数据就是-3 了以此类推！
     // 直接操作上一个页面的 index数据 之后返回 
      prevPage.setData({
        index:index
      },function(){
        wx.navigateBack()
      })
```

###slot-组件插槽

不同页面的某一个模块具有相似性，这时候将这个模块封装成公共组件，使其具有可扩展性，减少了重复工作，只需要修改插槽部分就可以重复使用组件
**单个插槽** 

```html
// 子组件中wxml文件
<view>我是组件的头</view>
<slot />
<view>我是组件的尾</view>
------------------------
//在父组件json文件中注册插槽子组件
// 父组件wxml中使用插槽
<my-slot>
  在这里随便放入各种元素代替插槽的位置
</my-slot>
```
**多个插槽**
注：使用多个插槽需要给每个插槽起名字，同时要在Component中添加options选项
```html
// 子组件中wxml文件
<view>我是组件的头</view>
<view class="slot1"><slot name="slot1" /></view>
<view class="slot2"><slot name="slot2" /></view>
<view class="slot3"><slot name="slot3" /></view>
<view>我是组件的尾</view>
-----------------------------
//在父组件的js文件中
Component({
	options:{
		multipleSlots:true //添加这个属性才可以使用多插槽
	}
})
-----------------------------
//在父组件json文件中注册插槽子组件
// 父组件wxml中使用插槽
<my-slot>
	// 注意： 代替元素需要指名代替的插槽
  <任意元素 slot="slot1">
  <任意元素 slot="slot2">
  <任意元素 slot="slot3">
</my-slot>
```

## Component构造器

**properties--定义传入的属性**

```js
properties:{
	title:String,
	content:{
		type:String,
		value:""
	}
}
```
**data--定义内部属性**

```js
currentIndex:0,
info:{
	name:"coderwhy",
	age:18
},
movies:["星际穿越","盗梦空间"]
```
**methods--定义方法**
```js
methods:{
	onBtnClick(){
		this.setData({
			"info.name":"rene",
			"movies[0]":"大话西游"
		})
	}
}
```
**options--额外配置选项**
```js
options:{
	style:"shared",
	multpleSlots:true
}
```

**externalClasses--引用外部样式**
```js
externalClasses:['title']
```

**observers--属性和数据监听**
```js
observers:{
	title:function(newVal){} //没有oldVal
}
```

**pageLifetimes--监听页面生命周期**

```js
pageLifetimes:{
	show(){}, //监听组件所在页面显示时
	hide(){},	//监听组件所在页面隐藏时
	resize(){}  //监听页面尺寸改变时【不常用】
}
```

**lifetimes--组件生命周期**

```js
lifetimes:{
	created(){}, 
	attached(){}, //组件被添加到页面时
	ready(){},	//组件渲染完成时
	movied(){},		//组件被移动到节点树另一个位置时
	detached(){} //组件被移除时 
}
```

## 小程序API

### 网络请求

使用微信提供的API，用于网络请求：wx.request(Object object)
```js
// 基本的网络请求发送方式 
wx.request({
	url:'域名 ',
	success: function(res){
		console.log(res)
	}
})
```

**request参数**

| 属性         | 类型                      | 必填 | 说明                                                         |
| ------------ | ------------------------- | ---- | ------------------------------------------------------------ |
| url          | string                    | 是   | 开发者服务器接口地址                                         |
| data         | string/object/ArrayBuffer | 否   | 请求的参数                                                   |
| header       | Object                    | 否   | 设置请求的 header，header 中不能设置 Referer。<br/>`content-type` 默认为 `application/json` |
| method       | string                    | 否   | HTTP 请求方法                                                |
| dataType     | string                    | 否   | 返回的数据格式                                               |
| responseType | string                    | 否   | 响应的数据类型                                               |
| success      | function                  | 否   | 接口调用成功的回调函数                                       |
| fail         | function                  | 否   | 接口调用失败的回调函数                                       |
| complete     | function                  | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |

**请求封装**
注：使用工具类对方法进行封装，减少修改的次数

请求封装的优势
1.降低网络请求和wx.request的耦合度
2.淘汰古老的success和fail方式，使用Promise方式获取回调结果

- 设置一个service文件夹，用来存放网络请求文件
- 在service中创建一个network.js文件
```js
// network.js
export default  function request(options){
// 使用创建promise对象获取回调函数
  return new Promise((resolve,reject) => {
    wx.request({
      url: options.url,
      method: options.method || 'get',
      data: options.data || {},
      success: resolve，
      fail: reject
    })
  })
}
----------------------------
//在需要使用request的页面js文件中， 引入请求封装文件
import request from '../../service/network.js'  //注意：这里必须使用相对路径
// 在方法中引入
request({
      url:''
    }).then(res => {
      console.log(res)
    }).catch(err => {
      console.log(err)
    })
```

### 展示弹窗
小程序有四种弹窗方式：showToast  showModal  showLoading  showActionSheet
- showToast只是展示一个icon和文字
- showModal包含了确定和取消按钮，可以获取回调函数
- showLoading就是showToast的loading的样式，但是不会主动消失，需要调用wx.hideLoading()才会消失
```js
handleShowLoading(){
	wx.showLoading({
		tltle:'加载中',
		mask:true
	})
	setTimeout(()=>{
		//手动设置Loading的消失时间
		wx.hideLoading()
	},1000)
}
```
- showActionSheet是底部弹窗，用于选择相册、拍照或者二维码等跳转功能
```js
handleShowAction(){
	wx.showActionSheet({
		itemList:['相册','拍照'],
	})
}
```
### 页面分享
onShareAppMessage页面分享函数
```js
onShareAppMessage:function(options){
	return{
		title:"分享页面的标题",
		path:"分享的页面路径",
		imageUrl:"分享页面大图的地址"
	}
-----------------------------
// 添加分享按钮
<button open-type="share">分享</button>  // 配合js可以直接实现分享功能
```

### 小程序的登录流程
- 调用wx.login获取code

- 调用wx.request发送code到我们自己的服务器，服务器会返回一个登录态标识【token】

- 将登录态的标识token进行存储，以便下次使用

- 请求需要登录态标识的接口时，携带token

**登录流程时许**
![img](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg) 

注：openId是每个微信用户的唯一标识，appid和appsecret在微信小程序网页端控制台内获取

### 页面跳转
通过navigator  和  通过wx的API进行跳转
**navigator**

```html
<navigator url=' '>跳转到xx页</navigator>
```

注意：navigator有open-type、delta属性
1.navigator

| 值  | 说明|
| ---- | ---- |
| navigate【默认】 | 对应wx.navigateTo和wx.navigateToMiniProgram的功能 |
| redirect | 对应wx.redirect的功能 |
| switchTab | 对应wx.switchTab的功能 |
| reLaunch | 对应wx.reLaunch的功能 |
| navigateBack | 对应wx.navigateBack的功能 |
| exit | 退出小程序，target="miniProgram"时生效 |

- redirect：关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到tabBar页面，且不能返回
- switchTab：跳转到tabBar页面，并关闭其他所有非tabBar页面
- reLaunch：关闭所有页面，打开应用中的某个页面【直接展示跳转页面，并且可以跳转到tabBar页面】
2.delta
返回几个层级
```html
// 返回向上两个层级的页面
<navigator delta="2">返回</navigator> 
```
